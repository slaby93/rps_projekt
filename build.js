!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in p||(p[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==v.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=p[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(v.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=p[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return x[e]||(x[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=p[s],v=x[s];v?l=v.exports:c&&!c.declarative?l=c.esModule:c?(d(c),v=c.module,l=v.exports):l=f(s),v&&v.importers?(v.importers.push(t),t.dependencies.push(v)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=p[e];if(t)t.declarative?c(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=f(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=p[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){if(r===e)return r;var t={};if("object"==typeof r||"function"==typeof r)if(g){var n;for(var o in r)(n=Object.getOwnPropertyDescriptor(r,o))&&h(t,o,n)}else{var a=r&&r.hasOwnProperty;for(var o in r)(!a||r.hasOwnProperty(o))&&(t[o]=r[o])}return t["default"]=r,h(t,"__useDefault",{value:!0}),t}function c(r,t){var n=p[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==v.call(t,u)&&(p[u]?c(u,t):f(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function f(e){if(D[e])return D[e];if("@node/"==e.substr(0,6))return y(e.substr(6));var r=p[e];if(!r)throw"Module "+e+" not present.";return a(e),c(e,[]),p[e]=void 0,r.declarative&&h(r.module.exports,"__esModule",{value:!0}),D[e]=r.declarative?r.module.exports:r.esModule}var p={},v=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},g=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(m){g=!1}var h;!function(){try{Object.defineProperty({},"a",{})&&(h=Object.defineProperty)}catch(e){h=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var x={},y="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,D={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:y,register:r,registerDynamic:t,get:f,set:function(e,r){D[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?D[e]=r:D[e]=s(r)})(n[d],arguments[d]);o(u);var i=f(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)f(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1","1"], [], function($__System) {

!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    (function(global, factory) {
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
      } else {
        factory(global);
      }
    }(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
      var arr = [];
      var document = window.document;
      var slice = arr.slice;
      var concat = arr.concat;
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var support = {};
      var version = "2.2.2",
          jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context);
          },
          rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
          rmsPrefix = /^-ms-/,
          rdashAlpha = /-([\da-z])/gi,
          fcamelCase = function(all, letter) {
            return letter.toUpperCase();
          };
      jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        get: function(num) {
          return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
        },
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          ret.context = this.context;
          return ret;
        },
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        eq: function(i) {
          var len = this.length,
              j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options,
            name,
            src,
            copy,
            copyIsArray,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i] || {};
          i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
          target = {};
        }
        if (i === length) {
          target = this;
          i--;
        }
        for (; i < length; i++) {
          if ((options = arguments[i]) != null) {
            for (name in options) {
              src = target[name];
              copy = options[name];
              if (target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && jQuery.isArray(src) ? src : [];
                } else {
                  clone = src && jQuery.isPlainObject(src) ? src : {};
                }
                target[name] = jQuery.extend(deep, clone, copy);
              } else if (copy !== undefined) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
          return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
          return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
          var realStringObj = obj && obj.toString();
          return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
        },
        isPlainObject: function(obj) {
          var key;
          if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
            return false;
          }
          if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
            return false;
          }
          for (key in obj) {}
          return key === undefined || hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        type: function(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
          var script,
              indirect = eval;
          code = jQuery.trim(code);
          if (code) {
            if (code.indexOf("use strict") === 1) {
              script = document.createElement("script");
              script.text = code;
              document.head.appendChild(script).parentNode.removeChild(script);
            } else {
              indirect(code);
            }
          }
        },
        camelCase: function(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
          var length,
              i = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i < length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        trim: function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
          var ret = results || [];
          if (arr != null) {
            if (isArrayLike(Object(arr))) {
              jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            } else {
              push.call(ret, arr);
            }
          }
          return ret;
        },
        inArray: function(elem, arr, i) {
          return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
          var len = +second.length,
              j = 0,
              i = first.length;
          for (; j < len; j++) {
            first[i++] = second[j];
          }
          first.length = i;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse,
              matches = [],
              i = 0,
              length = elems.length,
              callbackExpect = !invert;
          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }
          return matches;
        },
        map: function(elems, callback, arg) {
          var length,
              value,
              i = 0,
              ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i < length; i++) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
          var tmp,
              args,
              proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!jQuery.isFunction(fn)) {
            return undefined;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery.guid++;
          return proxy;
        },
        now: Date.now,
        support: support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length,
            type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
      }
      var Sizzle = (function(window) {
        var i,
            support,
            Expr,
            getText,
            isXML,
            tokenize,
            compile,
            select,
            outermostContext,
            sortInput,
            hasDuplicate,
            setDocument,
            document,
            docElem,
            documentIsHTML,
            rbuggyQSA,
            rbuggyMatches,
            matches,
            contains,
            expando = "sizzle" + 1 * new Date(),
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
              }
              return 0;
            },
            MAX_NEGATIVE = 1 << 31,
            hasOwn = ({}).hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            indexOf = function(list, elem) {
              var i = 0,
                  len = list.length;
              for (; i < len; i++) {
                if (list[i] === elem) {
                  return i;
                }
              }
              return -1;
            },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            whitespace = "[\\x20\\t\\r\\n\\f]",
            identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
            rwhitespace = new RegExp(whitespace + "+", "g"),
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
              "ID": new RegExp("^#(" + identifier + ")"),
              "CLASS": new RegExp("^\\.(" + identifier + ")"),
              "TAG": new RegExp("^(" + identifier + "|[*])"),
              "ATTR": new RegExp("^" + attributes),
              "PSEUDO": new RegExp("^" + pseudos),
              "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
              "bool": new RegExp("^(?:" + booleans + ")$", "i"),
              "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            rescape = /'|\\/g,
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function(_, escaped, escapedWhitespace) {
              var high = "0x" + escaped - 0x10000;
              return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
            },
            unloadHandler = function() {
              setDocument();
            };
        try {
          push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {apply: arr.length ? function(target, els) {
              push_native.apply(target, slice.call(els));
            } : function(target, els) {
              var j = target.length,
                  i = 0;
              while ((target[j++] = els[i++])) {}
              target.length = j - 1;
            }};
        }
        function Sizzle(selector, context, results, seed) {
          var m,
              i,
              elem,
              nid,
              nidselect,
              match,
              groups,
              newSelector,
              newContext = context && context.ownerDocument,
              nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
              setDocument(context);
            }
            context = context || document;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                if ((m = match[1])) {
                  if (nodeType === 9) {
                    if ((elem = context.getElementById(m))) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                  push.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                if (nodeType !== 1) {
                  newContext = context;
                  newSelector = selector;
                } else if (context.nodeName.toLowerCase() !== "object") {
                  if ((nid = context.getAttribute("id"))) {
                    nid = nid.replace(rescape, "\\$&");
                  } else {
                    context.setAttribute("id", (nid = expando));
                  }
                  groups = tokenize(selector);
                  i = groups.length;
                  nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                  while (i--) {
                    groups[i] = nidselect + " " + toSelector(groups[i]);
                  }
                  newSelector = groups.join(",");
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                }
                if (newSelector) {
                  try {
                    push.apply(results, newContext.querySelectorAll(newSelector));
                    return results;
                  } catch (qsaError) {} finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return (cache[key + " "] = value);
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var div = document.createElement("div");
          try {
            return !!fn(div);
          } catch (e) {
            return false;
          } finally {
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
            div = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr = attrs.split("|"),
              i = arr.length;
          while (i--) {
            Expr.attrHandle[arr[i]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a,
              diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
          if (diff) {
            return diff;
          }
          if (cur) {
            while ((cur = cur.nextSibling)) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches) {
              var j,
                  matchIndexes = fn([], seed.length, argument),
                  i = matchIndexes.length;
              while (i--) {
                if (seed[(j = matchIndexes[i])]) {
                  seed[j] = !(matches[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
          var documentElement = elem && (elem.ownerDocument || elem).documentElement;
          return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
          var hasCompare,
              parent,
              doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
            return document;
          }
          document = doc;
          docElem = document.documentElement;
          documentIsHTML = !isXML(document);
          if ((parent = document.defaultView) && parent.top !== parent) {
            if (parent.addEventListener) {
              parent.addEventListener("unload", unloadHandler, false);
            } else if (parent.attachEvent) {
              parent.attachEvent("onunload", unloadHandler);
            }
          }
          support.attributes = assert(function(div) {
            div.className = "i";
            return !div.getAttribute("className");
          });
          support.getElementsByTagName = assert(function(div) {
            div.appendChild(document.createComment(""));
            return !div.getElementsByTagName("*").length;
          });
          support.getElementsByClassName = rnative.test(document.getElementsByClassName);
          support.getById = assert(function(div) {
            docElem.appendChild(div).id = expando;
            return !document.getElementsByName || !document.getElementsByName(expando).length;
          });
          if (support.getById) {
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var m = context.getElementById(id);
                return m ? [m] : [];
              }
            };
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
          } else {
            delete Expr.find["ID"];
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node && node.value === attrId;
              };
            };
          }
          Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while ((elem = results[i++])) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if ((support.qsa = rnative.test(document.querySelectorAll))) {
            assert(function(div) {
              docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
              if (div.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
              }
              if (!div.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!div.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!div.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
            });
            assert(function(div) {
              var input = document.createElement("input");
              input.setAttribute("type", "hidden");
              div.appendChild(input).setAttribute("name", "D");
              if (div.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
              }
              if (!div.querySelectorAll(":enabled").length) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              div.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
            assert(function(div) {
              support.disconnectedMatch = matches.call(div, "div");
              matches.call(div, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while ((b = b.parentNode)) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
            if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
              if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b];
            if (!aup || !bup) {
              return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while ((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while ((cur = cur.parentNode)) {
              bp.unshift(cur);
            }
            while (ap[i] === bp[i]) {
              i++;
            }
            return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
          };
          return document;
        };
        Sizzle.matches = function(expr, elements) {
          return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          expr = expr.replace(rattributeQuotes, "='$1']");
          if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {}
          }
          return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
          if ((context.ownerDocument || context) !== document) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()],
              val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
          return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
          var elem,
              duplicates = [],
              j = 0,
              i = 0;
          hasDuplicate = !support.detectDuplicates;
          sortInput = !support.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while ((elem = results[i++])) {
              if (elem === results[i]) {
                j = duplicates.push(i);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle.getText = function(elem) {
          var node,
              ret = "",
              i = 0,
              nodeType = elem.nodeType;
          if (!nodeType) {
            while ((node = elem[i++])) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle.selectors = {
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": {dir: "parentNode"},
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": {dir: "previousSibling"}
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +((match[7] + match[8]) || match[3] === "odd");
              } else if (match[3]) {
                Sizzle.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess,
                  unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, argument, first, last) {
              var simple = type.slice(0, 3) !== "nth",
                  forward = type.slice(-4) !== "last",
                  ofType = what === "of-type";
              return first === 1 && last === 0 ? function(elem) {
                return !!elem.parentNode;
              } : function(elem, context, xml) {
                var cache,
                    uniqueCache,
                    outerCache,
                    node,
                    nodeIndex,
                    start,
                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;
                if (parent) {
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || (diff % first === 0 && diff / first >= 0);
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args,
                  fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                  var idx,
                      matched = fn(seed, argument),
                      i = matched.length;
                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            "not": markFunction(function(selector) {
              var input = [],
                  results = [],
                  matcher = compile(selector.replace(rtrim, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length;
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) : function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
              };
            }),
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            "target": function(elem) {
              var hash = window.location && window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            "enabled": function(elem) {
              return elem.disabled === false;
            },
            "disabled": function(elem) {
              return elem.disabled === true;
            },
            "checked": function(elem) {
              var nodeName = elem.nodeName.toLowerCase();
              return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i = 0;
              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i = 1;
              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;
              for (; --i >= 0; ) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;
              for (; ++i < length; ) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
          var matched,
              match,
              tokens,
              type,
              soFar,
              groups,
              preFilters,
              cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push((tokens = []));
            }
            matched = false;
            if ((match = rcombinators.exec(soFar))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: match[0].replace(rtrim, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
          var i = 0,
              len = tokens.length,
              selector = "";
          for (; i < len; i++) {
            selector += tokens[i].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir = combinator.dir,
              checkNonElements = base && dir === "parentNode",
              doneName = done++;
          return combinator.first ? function(elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          } : function(elem, context, xml) {
            var oldCache,
                uniqueCache,
                outerCache,
                newCache = [dirruns, doneName];
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                  if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return (newCache[2] = oldCache[2]);
                  } else {
                    uniqueCache[dir] = newCache;
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i = 0,
              len = contexts.length;
          for (; i < len; i++) {
            Sizzle(selector, contexts[i], results);
          }
          return results;
        }
        function condense(unmatched, map, filter, context, xml) {
          var elem,
              newUnmatched = [],
              i = 0,
              len = unmatched.length,
              mapped = map != null;
          for (; i < len; i++) {
            if ((elem = unmatched[i])) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map.push(i);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp,
                i,
                elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i = temp.length;
              while (i--) {
                if ((elem = temp[i])) {
                  matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i = matcherOut.length;
                  while (i--) {
                    if ((elem = matcherOut[i])) {
                      temp.push((matcherIn[i] = elem));
                    }
                  }
                  postFinder(null, (matcherOut = []), temp, xml);
                }
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext,
              matcher,
              j,
              len = tokens.length,
              leadingRelative = Expr.relative[tokens[0].type],
              implicitRelative = leadingRelative || Expr.relative[" "],
              i = leadingRelative ? 1 : 0,
              matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true),
              matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
              }, implicitRelative, true),
              matchers = [function(elem, context, xml) {
                var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
              }];
          for (; i < len; i++) {
            if ((matcher = Expr.relative[tokens[i].type])) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
              if (matcher[expando]) {
                j = ++i;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0,
              byElement = elementMatchers.length > 0,
              superMatcher = function(seed, context, xml, results, outermost) {
                var elem,
                    j,
                    matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                    len = elems.length;
                if (outermost) {
                  outermostContext = context === document || context || outermost;
                }
                for (; i !== len && (elem = elems[i]) != null; i++) {
                  if (byElement && elem) {
                    j = 0;
                    if (!context && elem.ownerDocument !== document) {
                      setDocument(elem);
                      xml = !documentIsHTML;
                    }
                    while ((matcher = elementMatchers[j++])) {
                      if (matcher(elem, context || document, xml)) {
                        results.push(elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if ((elem = !matcher && elem)) {
                      matchedCount--;
                    }
                    if (seed) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                  j = 0;
                  while ((matcher = setMatchers[j++])) {
                    matcher(unmatched, setMatched, context, xml);
                  }
                  if (seed) {
                    if (matchedCount > 0) {
                      while (i--) {
                        if (!(unmatched[i] || setMatched[i])) {
                          setMatched[i] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push.apply(results, setMatched);
                  if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                    Sizzle.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
          var i,
              setMatchers = [],
              elementMatchers = [],
              cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i = match.length;
            while (i--) {
              cached = matcherFromTokens(match[i]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
          var i,
              tokens,
              token,
              type,
              find,
              compiled = typeof selector === "function" && selector,
              match = !seed && tokenize((selector = compiled.selector || selector));
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i--) {
              token = tokens[i];
              if (Expr.relative[(type = token.type)]) {
                break;
              }
              if ((find = Expr.find[type])) {
                if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                  tokens.splice(i, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
          return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support.attributes || !assert(function(div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle;
      })(window);
      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors;
      jQuery.expr[":"] = jQuery.expr.pseudos;
      jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      var dir = function(elem, dir, until) {
        var matched = [],
            truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
          if (n.nodeType === 1 && n !== elem) {
            matched.push(n);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
      var risSimple = /^.[^:#\[\.,]*$/;
      function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
          return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return (elem === qualifier) !== not;
          });
        }
        if (typeof qualifier === "string") {
          if (risSimple.test(qualifier)) {
            return jQuery.filter(qualifier, elements, not);
          }
          qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
          return (indexOf.call(qualifier, elem) > -1) !== not;
        });
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
          return elem.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i,
              len = this.length,
              ret = [],
              self = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self[i], this)) {
                  return true;
                }
              }
            }));
          }
          for (i = 0; i < len; i++) {
            jQuery.find(selector, self[i], ret);
          }
          ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
          ret.selector = this.selector ? this.selector + " " + selector : selector;
          return ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
      });
      var rootjQuery,
          rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
          init = jQuery.fn.init = function(selector, context, root) {
            var match,
                elem;
            if (!selector) {
              return this;
            }
            root = root || rootjQuery;
            if (typeof selector === "string") {
              if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [null, selector, null];
              } else {
                match = rquickExpr.exec(selector);
              }
              if (match && (match[1] || !context)) {
                if (match[1]) {
                  context = context instanceof jQuery ? context[0] : context;
                  jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                  if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                    for (match in context) {
                      if (jQuery.isFunction(this[match])) {
                        this[match](context[match]);
                      } else {
                        this.attr(match, context[match]);
                      }
                    }
                  }
                  return this;
                } else {
                  elem = document.getElementById(match[2]);
                  if (elem && elem.parentNode) {
                    this.length = 1;
                    this[0] = elem;
                  }
                  this.context = document;
                  this.selector = selector;
                  return this;
                }
              } else if (!context || context.jquery) {
                return (context || root).find(selector);
              } else {
                return this.constructor(context).find(selector);
              }
            } else if (selector.nodeType) {
              this.context = this[0] = selector;
              this.length = 1;
              return this;
            } else if (jQuery.isFunction(selector)) {
              return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
              this.selector = selector.selector;
              this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
          };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/,
          guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
          };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this),
              l = targets.length;
          return this.filter(function() {
            var i = 0;
            for (; i < l; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur,
              i = 0,
              l = this.length,
              matched = [],
              pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
          if (!elem) {
            return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
          return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
      });
      function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnotwhite = (/\S+/g);
      function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing,
            memory,
            fired,
            locked,
            list = [],
            queue = [],
            firingIndex = -1,
            fire = function() {
              locked = options.once;
              fired = firing = true;
              for (; queue.length; firingIndex = -1) {
                memory = queue.shift();
                while (++firingIndex < list.length) {
                  if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    firingIndex = list.length;
                    memory = false;
                  }
                }
              }
              if (!options.memory) {
                memory = false;
              }
              firing = false;
              if (locked) {
                if (memory) {
                  list = [];
                } else {
                  list = "";
                }
              }
            },
            self = {
              add: function() {
                if (list) {
                  if (memory && !firing) {
                    firingIndex = list.length - 1;
                    queue.push(memory);
                  }
                  (function add(args) {
                    jQuery.each(args, function(_, arg) {
                      if (jQuery.isFunction(arg)) {
                        if (!options.unique || !self.has(arg)) {
                          list.push(arg);
                        }
                      } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                        add(arg);
                      }
                    });
                  })(arguments);
                  if (memory && !firing) {
                    fire();
                  }
                }
                return this;
              },
              remove: function() {
                jQuery.each(arguments, function(_, arg) {
                  var index;
                  while ((index = jQuery.inArray(arg, list, index)) > -1) {
                    list.splice(index, 1);
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                });
                return this;
              },
              has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
              },
              empty: function() {
                if (list) {
                  list = [];
                }
                return this;
              },
              disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
              },
              disabled: function() {
                return !list;
              },
              lock: function() {
                locked = queue = [];
                if (!memory) {
                  list = memory = "";
                }
                return this;
              },
              locked: function() {
                return !!locked;
              },
              fireWith: function(context, args) {
                if (!locked) {
                  args = args || [];
                  args = [context, args.slice ? args.slice() : args];
                  queue.push(args);
                  if (!firing) {
                    fire();
                  }
                }
                return this;
              },
              fire: function() {
                self.fireWith(this, arguments);
                return this;
              },
              fired: function() {
                return !!fired;
              }
            };
        return self;
      };
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
              state = "pending",
              promise = {
                state: function() {
                  return state;
                },
                always: function() {
                  deferred.done(arguments).fail(arguments);
                  return this;
                },
                then: function() {
                  var fns = arguments;
                  return jQuery.Deferred(function(newDefer) {
                    jQuery.each(tuples, function(i, tuple) {
                      var fn = jQuery.isFunction(fns[i]) && fns[i];
                      deferred[tuple[1]](function() {
                        var returned = fn && fn.apply(this, arguments);
                        if (returned && jQuery.isFunction(returned.promise)) {
                          returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                        } else {
                          newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                        }
                      });
                    });
                    fns = null;
                  }).promise();
                },
                promise: function(obj) {
                  return obj != null ? jQuery.extend(obj, promise) : promise;
                }
              },
              deferred = {};
          promise.pipe = promise.then;
          jQuery.each(tuples, function(i, tuple) {
            var list = tuple[2],
                stateString = tuple[3];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(function() {
                state = stateString;
              }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
            }
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        when: function(subordinate) {
          var i = 0,
              resolveValues = slice.call(arguments),
              length = resolveValues.length,
              remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
              deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
              updateFunc = function(i, contexts, values) {
                return function(value) {
                  contexts[i] = this;
                  values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                  if (values === progressValues) {
                    deferred.notifyWith(contexts, values);
                  } else if (!(--remaining)) {
                    deferred.resolveWith(contexts, values);
                  }
                };
              },
              progressValues,
              progressContexts,
              resolveContexts;
          if (length > 1) {
            progressValues = new Array(length);
            progressContexts = new Array(length);
            resolveContexts = new Array(length);
            for (; i < length; i++) {
              if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
              } else {
                --remaining;
              }
            }
          }
          if (!remaining) {
            deferred.resolveWith(resolveContexts, resolveValues);
          }
          return deferred.promise();
        }
      });
      var readyList;
      jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
      };
      jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
          if (hold) {
            jQuery.readyWait++;
          } else {
            jQuery.ready(true);
          }
        },
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document, [jQuery]);
          if (jQuery.fn.triggerHandler) {
            jQuery(document).triggerHandler("ready");
            jQuery(document).off("ready");
          }
        }
      });
      function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
      }
      jQuery.ready.promise = function(obj) {
        if (!readyList) {
          readyList = jQuery.Deferred();
          if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            window.setTimeout(jQuery.ready);
          } else {
            document.addEventListener("DOMContentLoaded", completed);
            window.addEventListener("load", completed);
          }
        }
        return readyList.promise(obj);
      };
      jQuery.ready.promise();
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;
        if (jQuery.type(key) === "object") {
          chainable = true;
          for (i in key) {
            access(elems, fn, i, key[i], true, emptyGet, raw);
          }
        } else if (value !== undefined) {
          chainable = true;
          if (!jQuery.isFunction(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, key, value) {
                return bulk.call(jQuery(elem), value);
              };
            }
          }
          if (fn) {
            for (; i < len; i++) {
              fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            }
          }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
      };
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        register: function(owner, initial) {
          var value = initial || {};
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              writable: true,
              configurable: true
            });
          }
          return owner[this.expando];
        },
        cache: function(owner) {
          if (!acceptData(owner)) {
            return {};
          }
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value: value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop,
              cache = this.cache(owner);
          if (typeof data === "string") {
            cache[data] = value;
          } else {
            for (prop in data) {
              cache[prop] = data[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function(owner, key, value) {
          var stored;
          if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
            stored = this.get(owner, key);
            return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
          }
          this.set(owner, key, value);
          return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
          var i,
              name,
              camel,
              cache = owner[this.expando];
          if (cache === undefined) {
            return;
          }
          if (key === undefined) {
            this.register(owner);
          } else {
            if (jQuery.isArray(key)) {
              name = key.concat(key.map(jQuery.camelCase));
            } else {
              camel = jQuery.camelCase(key);
              if (key in cache) {
                name = [key, camel];
              } else {
                name = camel;
                name = name in cache ? [name] : (name.match(rnotwhite) || []);
              }
            }
            i = name.length;
            while (i--) {
              delete cache[name[i]];
            }
          }
          if (key === undefined || jQuery.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = undefined;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
          rmultiDash = /[A-Z]/g;
      function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
            } catch (e) {}
            dataUser.set(elem, key, data);
          } else {
            data = undefined;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i,
              name,
              data,
              elem = this[0],
              attrs = elem && elem.attributes;
          if (key === undefined) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;
                while (i--) {
                  if (attrs[i]) {
                    name = attrs[i].name;
                    if (name.indexOf("data-") === 0) {
                      name = jQuery.camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value) {
            var data,
                camelKey;
            if (elem && value === undefined) {
              data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
              if (data !== undefined) {
                return data;
              }
              camelKey = jQuery.camelCase(key);
              data = dataUser.get(elem, camelKey);
              if (data !== undefined) {
                return data;
              }
              data = dataAttr(elem, camelKey, undefined);
              if (data !== undefined) {
                return data;
              }
              return;
            }
            camelKey = jQuery.camelCase(key);
            this.each(function() {
              var data = dataUser.get(this, camelKey);
              dataUser.set(this, camelKey, value);
              if (key.indexOf("-") > -1 && data !== undefined) {
                dataUser.set(this, key, value);
              }
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data) {
              if (!queue || jQuery.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type),
              startLength = queue.length,
              fn = queue.shift(),
              hooks = jQuery._queueHooks(elem, type),
              next = function() {
                jQuery.dequeue(elem, type);
              };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })});
        }
      });
      jQuery.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }
          return data === undefined ? this : this.each(function() {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
          var tmp,
              count = 1,
              defer = jQuery.Deferred(),
              elements = this,
              i = this.length,
              resolve = function() {
                if (!(--count)) {
                  defer.resolveWith(elements, [elements]);
                }
              };
          if (typeof type !== "string") {
            obj = type;
            type = undefined;
          }
          type = type || "fx";
          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted,
            scale = 1,
            maxIterations = 20,
            currentValue = tween ? function() {
              return tween.cur();
            } : function() {
              return jQuery.css(elem, prop, "");
            },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
            initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          unit = unit || initialInUnit[3];
          valueParts = valueParts || [];
          initialInUnit = +initial || 1;
          do {
            scale = scale || ".5";
            initialInUnit = initialInUnit / scale;
            jQuery.style(elem, prop, initialInUnit + unit);
          } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var rcheckableType = (/^(?:checkbox|radio)$/i);
      var rtagName = (/<([\w:-]+)/);
      var rscriptType = (/^$|\/(?:java|ecma)script/i);
      var wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function getAll(context, tag) {
        var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
      }
      function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;
        for (; i < l; i++) {
          dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem,
            tmp,
            tag,
            wrap,
            contains,
            j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;
        for (; i < l; i++) {
          elem = elems[i];
          if (elem || elem === 0) {
            if (jQuery.type(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
              j = wrap[0];
              while (j--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i = 0;
        while ((elem = nodes[i++])) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          contains = jQuery.contains(elem.ownerDocument, elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (contains) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j = 0;
            while ((elem = tmp[j++])) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      })();
      var rkeyEvent = /^key/,
          rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
          rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function safeActiveElement() {
        try {
          return document.activeElement;
        } catch (err) {}
      }
      function on(elem, types, selector, data, fn, one) {
        var origFn,
            type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = undefined;
          }
          for (type in types) {
            on(elem, type, selector, data, types[type], one);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = undefined;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = undefined;
          } else {
            fn = data;
            data = selector;
            selector = undefined;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn,
              eventHandle,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.get(elem);
          if (!elemData) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = {};
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
          }
          types = (types || "").match(rnotwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery.event.special[type] || {};
            handleObj = jQuery.extend({
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type] = true;
          }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j,
              origCount,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnotwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j = handlers.length;
            while (j--) {
              handleObj = handlers[j];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(event) {
          event = jQuery.event.fix(event);
          var i,
              j,
              ret,
              matched,
              handleObj,
              handlerQueue = [],
              args = slice.call(arguments),
              handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
              special = jQuery.event.special[event.type] || {};
          args[0] = event;
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i = 0;
          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;
            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== undefined) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i,
              matches,
              sel,
              handleObj,
              handlerQueue = [],
              delegateCount = handlers.delegateCount,
              cur = event.target;
          if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                matches = [];
                for (i = 0; i < delegateCount; i++) {
                  handleObj = handlers[i];
                  sel = handleObj.selector + " ";
                  if (matches[sel] === undefined) {
                    matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matches[sel]) {
                    matches.push(handleObj);
                  }
                }
                if (matches.length) {
                  handlerQueue.push({
                    elem: cur,
                    handlers: matches
                  });
                }
              }
            }
          }
          if (delegateCount < handlers.length) {
            handlerQueue.push({
              elem: this,
              handlers: handlers.slice(delegateCount)
            });
          }
          return handlerQueue;
        },
        props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
        fixHooks: {},
        keyHooks: {
          props: "char charCode key keyCode".split(" "),
          filter: function(event, original) {
            if (event.which == null) {
              event.which = original.charCode != null ? original.charCode : original.keyCode;
            }
            return event;
          }
        },
        mouseHooks: {
          props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
          filter: function(event, original) {
            var eventDoc,
                doc,
                body,
                button = original.button;
            if (event.pageX == null && original.clientX != null) {
              eventDoc = event.target.ownerDocument || document;
              doc = eventDoc.documentElement;
              body = eventDoc.body;
              event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
              event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }
            if (!event.which && button !== undefined) {
              event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
            }
            return event;
          }
        },
        fix: function(event) {
          if (event[jQuery.expando]) {
            return event;
          }
          var i,
              prop,
              copy,
              type = event.type,
              originalEvent = event,
              fixHook = this.fixHooks[type];
          if (!fixHook) {
            this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
          }
          copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
          event = new jQuery.Event(originalEvent);
          i = copy.length;
          while (i--) {
            prop = copy[i];
            event[prop] = originalEvent[prop];
          }
          if (!event.target) {
            event.target = document;
          }
          if (event.target.nodeType === 3) {
            event.target = event.target.parentNode;
          }
          return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
          load: {noBubble: true},
          focus: {
            trigger: function() {
              if (this !== safeActiveElement() && this.focus) {
                this.focus();
                return false;
              }
            },
            delegateType: "focusin"
          },
          blur: {
            trigger: function() {
              if (this === safeActiveElement() && this.blur) {
                this.blur();
                return false;
              }
            },
            delegateType: "focusout"
          },
          click: {
            trigger: function() {
              if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                this.click();
                return false;
              }
            },
            _default: function(event) {
              return jQuery.nodeName(event.target, "a");
            }
          },
          beforeunload: {postDispatch: function(event) {
              if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }}
        }
      };
      jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e) {
            e.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;
            if (!related || (related !== target && !jQuery.contains(target, related))) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj,
              type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = undefined;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
          rnoInnerhtml = /<script|<style|<link/i,
          rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
          rscriptTypeMasked = /^true\/(.*)/,
          rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
      function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
          elem.type = match[1];
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i,
            l,
            type,
            pdataOld,
            pdataCur,
            udataOld,
            udataCur,
            events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.access(src);
          pdataCur = dataPriv.set(dest, pdataOld);
          events = pdataOld.events;
          if (events) {
            delete pdataCur.handle;
            pdataCur.events = {};
            for (type in events) {
              for (i = 0, l = events[type].length; i < l; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment,
            first,
            scripts,
            hasScripts,
            node,
            doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            isFunction = jQuery.isFunction(value);
        if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
          return collection.each(function(index) {
            var self = collection.eq(index);
            if (isFunction) {
              args[0] = value.call(this, index, self.html());
            }
            domManip(self, args, callback, ignored);
          });
        }
        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i < l; i++) {
              node = fragment;
              if (i !== iNoClone) {
                node = jQuery.clone(node, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i], node, i);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i = 0; i < hasScripts; i++) {
                node = scripts[i];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src) {
                    if (jQuery._evalUrl) {
                      jQuery._evalUrl(node.src);
                    }
                  } else {
                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;
        for (; (node = nodes[i]) != null; i++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && jQuery.contains(node.ownerDocument, node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i,
              l,
              srcElements,
              destElements,
              clone = elem.cloneNode(true),
              inPage = jQuery.contains(elem.ownerDocument, elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i = 0, l = srcElements.length; i < l; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i = 0, l = srcElements.length; i < l; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        cleanData: function(elems) {
          var data,
              elem,
              type,
              special = jQuery.event.special,
              i = 0;
          for (; (elem = elems[i]) !== undefined; i++) {
            if (acceptData(elem)) {
              if ((data = elem[dataPriv.expando])) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type);
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = undefined;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = undefined;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        domManip: domManip,
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value) {
            return value === undefined ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem,
              i = 0;
          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value) {
            var elem = this[0] || {},
                i = 0,
                l = this.length;
            if (value === undefined && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
              value = jQuery.htmlPrefilter(value);
              try {
                for (; i < l; i++) {
                  elem = this[i] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value;
                  }
                }
                elem = 0;
              } catch (e) {}
            }
            if (elem) {
              this.empty().append(value);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems,
              ret = [],
              insert = jQuery(selector),
              last = insert.length - 1,
              i = 0;
          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var iframe,
          elemdisplay = {
            HTML: "block",
            BODY: "block"
          };
      function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = jQuery.css(elem[0], "display");
        elem.detach();
        return display;
      }
      function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];
        if (!display) {
          display = actualDisplay(nodeName, doc);
          if (display === "none" || !display) {
            iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
            doc = iframe[0].contentDocument;
            doc.write();
            doc.close();
            display = actualDisplay(nodeName, doc);
            iframe.detach();
          }
          elemdisplay[nodeName] = display;
        }
        return display;
      }
      var rmargin = (/^margin/);
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback, args) {
        var ret,
            name,
            old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var documentElement = document.documentElement;
      (function() {
        var pixelPositionVal,
            boxSizingReliableVal,
            pixelMarginRightVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);
        function computeStyleTests() {
          div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
          div.innerHTML = "";
          documentElement.appendChild(container);
          var divStyle = window.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = divStyle.marginLeft === "2px";
          boxSizingReliableVal = divStyle.width === "4px";
          div.style.marginRight = "50%";
          pixelMarginRightVal = divStyle.marginRight === "4px";
          documentElement.removeChild(container);
        }
        jQuery.extend(support, {
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          boxSizingReliable: function() {
            if (boxSizingReliableVal == null) {
              computeStyleTests();
            }
            return boxSizingReliableVal;
          },
          pixelMarginRight: function() {
            if (boxSizingReliableVal == null) {
              computeStyleTests();
            }
            return pixelMarginRightVal;
          },
          reliableMarginLeft: function() {
            if (boxSizingReliableVal == null) {
              computeStyleTests();
            }
            return reliableMarginLeftVal;
          },
          reliableMarginRight: function() {
            var ret,
                marginDiv = div.appendChild(document.createElement("div"));
            marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
            marginDiv.style.marginRight = marginDiv.style.width = "0";
            div.style.width = "1px";
            documentElement.appendChild(container);
            ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
            documentElement.removeChild(container);
            div.removeChild(marginDiv);
            return ret;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width,
            minWidth,
            maxWidth,
            ret,
            style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
        if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        }
        if (computed) {
          if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== undefined ? ret + "" : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }};
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
          cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
          },
          cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
          },
          cssPrefixes = ["Webkit", "O", "Moz", "ms"],
          emptyStyle = document.createElement("div").style;
      function vendorPropName(name) {
        if (name in emptyStyle) {
          return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;
        while (i--) {
          name = cssPrefixes[i] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
      }
      function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
            val = 0;
        for (; i < 4; i += 2) {
          if (extra === "margin") {
            val += jQuery.css(elem, extra + cssExpand[i], true, styles);
          }
          if (isBorderBox) {
            if (extra === "content") {
              val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            }
            if (extra !== "margin") {
              val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          } else {
            val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            if (extra !== "padding") {
              val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          }
        }
        return val;
      }
      function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (document.msFullscreenElement && window.top !== window) {
          if (elem.getClientRects().length) {
            val = Math.round(elem.getBoundingClientRect()[name] * 100);
          }
        }
        if (val <= 0 || val == null) {
          val = curCSS(elem, name, styles);
          if (val < 0 || val == null) {
            val = elem.style[name];
          }
          if (rnumnonpx.test(val)) {
            return val;
          }
          valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
          val = parseFloat(val) || 0;
        }
        return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
      }
      function showHide(elements, show) {
        var display,
            elem,
            hidden,
            values = [],
            index = 0,
            length = elements.length;
        for (; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          values[index] = dataPriv.get(elem, "olddisplay");
          display = elem.style.display;
          if (show) {
            if (!values[index] && display === "none") {
              elem.style.display = "";
            }
            if (elem.style.display === "" && isHidden(elem)) {
              values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
            }
          } else {
            hidden = isHidden(elem);
            if (display !== "none" || !hidden) {
              dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
            }
          }
        }
        for (index = 0; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          if (!show || elem.style.display === "none" || elem.style.display === "") {
            elem.style.display = show ? values[index] || "" : "none";
          }
        }
        return elements;
      }
      jQuery.extend({
        cssHooks: {opacity: {get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }}},
        cssNumber: {
          "animationIterationCount": true,
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
        },
        cssProps: {"float": "cssFloat"},
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret,
              type,
              hooks,
              origName = jQuery.camelCase(name),
              style = elem.style;
          name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== undefined) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number") {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
              style[name] = value;
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val,
              num,
              hooks,
              origName = jQuery.camelCase(name);
          name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === undefined) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, name, extra);
              }) : getWidthOrHeight(elem, name, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches,
                styles = extra && getStyles(elem),
                subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[name] = value;
              value = jQuery.css(elem, name);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      });
      jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
          return swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
        }
      });
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
            var i = 0,
                expanded = {},
                parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }
            return expanded;
          }};
        if (!rmargin.test(prefix)) {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name, value) {
            var styles,
                len,
                map = {},
                i = 0;
            if (jQuery.isArray(name)) {
              styles = getStyles(elem);
              len = name.length;
              for (; i < len; i++) {
                map[name[i]] = jQuery.css(elem, name[i], false, styles);
              }
              return map;
            }
            return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
          }, name, value, arguments.length > 1);
        },
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHidden(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased,
              hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {_default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }};
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }};
      jQuery.easing = {
        linear: function(p) {
          return p;
        },
        swing: function(p) {
          return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow,
          timerId,
          rfxtypes = /^(?:toggle|show|hide)$/,
          rrun = /queueHooks$/;
      function createFxNow() {
        window.setTimeout(function() {
          fxNow = undefined;
        });
        return (fxNow = jQuery.now());
      }
      function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {height: type};
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
          if ((tween = collection[index].call(animation, prop, value))) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop,
            value,
            toggle,
            tween,
            hooks,
            oldfire,
            display,
            checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          display = jQuery.css(elem, "display");
          checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
          if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
            style.display = "inline-block";
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.exec(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          } else {
            display = undefined;
          }
        }
        if (!jQuery.isEmptyObject(orig)) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", {});
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            jQuery(elem).show();
          } else {
            anim.done(function() {
              jQuery(elem).hide();
            });
          }
          anim.done(function() {
            var prop;
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
          for (prop in orig) {
            tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = tween.start;
              if (hidden) {
                tween.end = tween.start;
                tween.start = prop === "width" || prop === "height" ? 1 : 0;
              }
            }
          }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
          style.display = display;
        }
      }
      function propFilter(props, specialEasing) {
        var index,
            name,
            easing,
            value,
            hooks;
        for (index in props) {
          name = jQuery.camelCase(index);
          easing = specialEasing[name];
          value = props[index];
          if (jQuery.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }
          if (index !== name) {
            props[name] = value;
            delete props[index];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function() {
              delete tick.elem;
            }),
            tick = function() {
              if (stopped) {
                return false;
              }
              var currentTime = fxNow || createFxNow(),
                  remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                  temp = remaining / animation.duration || 0,
                  percent = 1 - temp,
                  index = 0,
                  length = animation.tweens.length;
              for (; index < length; index++) {
                animation.tweens[index].run(percent);
              }
              deferred.notifyWith(elem, [animation, percent, remaining]);
              if (percent < 1 && length) {
                return remaining;
              } else {
                deferred.resolveWith(elem, [animation]);
                return false;
              }
            },
            animation = deferred.promise({
              elem: elem,
              props: jQuery.extend({}, properties),
              opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
              }, options),
              originalProperties: properties,
              originalOptions: options,
              startTime: fxNow || createFxNow(),
              duration: options.duration,
              tweens: [],
              createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
              },
              stop: function(gotoEnd) {
                var index = 0,
                    length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                  return this;
                }
                stopped = true;
                for (; index < length; index++) {
                  animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                  deferred.notifyWith(elem, [animation, 1, 0]);
                  deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                  deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
              }
            }),
            props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            if (jQuery.isFunction(result.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
            }
            return result;
          }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {"*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]},
        tweener: function(props, callback) {
          if (jQuery.isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnotwhite);
          }
          var prop,
              index = 0,
              length = props.length;
          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (jQuery.isFunction(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop),
              optall = jQuery.speed(speed, easing, callback),
              doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || dataPriv.get(this, "finish")) {
                  anim.stop(true);
                }
              };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
          }
          if (clearQueue && type !== false) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = dataPriv.get(this);
            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index,
                data = dataPriv.get(this),
                queue = data[type + "queue"],
                hooks = data[type + "queueHooks"],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
          timer = timers[i];
          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = undefined;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
          jQuery.fx.start();
        } else {
          jQuery.timers.pop();
        }
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (!timerId) {
          timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
      };
      jQuery.fx.stop = function() {
        window.clearInterval(timerId);
        timerId = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
      };
      jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window.setTimeout(next, time);
          hooks.stop = function() {
            window.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook,
          attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
          }
          if (value !== undefined) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name);
          return ret == null ? undefined : ret;
        },
        attrHooks: {type: {set: function(elem, value) {
              if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }}},
        removeAttr: function(elem, value) {
          var name,
              propName,
              i = 0,
              attrNames = value && value.match(rnotwhite);
          if (attrNames && elem.nodeType === 1) {
            while ((name = attrNames[i++])) {
              propName = jQuery.propFix[name] || name;
              if (jQuery.expr.match.bool.test(name)) {
                elem[propName] = false;
              }
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }};
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
          var ret,
              handle;
          if (!isXML) {
            handle = attrHandle[name];
            attrHandle[name] = ret;
            ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
            attrHandle[name] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i,
          rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== undefined) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }
            return (elem[name] = value);
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {tabIndex: {get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
            }}},
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this;
      });
      var rclass = /[\t\r\n\f]/g;
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classes,
              elem,
              cur,
              curValue,
              clazz,
              j,
              finalValue,
              i = 0;
          if (jQuery.isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
          }
          if (typeof value === "string" && value) {
            classes = value.match(rnotwhite) || [];
            while ((elem = this[i++])) {
              curValue = getClass(elem);
              cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
              if (cur) {
                j = 0;
                while ((clazz = classes[j++])) {
                  if (cur.indexOf(" " + clazz + " ") < 0) {
                    cur += clazz + " ";
                  }
                }
                finalValue = jQuery.trim(cur);
                if (curValue !== finalValue) {
                  elem.setAttribute("class", finalValue);
                }
              }
            }
          }
          return this;
        },
        removeClass: function(value) {
          var classes,
              elem,
              cur,
              curValue,
              clazz,
              j,
              finalValue,
              i = 0;
          if (jQuery.isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          if (typeof value === "string" && value) {
            classes = value.match(rnotwhite) || [];
            while ((elem = this[i++])) {
              curValue = getClass(elem);
              cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
              if (cur) {
                j = 0;
                while ((clazz = classes[j++])) {
                  while (cur.indexOf(" " + clazz + " ") > -1) {
                    cur = cur.replace(" " + clazz + " ", " ");
                  }
                }
                finalValue = jQuery.trim(cur);
                if (curValue !== finalValue) {
                  elem.setAttribute("class", finalValue);
                }
              }
            }
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var type = typeof value;
          if (typeof stateVal === "boolean" && type === "string") {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          if (jQuery.isFunction(value)) {
            return this.each(function(i) {
              jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
          }
          return this.each(function() {
            var className,
                i,
                self,
                classNames;
            if (type === "string") {
              i = 0;
              self = jQuery(this);
              classNames = value.match(rnotwhite) || [];
              while ((className = classNames[i++])) {
                if (self.hasClass(className)) {
                  self.removeClass(className);
                } else {
                  self.addClass(className);
                }
              }
            } else if (value === undefined || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
              }
            }
          });
        },
        hasClass: function(selector) {
          var className,
              elem,
              i = 0;
          className = " " + selector + " ";
          while ((elem = this[i++])) {
            if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g,
          rspaces = /[\x20\t\r\n\f]+/g;
      jQuery.fn.extend({val: function(value) {
          var hooks,
              ret,
              isFunction,
              elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                return ret;
              }
              ret = elem.value;
              return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
            }
            return;
          }
          isFunction = jQuery.isFunction(value);
          return this.each(function(i) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (isFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (jQuery.isArray(val)) {
              val = jQuery.map(val, function(value) {
                return value == null ? "" : value + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
              this.value = val;
            }
          });
        }});
      jQuery.extend({valHooks: {
          option: {get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
            }},
          select: {
            get: function(elem) {
              var value,
                  option,
                  options = elem.options,
                  index = elem.selectedIndex,
                  one = elem.type === "select-one" || index < 0,
                  values = one ? null : [],
                  max = one ? index + 1 : options.length,
                  i = index < 0 ? max : one ? index : 0;
              for (; i < max; i++) {
                option = options[i];
                if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet,
                  option,
                  options = elem.options,
                  values = jQuery.makeArray(value),
                  i = options.length;
              while (i--) {
                option = options[i];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }});
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {set: function(elem, value) {
            if (jQuery.isArray(value)) {
              return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
            }
          }};
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i,
              cur,
              tmp,
              bubbleType,
              ontype,
              handle,
              special,
              eventPath = [elem || document],
              type = hasOwn.call(event, "type") ? event.type : event,
              namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = tmp = elem = elem || document;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = undefined;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window);
            }
          }
          i = 0;
          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            event.type = i > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type;
                elem[type]();
                jQuery.event.triggered = undefined;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        simulate: function(type, elem, event) {
          var e = jQuery.extend(new jQuery.Event(), event, {
            type: type,
            isSimulated: true
          });
          jQuery.event.trigger(e, null, elem);
          if (e.isDefaultPrevented()) {
            event.preventDefault();
          }
        }
      });
      jQuery.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      });
      jQuery.fn.extend({hover: function(fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }});
      support.focusin = "onfocusin" in window;
      if (!support.focusin) {
        jQuery.each({
          focus: "focusin",
          blur: "focusout"
        }, function(orig, fix) {
          var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
          };
          jQuery.event.special[fix] = {
            setup: function() {
              var doc = this.ownerDocument || this,
                  attaches = dataPriv.access(doc, fix);
              if (!attaches) {
                doc.addEventListener(orig, handler, true);
              }
              dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this,
                  attaches = dataPriv.access(doc, fix) - 1;
              if (!attaches) {
                doc.removeEventListener(orig, handler, true);
                dataPriv.remove(doc, fix);
              } else {
                dataPriv.access(doc, fix, attaches);
              }
            }
          };
        });
      }
      var location = window.location;
      var nonce = jQuery.now();
      var rquery = (/\?/);
      jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
      };
      jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
          xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
          jQuery.error("Invalid XML: " + data);
        }
        return xml;
      };
      var rhash = /#.*$/,
          rts = /([?&])_=[^&]*/,
          rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
          rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
          rnoContent = /^(?:GET|HEAD)$/,
          rprotocol = /^\/\//,
          prefilters = {},
          transports = {},
          allTypes = "*/".concat("*"),
          originAnchor = document.createElement("a");
      originAnchor.href = location.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType,
              i = 0,
              dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
          if (jQuery.isFunction(func)) {
            while ((dataType = dataTypes[i++])) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = (structure === transports);
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key,
            deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== undefined) {
            (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct,
            type,
            finalDataType,
            firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === undefined) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},
            dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return {
          state: "success",
          data: response
        };
      }
      jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": true,
            "text json": jQuery.parseJSON,
            "text xml": jQuery.parseXML
          },
          flatOptions: {
            url: true,
            context: true
          }
        },
        ajaxSetup: function(target, settings) {
          return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = undefined;
          }
          options = options || {};
          var transport,
              cacheURL,
              responseHeadersString,
              responseHeaders,
              timeoutTimer,
              urlAnchor,
              fireGlobals,
              i,
              s = jQuery.ajaxSetup({}, options),
              callbackContext = s.context || s,
              globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
              deferred = jQuery.Deferred(),
              completeDeferred = jQuery.Callbacks("once memory"),
              statusCode = s.statusCode || {},
              requestHeaders = {},
              requestHeadersNames = {},
              state = 0,
              strAbort = "canceled",
              jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                  var match;
                  if (state === 2) {
                    if (!responseHeaders) {
                      responseHeaders = {};
                      while ((match = rheaders.exec(responseHeadersString))) {
                        responseHeaders[match[1].toLowerCase()] = match[2];
                      }
                    }
                    match = responseHeaders[key.toLowerCase()];
                  }
                  return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                  return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                  var lname = name.toLowerCase();
                  if (!state) {
                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                    requestHeaders[name] = value;
                  }
                  return this;
                },
                overrideMimeType: function(type) {
                  if (!state) {
                    s.mimeType = type;
                  }
                  return this;
                },
                statusCode: function(map) {
                  var code;
                  if (map) {
                    if (state < 2) {
                      for (code in map) {
                        statusCode[code] = [statusCode[code], map[code]];
                      }
                    } else {
                      jqXHR.always(map[jqXHR.status]);
                    }
                  }
                  return this;
                },
                abort: function(statusText) {
                  var finalText = statusText || strAbort;
                  if (transport) {
                    transport.abort(finalText);
                  }
                  done(0, finalText);
                  return this;
                }
              };
          deferred.promise(jqXHR).complete = completeDeferred.add;
          jqXHR.success = jqXHR.done;
          jqXHR.error = jqXHR.fail;
          s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
          s.type = options.method || options.type || s.method || s.type;
          s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
          if (s.crossDomain == null) {
            urlAnchor = document.createElement("a");
            try {
              urlAnchor.href = s.url;
              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              s.crossDomain = true;
            }
          }
          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
          if (state === 2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s.type = s.type.toUpperCase();
          s.hasContent = !rnoContent.test(s.type);
          cacheURL = s.url;
          if (!s.hasContent) {
            if (s.data) {
              cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
              delete s.data;
            }
            if (s.cache === false) {
              s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
            }
          }
          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          }
          jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          }
          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          for (i in {
            success: 1,
            error: 1,
            complete: 1
          }) {
            jqXHR[i](s[i]);
          }
          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            }
            if (state === 2) {
              return jqXHR;
            }
            if (s.async && s.timeout > 0) {
              timeoutTimer = window.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s.timeout);
            }
            try {
              state = 1;
              transport.send(requestHeaders, done);
            } catch (e) {
              if (state < 2) {
                done(-1, e);
              } else {
                throw e;
              }
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess,
                success,
                error,
                response,
                modified,
                statusText = nativeStatusText;
            if (state === 2) {
              return;
            }
            state = 2;
            if (timeoutTimer) {
              window.clearTimeout(timeoutTimer);
            }
            transport = undefined;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            }
            response = ajaxConvert(s, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = undefined;
            if (fireGlobals) {
              globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
              if (!(--jQuery.active)) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, undefined, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
          if (jQuery.isFunction(data)) {
            type = type || callback;
            callback = data;
            data = undefined;
          }
          return jQuery.ajax(jQuery.extend({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery._evalUrl = function(url) {
        return jQuery.ajax({
          url: url,
          type: "GET",
          dataType: "script",
          async: false,
          global: false,
          "throws": true
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (jQuery.isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapAll(html.call(this, i));
            });
          }
          if (this[0]) {
            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (jQuery.isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }
          return this.each(function() {
            var self = jQuery(this),
                contents = self.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self.append(html);
            }
          });
        },
        wrap: function(html) {
          var isFunction = jQuery.isFunction(html);
          return this.each(function(i) {
            jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function() {
          return this.parent().each(function() {
            if (!jQuery.nodeName(this, "body")) {
              jQuery(this).replaceWith(this.childNodes);
            }
          }).end();
        }
      });
      jQuery.expr.filters.hidden = function(elem) {
        return !jQuery.expr.filters.visible(elem);
      };
      jQuery.expr.filters.visible = function(elem) {
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
      };
      var r20 = /%20/g,
          rbracket = /\[\]$/,
          rCRLF = /\r?\n/g,
          rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
          rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
          jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v);
            } else {
              buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
            }
          });
        } else if (!traditional && jQuery.type(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a, traditional) {
        var prefix,
            s = [],
            add = function(key, value) {
              value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
              s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };
        if (traditional === undefined) {
          traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
          jQuery.each(a, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        }
        return s.join("&").replace(r20, "+");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(i, elem) {
            var val = jQuery(this).val();
            return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            }) : {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          }).get();
        }
      });
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window.XMLHttpRequest();
        } catch (e) {}
      };
      var xhrSuccessStatus = {
        0: 200,
        1223: 204
      },
          xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback,
            errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i,
                  xhr = options.xhr();
              xhr.open(options.type, options.url, options.async, options.username, options.password);
              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(xhr.status, xhr.statusText);
                      }
                    } else {
                      complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = callback("error");
              if (xhr.onabort !== undefined) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                if (callback) {
                  throw e;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
        contents: {script: /\b(?:java|ecma)script\b/},
        converters: {"text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }}
      });
      jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
          s.cache = false;
        }
        if (s.crossDomain) {
          s.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
          var script,
              callback;
          return {
            send: function(_, complete) {
              script = jQuery("<script>").prop({
                charset: s.scriptCharset,
                src: s.url
              }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [],
          rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName,
            overwritten,
            responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
          callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          }
          s.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s.dataTypes[0] = "json";
          overwritten = window[callbackName];
          window[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === undefined) {
              jQuery(window).removeProp(callbackName);
            } else {
              window[callbackName] = overwritten;
            }
            if (s[callbackName]) {
              s.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && jQuery.isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = undefined;
          });
          return "script";
        }
      });
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
          return null;
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      var _load = jQuery.fn.load;
      jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
          return _load.apply(this, arguments);
        }
        var selector,
            type,
            response,
            self = this,
            off = url.indexOf(" ");
        if (off > -1) {
          selector = jQuery.trim(url.slice(off));
          url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
          callback = params;
          params = undefined;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self.length > 0) {
          jQuery.ajax({
            url: url,
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
          }).always(callback && function(jqXHR, status) {
            self.each(function() {
              callback.apply(self, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
          return this.on(type, fn);
        };
      });
      jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
      }
      jQuery.offset = {setOffset: function(elem, options, i) {
          var curPosition,
              curLeft,
              curCSSTop,
              curTop,
              curOffset,
              curCSSLeft,
              calculatePosition,
              position = jQuery.css(elem, "position"),
              curElem = jQuery(elem),
              props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (jQuery.isFunction(options)) {
            options = options.call(elem, i, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = (options.top - curOffset.top) + curTop;
          }
          if (options.left != null) {
            props.left = (options.left - curOffset.left) + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }};
      jQuery.fn.extend({
        offset: function(options) {
          if (arguments.length) {
            return options === undefined ? this : this.each(function(i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }
          var docElem,
              win,
              elem = this[0],
              box = {
                top: 0,
                left: 0
              },
              doc = elem && elem.ownerDocument;
          if (!doc) {
            return;
          }
          docElem = doc.documentElement;
          if (!jQuery.contains(docElem, elem)) {
            return box;
          }
          box = elem.getBoundingClientRect();
          win = getWindow(doc);
          return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
          };
        },
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent,
              offset,
              elem = this[0],
              parentOffset = {
                top: 0,
                left: 0
              };
          if (jQuery.css(elem, "position") === "fixed") {
            offset = elem.getBoundingClientRect();
          } else {
            offsetParent = this.offsetParent();
            offset = this.offset();
            if (!jQuery.nodeName(offsetParent[0], "html")) {
              parentOffset = offsetParent.offset();
            }
            parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
          }
          return {
            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method, val) {
            var win = getWindow(elem);
            if (val === undefined) {
              return win ? win[prop] : elem[method];
            }
            if (win) {
              win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
            } else {
              elem[method] = val;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);
            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
          }
        });
      });
      jQuery.each({
        Height: "height",
        Width: "width"
      }, function(name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type, value) {
              var doc;
              if (jQuery.isWindow(elem)) {
                return elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
              }
              return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
            }, type, chainable ? margin : undefined, chainable, null);
          };
        });
      });
      jQuery.fn.extend({
        bind: function(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        size: function() {
          return this.length;
        }
      });
      jQuery.fn.andSelf = jQuery.fn.addBack;
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window.jQuery,
          _$ = window.$;
      jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
          window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
          window.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
      }
      return jQuery;
    }));
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("3", ["2"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('2');
  return module.exports;
});

$__System.registerDynamic("4", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy,
          toJson = angular.toJson;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i] || !parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              result = result.replace(/\/$/, '');
              surroundPattern = ['(?:\/(', ')|\/)?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          if (regexp) {
            type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          }
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        var param,
            paramVal;
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          param = this.params[paramName];
          paramVal = m[i + 1];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
          param = this.params[paramName];
          paramVal = searchParams[paramName];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            var isFinalPathParam = i + 1 === nPath;
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
            if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
              result = result.slice(0, -1);
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            if (encoded.length === 0)
              continue;
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              if (isArray(val) && val.length === 0)
                return val;
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              "string": {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              "int": {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              "bool": {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              "date": {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              "json": {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              "any": {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            if (angular.isString(config.type))
              return $types[config.type];
            if (config.type instanceof Type)
              return config.type;
            return new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              isHtml5 = isHtml5 && $sniffer.history;
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = inherit(state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            var ownParams = pick(state.ownParams, state.ownParams.$$keys());
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (hash)
              toParams['#'] = hash;
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                if ($state.transition == null)
                  $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').factory('$stateParams', function() {
        return {};
      }).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      var ngMajorVer = angular.version.major;
      var ngMinorVer = angular.version.minor;
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
          if (!!attrs.noanimation)
            return statics;
          function animEnabled(element) {
            if (ngMajorVer === 1 && ngMinorVer >= 4)
              return !!$animate.enabled(element);
            if (ngMajorVer === 1 && ngMinorVer >= 2)
              return !!$animate.enabled();
            return (!!$animator);
          }
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                if (!animEnabled(element)) {
                  statics.enter(element, target, cb);
                } else if (angular.version.minor > 2) {
                  $animate.enter(element, null, target).then(cb);
                } else {
                  $animate.enter(element, null, target, cb);
                }
              },
              leave: function(element, cb) {
                if (!animEnabled(element)) {
                  statics.leave(element, cb);
                } else if (angular.version.minor > 2) {
                  $animate.leave(element).then(cb);
                } else {
                  $animate.leave(element, cb);
                }
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics;
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                var _previousEl = previousEl;
                var _currentScope = currentScope;
                if (_currentScope) {
                  _currentScope._willBeDestroyed = true;
                }
                function cleanOld() {
                  if (_previousEl) {
                    _previousEl.remove();
                  }
                  if (_currentScope) {
                    _currentScope.$destroy();
                  }
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    cleanOld();
                    previousEl = null;
                  });
                  previousEl = currentEl;
                } else {
                  cleanOld();
                  previousEl = null;
                }
                currentEl = null;
                currentScope = null;
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                newScope.$emit('$viewContentLoading', name);
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded', name);
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      function getTypeInfo(el) {
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === "FORM";
        return {
          attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
          isAnchor: el.prop("tagName").toUpperCase() === "A",
          clickable: !isForm
        };
      }
      function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
          var button = e.which || e.button,
              target = current();
          if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
            var transition = $timeout(function() {
              $state.go(target.state, target.params, target.options);
            });
            e.preventDefault();
            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
            e.preventDefault = function() {
              if (ignorePreventDefaultCount-- <= 0)
                $timeout.cancel(transition);
            };
          }
        };
      }
      function defaultOpts(el, $state) {
        return {
          relative: stateContext(el) || $state.$current,
          inherit: true
        };
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var def = {
              state: ref.state,
              href: null,
              params: null
            };
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
            var update = function(val) {
              if (val)
                def.params = angular.copy(val);
              def.href = $state.href(ref.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(ref.state, def.params);
              if (def.href !== null)
                attrs.$set(type.attr, def.href);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(val) {
                if (val !== def.params)
                  update(val);
              }, true);
              def.params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefDynamicDirective.$inject = ['$state', '$timeout'];
      function $StateRefDynamicDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
            var watch = '[' + group.map(function(val) {
              return val || 'null';
            }).join(', ') + ']';
            var def = {
              state: null,
              params: null,
              options: null,
              href: null
            };
            function runStateRefLink(group) {
              def.state = group[0];
              def.params = group[1];
              def.options = group[2];
              def.href = $state.href(def.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(def.state, def.params);
              if (def.href)
                attrs.$set(type.attr, def.href);
            }
            scope.$watch(watch, runStateRefLink, true);
            runStateRefLink(scope.$eval(watch));
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', '$timeout', function($scope, $element, $attrs, $timeout) {
            var states = [],
                activeClasses = {},
                activeEqClass,
                uiSrefActive;
            activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
            try {
              uiSrefActive = $scope.$eval($attrs.uiSrefActive);
            } catch (e) {}
            uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
            if (isObject(uiSrefActive)) {
              forEach(uiSrefActive, function(stateOrName, activeClass) {
                if (isString(stateOrName)) {
                  var ref = parseStateRef(stateOrName, $state.current.name);
                  addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                }
              });
            }
            this.$$addStateInfo = function(newState, newParams) {
              if (isObject(uiSrefActive) && states.length > 0) {
                return;
              }
              addState(newState, newParams, uiSrefActive);
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function addState(stateName, stateParams, activeClass) {
              var state = $state.get(stateName, stateContext($element));
              var stateHash = createStateHash(stateName, stateParams);
              states.push({
                state: state || {name: stateName},
                params: stateParams,
                hash: stateHash
              });
              activeClasses[stateHash] = activeClass;
            }
            function createStateHash(state, params) {
              if (!isString(state)) {
                throw new Error('state should be a string');
              }
              if (isObject(params)) {
                return state + toJson(params);
              }
              params = $scope.$eval(params);
              if (isObject(params)) {
                return state + toJson(params);
              }
              return state;
            }
            function update() {
              for (var i = 0; i < states.length; i++) {
                if (anyMatch(states[i].state, states[i].params)) {
                  addClass($element, activeClasses[states[i].hash]);
                } else {
                  removeClass($element, activeClasses[states[i].hash]);
                }
                if (exactMatch(states[i].state, states[i].params)) {
                  addClass($element, activeEqClass);
                } else {
                  removeClass($element, activeEqClass);
                }
              }
            }
            function addClass(el, className) {
              $timeout(function() {
                el.addClass(className);
              });
            }
            function removeClass(el, className) {
              el.removeClass(className);
            }
            function anyMatch(state, params) {
              return $state.includes(state.name, params);
            }
            function exactMatch(state, params) {
              return $state.is(state.name, params);
            }
            update();
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state, params) {
          return $state.is(state, params);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
          return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("6", ["4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('4');
  return module.exports;
});

$__System.registerDynamic("7", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  var isDefined = angular.isDefined,
      isUndefined = angular.isUndefined,
      isNumber = angular.isNumber,
      isObject = angular.isObject,
      isArray = angular.isArray,
      extend = angular.extend,
      toJson = angular.toJson;
  angular.module('LocalStorageModule', []).provider('localStorageService', function() {
    this.prefix = 'ls';
    this.storageType = 'localStorage';
    this.cookie = {
      expiry: 30,
      path: '/'
    };
    this.notify = {
      setItem: true,
      removeItem: false
    };
    this.setPrefix = function(prefix) {
      this.prefix = prefix;
      return this;
    };
    this.setStorageType = function(storageType) {
      this.storageType = storageType;
      return this;
    };
    this.setStorageCookie = function(exp, path) {
      this.cookie.expiry = exp;
      this.cookie.path = path;
      return this;
    };
    this.setStorageCookieDomain = function(domain) {
      this.cookie.domain = domain;
      return this;
    };
    this.setNotify = function(itemSet, itemRemove) {
      this.notify = {
        setItem: itemSet,
        removeItem: itemRemove
      };
      return this;
    };
    this.$get = ['$rootScope', '$window', '$document', '$parse', function($rootScope, $window, $document, $parse) {
      var self = this;
      var prefix = self.prefix;
      var cookie = self.cookie;
      var notify = self.notify;
      var storageType = self.storageType;
      var webStorage;
      if (!$document) {
        $document = document;
      } else if ($document[0]) {
        $document = $document[0];
      }
      if (prefix.substr(-1) !== '.') {
        prefix = !!prefix ? prefix + '.' : '';
      }
      var deriveQualifiedKey = function(key) {
        return prefix + key;
      };
      var browserSupportsLocalStorage = (function() {
        try {
          var supported = (storageType in $window && $window[storageType] !== null);
          var key = deriveQualifiedKey('__' + Math.round(Math.random() * 1e7));
          if (supported) {
            webStorage = $window[storageType];
            webStorage.setItem(key, '');
            webStorage.removeItem(key);
          }
          return supported;
        } catch (e) {
          storageType = 'cookie';
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return false;
        }
      }());
      var addToLocalStorage = function(key, value) {
        if (isUndefined(value)) {
          value = null;
        } else {
          value = toJson(value);
        }
        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }
          if (notify.setItem) {
            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
              key: key,
              newvalue: value,
              storageType: 'cookie'
            });
          }
          return addToCookies(key, value);
        }
        try {
          if (webStorage) {
            webStorage.setItem(deriveQualifiedKey(key), value);
          }
          if (notify.setItem) {
            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
              key: key,
              newvalue: value,
              storageType: self.storageType
            });
          }
        } catch (e) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return addToCookies(key, value);
        }
        return true;
      };
      var getFromLocalStorage = function(key) {
        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }
          return getFromCookies(key);
        }
        var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
        if (!item || item === 'null') {
          return null;
        }
        try {
          return JSON.parse(item);
        } catch (e) {
          return item;
        }
      };
      var removeFromLocalStorage = function() {
        var i,
            key;
        for (i = 0; i < arguments.length; i++) {
          key = arguments[i];
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            if (notify.removeItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                key: key,
                storageType: 'cookie'
              });
            }
            removeFromCookies(key);
          } else {
            try {
              webStorage.removeItem(deriveQualifiedKey(key));
              if (notify.removeItem) {
                $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                  key: key,
                  storageType: self.storageType
                });
              }
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
              removeFromCookies(key);
            }
          }
        }
      };
      var getKeysForLocalStorage = function() {
        if (!browserSupportsLocalStorage) {
          $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          return false;
        }
        var prefixLength = prefix.length;
        var keys = [];
        for (var key in webStorage) {
          if (key.substr(0, prefixLength) === prefix) {
            try {
              keys.push(key.substr(prefixLength));
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.Description);
              return [];
            }
          }
        }
        return keys;
      };
      var clearAllFromLocalStorage = function(regularExpression) {
        var prefixRegex = !!prefix ? new RegExp('^' + prefix) : new RegExp();
        var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();
        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
          }
          return clearAllFromCookies();
        }
        var prefixLength = prefix.length;
        for (var key in webStorage) {
          if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
            try {
              removeFromLocalStorage(key.substr(prefixLength));
            } catch (e) {
              $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
              return clearAllFromCookies();
            }
          }
        }
        return true;
      };
      var browserSupportsCookies = (function() {
        try {
          return $window.navigator.cookieEnabled || ("cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1));
        } catch (e) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return false;
        }
      }());
      var addToCookies = function(key, value, daysToExpiry) {
        if (isUndefined(value)) {
          return false;
        } else if (isArray(value) || isObject(value)) {
          value = toJson(value);
        }
        if (!browserSupportsCookies) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
          return false;
        }
        try {
          var expiry = '',
              expiryDate = new Date(),
              cookieDomain = '';
          if (value === null) {
            expiryDate.setTime(expiryDate.getTime() + (-1 * 24 * 60 * 60 * 1000));
            expiry = "; expires=" + expiryDate.toGMTString();
            value = '';
          } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
            expiryDate.setTime(expiryDate.getTime() + (daysToExpiry * 24 * 60 * 60 * 1000));
            expiry = "; expires=" + expiryDate.toGMTString();
          } else if (cookie.expiry !== 0) {
            expiryDate.setTime(expiryDate.getTime() + (cookie.expiry * 24 * 60 * 60 * 1000));
            expiry = "; expires=" + expiryDate.toGMTString();
          }
          if (!!key) {
            var cookiePath = "; path=" + cookie.path;
            if (cookie.domain) {
              cookieDomain = "; domain=" + cookie.domain;
            }
            $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
          }
        } catch (e) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
          return false;
        }
        return true;
      };
      var getFromCookies = function(key) {
        if (!browserSupportsCookies) {
          $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
          return false;
        }
        var cookies = $document.cookie && $document.cookie.split(';') || [];
        for (var i = 0; i < cookies.length; i++) {
          var thisCookie = cookies[i];
          while (thisCookie.charAt(0) === ' ') {
            thisCookie = thisCookie.substring(1, thisCookie.length);
          }
          if (thisCookie.indexOf(deriveQualifiedKey(key) + '=') === 0) {
            var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
            try {
              return JSON.parse(storedValues);
            } catch (e) {
              return storedValues;
            }
          }
        }
        return null;
      };
      var removeFromCookies = function(key) {
        addToCookies(key, null);
      };
      var clearAllFromCookies = function() {
        var thisCookie = null,
            thisKey = null;
        var prefixLength = prefix.length;
        var cookies = $document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
          thisCookie = cookies[i];
          while (thisCookie.charAt(0) === ' ') {
            thisCookie = thisCookie.substring(1, thisCookie.length);
          }
          var key = thisCookie.substring(prefixLength, thisCookie.indexOf('='));
          removeFromCookies(key);
        }
      };
      var getStorageType = function() {
        return storageType;
      };
      var bindToScope = function(scope, key, def, lsKey) {
        lsKey = lsKey || key;
        var value = getFromLocalStorage(lsKey);
        if (value === null && isDefined(def)) {
          value = def;
        } else if (isObject(value) && isObject(def)) {
          value = extend(value, def);
        }
        $parse(key).assign(scope, value);
        return scope.$watch(key, function(newVal) {
          addToLocalStorage(lsKey, newVal);
        }, isObject(scope[key]));
      };
      var lengthOfLocalStorage = function() {
        var count = 0;
        var storage = $window[storageType];
        for (var i = 0; i < storage.length; i++) {
          if (storage.key(i).indexOf(prefix) === 0) {
            count++;
          }
        }
        return count;
      };
      return {
        isSupported: browserSupportsLocalStorage,
        getStorageType: getStorageType,
        set: addToLocalStorage,
        add: addToLocalStorage,
        get: getFromLocalStorage,
        keys: getKeysForLocalStorage,
        remove: removeFromLocalStorage,
        clearAll: clearAllFromLocalStorage,
        bind: bindToScope,
        deriveKey: deriveQualifiedKey,
        length: lengthOfLocalStorage,
        cookie: {
          isSupported: browserSupportsCookies,
          set: addToCookies,
          add: addToCookies,
          get: getFromCookies,
          remove: removeFromCookies,
          clearAll: clearAllFromCookies
        }
      };
    }];
  });
  return module.exports;
});

$__System.registerDynamic("8", ["7"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('7');
  module.exports = 'LocalStorageModule';
  return module.exports;
});

$__System.registerDynamic("9", ["8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('8');
  return module.exports;
});

$__System.register("a", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("b", ["a", "5", "c", "d"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps ./angular-material.css!";
    "deps angular";
    "deps angular-animate";
    "deps angular-aria";
    (function(window, angular, undefined) {
      "use strict";
      (function() {
        "use strict";
        angular.module('ngMaterial', ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.bottomSheet", "material.components.chips", "material.components.dialog", "material.components.divider", "material.components.datepicker", "material.components.content", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.fabTrigger", "material.components.icon", "material.components.input", "material.components.menuBar", "material.components.list", "material.components.menu", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.toast", "material.components.tabs", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe"]);
      })();
      (function() {
        "use strict";
        angular.module('material.core', ['ngAnimate', 'material.core.animate', 'material.core.layout', 'material.core.gestures', 'material.core.theming']).config(MdCoreConfigure).run(DetectNgTouch);
        function DetectNgTouch($log, $injector) {
          if ($injector.has('$swipe')) {
            var msg = "" + "You are using the ngTouch module. \n" + "Angular Material already has mobile click, tap, and swipe support... \n" + "ngTouch is not supported with Angular Material!";
            $log.warn(msg);
          }
        }
        DetectNgTouch.$inject = ["$log", "$injector"];
        function MdCoreConfigure($provide, $mdThemingProvider) {
          $provide.decorator('$$rAF', ["$delegate", rAFDecorator]);
          $mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('pink').warnPalette('deep-orange').backgroundPalette('grey');
        }
        MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
        function rAFDecorator($delegate) {
          $delegate.throttle = function(cb) {
            var queuedArgs,
                alreadyQueued,
                queueCb,
                context;
            return function debounced() {
              queuedArgs = arguments;
              context = this;
              queueCb = cb;
              if (!alreadyQueued) {
                alreadyQueued = true;
                $delegate(function() {
                  queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                  alreadyQueued = false;
                });
              }
            };
          };
          return $delegate;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').directive('mdAutofocus', MdAutofocusDirective).directive('mdAutoFocus', MdAutofocusDirective).directive('mdSidenavFocus', MdAutofocusDirective);
        function MdAutofocusDirective() {
          return {
            restrict: 'A',
            link: postLink
          };
        }
        function postLink(scope, element, attrs) {
          var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;
          scope.$watch(attr, function(canAutofocus) {
            element.toggleClass('_md-autofocus', canAutofocus);
          });
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdConstant', MdConstantFactory);
        function MdConstantFactory($sniffer) {
          var webkit = /webkit/i.test($sniffer.vendorPrefix);
          function vendorProperty(name) {
            return webkit ? ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;
          }
          return {
            KEY_CODE: {
              COMMA: 188,
              SEMICOLON: 186,
              ENTER: 13,
              ESCAPE: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT_ARROW: 37,
              UP_ARROW: 38,
              RIGHT_ARROW: 39,
              DOWN_ARROW: 40,
              TAB: 9,
              BACKSPACE: 8,
              DELETE: 46
            },
            CSS: {
              TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),
              ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),
              TRANSFORM: vendorProperty('transform'),
              TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
              TRANSITION: vendorProperty('transition'),
              TRANSITION_DURATION: vendorProperty('transitionDuration'),
              ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
              ANIMATION_DURATION: vendorProperty('animationDuration'),
              ANIMATION_NAME: vendorProperty('animationName'),
              ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
              ANIMATION_DIRECTION: vendorProperty('animationDirection')
            },
            MEDIA: {
              'xs': '(max-width: 599px)',
              'gt-xs': '(min-width: 600px)',
              'sm': '(min-width: 600px) and (max-width: 959px)',
              'gt-sm': '(min-width: 960px)',
              'md': '(min-width: 960px) and (max-width: 1279px)',
              'gt-md': '(min-width: 1280px)',
              'lg': '(min-width: 1280px) and (max-width: 1919px)',
              'gt-lg': '(min-width: 1920px)',
              'xl': '(min-width: 1920px)',
              'print': 'print'
            },
            MEDIA_PRIORITY: ['xl', 'gt-lg', 'lg', 'gt-md', 'md', 'gt-sm', 'sm', 'gt-xs', 'xs', 'print']
          };
        }
        MdConstantFactory.$inject = ["$sniffer"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').config(["$provide", function($provide) {
          $provide.decorator('$mdUtil', ['$delegate', function($delegate) {
            $delegate.iterator = MdIterator;
            return $delegate;
          }]);
        }]);
        function MdIterator(items, reloop) {
          var trueFn = function() {
            return true;
          };
          if (items && !angular.isArray(items)) {
            items = Array.prototype.slice.call(items);
          }
          reloop = !!reloop;
          var _items = items || [];
          return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
          };
          function getItems() {
            return [].concat(_items);
          }
          function count() {
            return _items.length;
          }
          function inRange(index) {
            return _items.length && (index > -1) && (index < _items.length);
          }
          function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
          }
          function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
          }
          function itemAt(index) {
            return inRange(index) ? _items[index] : null;
          }
          function findBy(key, val) {
            return _items.filter(function(item) {
              return item[key] === val;
            });
          }
          function add(item, index) {
            if (!item)
              return -1;
            if (!angular.isNumber(index)) {
              index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
          }
          function remove(item) {
            if (contains(item)) {
              _items.splice(indexOf(item), 1);
            }
          }
          function indexOf(item) {
            return _items.indexOf(item);
          }
          function contains(item) {
            return item && (indexOf(item) > -1);
          }
          function first() {
            return _items.length ? _items[0] : null;
          }
          function last() {
            return _items.length ? _items[_items.length - 1] : null;
          }
          function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            while (true) {
              if (!inRange(curIndex))
                return null;
              var nextIndex = curIndex + (backwards ? -1 : 1);
              var foundItem = null;
              if (inRange(nextIndex)) {
                foundItem = _items[nextIndex];
              } else if (reloop) {
                foundItem = backwards ? last() : first();
                nextIndex = indexOf(foundItem);
              }
              if ((foundItem === null) || (nextIndex === limit))
                return null;
              if (validate(foundItem))
                return foundItem;
              if (angular.isUndefined(limit))
                limit = nextIndex;
              curIndex = nextIndex;
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdMedia', mdMediaFactory);
        function mdMediaFactory($mdConstant, $rootScope, $window) {
          var queries = {};
          var mqls = {};
          var results = {};
          var normalizeCache = {};
          $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
          $mdMedia.getQuery = getQuery;
          $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
          return $mdMedia;
          function $mdMedia(query) {
            var validated = queries[query];
            if (angular.isUndefined(validated)) {
              validated = queries[query] = validate(query);
            }
            var result = results[validated];
            if (angular.isUndefined(result)) {
              result = add(validated);
            }
            return result;
          }
          function validate(query) {
            return $mdConstant.MEDIA[query] || ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);
          }
          function add(query) {
            var result = mqls[query];
            if (!result) {
              result = mqls[query] = $window.matchMedia(query);
            }
            result.addListener(onQueryChange);
            return (results[result.media] = !!result.matches);
          }
          function onQueryChange(query) {
            $rootScope.$evalAsync(function() {
              results[query.media] = !!query.matches;
            });
          }
          function getQuery(name) {
            return mqls[name];
          }
          function getResponsiveAttribute(attrs, attrName) {
            for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
              var mediaName = $mdConstant.MEDIA_PRIORITY[i];
              if (!mqls[queries[mediaName]].matches) {
                continue;
              }
              var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
              if (attrs[normalizedName]) {
                return attrs[normalizedName];
              }
            }
            return attrs[getNormalizedName(attrs, attrName)];
          }
          function watchResponsiveAttributes(attrNames, attrs, watchFn) {
            var unwatchFns = [];
            attrNames.forEach(function(attrName) {
              var normalizedName = getNormalizedName(attrs, attrName);
              if (angular.isDefined(attrs[normalizedName])) {
                unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
              }
              for (var mediaName in $mdConstant.MEDIA) {
                normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
                if (angular.isDefined(attrs[normalizedName])) {
                  unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                }
              }
            });
            return function unwatch() {
              unwatchFns.forEach(function(fn) {
                fn();
              });
            };
          }
          function getNormalizedName(attrs, attrName) {
            return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
          }
        }
        mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
      })();
      (function() {
        "use strict";
        var nextUniqueId = 0;
        angular.module('material.core').factory('$mdUtil', UtilFactory);
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));
          var hasComputedStyle = function(target, key, expectedVal) {
            var hasValue = false;
            if (target && target.length) {
              var computedStyles = $window.getComputedStyle(target[0]);
              hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
            }
            return hasValue;
          };
          var $mdUtil = {
            dom: {},
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
              return new Date().getTime();
            },
            clientRect: function(element, offsetParent, isOffsetRect) {
              var node = getNode(element);
              offsetParent = getNode(offsetParent || node.offsetParent || document.body);
              var nodeRect = node.getBoundingClientRect();
              var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              };
              return {
                left: nodeRect.left - offsetRect.left,
                top: nodeRect.top - offsetRect.top,
                width: nodeRect.width,
                height: nodeRect.height
              };
            },
            offsetRect: function(element, offsetParent) {
              return $mdUtil.clientRect(element, offsetParent, true);
            },
            nodesToArray: function(nodes) {
              nodes = nodes || [];
              var results = [];
              for (var i = 0; i < nodes.length; ++i) {
                results.push(nodes.item(i));
              }
              return results;
            },
            scrollTop: function(element) {
              element = angular.element(element || $document[0].body);
              var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
              var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
              return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
            },
            findFocusTarget: function(containerEl, attributeVal) {
              var AUTO_FOCUS = '[md-autofocus]';
              var elToFocus;
              elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
              if (!elToFocus && attributeVal != AUTO_FOCUS) {
                elToFocus = scanForFocusable(containerEl, '[md-auto-focus]');
                if (!elToFocus) {
                  elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
                }
              }
              return elToFocus;
              function scanForFocusable(target, selector) {
                var elFound,
                    items = target[0].querySelectorAll(selector);
                if (items && items.length) {
                  items.length && angular.forEach(items, function(it) {
                    it = angular.element(it);
                    var isFocusable = it.hasClass('_md-autofocus');
                    if (isFocusable)
                      elFound = it;
                  });
                }
                return elFound;
              }
            },
            disableScrollAround: function(element, parent) {
              $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
              ++$mdUtil.disableScrollAround._count;
              if ($mdUtil.disableScrollAround._enableScrolling)
                return $mdUtil.disableScrollAround._enableScrolling;
              element = angular.element(element);
              var body = $document[0].body,
                  restoreBody = disableBodyScroll(),
                  restoreElement = disableElementScroll(parent);
              return $mdUtil.disableScrollAround._enableScrolling = function() {
                if (!--$mdUtil.disableScrollAround._count) {
                  restoreBody();
                  restoreElement();
                  delete $mdUtil.disableScrollAround._enableScrolling;
                }
              };
              function disableElementScroll(element) {
                element = angular.element(element || body)[0];
                var zIndex = 50;
                var scrollMask = angular.element('<div class="md-scroll-mask">' + '  <div class="md-scroll-mask-bar"></div>' + '</div>').css('z-index', zIndex);
                element.appendChild(scrollMask[0]);
                scrollMask.on('wheel', preventDefault);
                scrollMask.on('touchmove', preventDefault);
                $document.on('keydown', disableKeyNav);
                return function restoreScroll() {
                  scrollMask.off('wheel');
                  scrollMask.off('touchmove');
                  scrollMask[0].parentNode.removeChild(scrollMask[0]);
                  $document.off('keydown', disableKeyNav);
                  delete $mdUtil.disableScrollAround._enableScrolling;
                };
                function disableKeyNav(e) {}
                function preventDefault(e) {
                  e.preventDefault();
                }
              }
              function disableBodyScroll() {
                var htmlNode = body.parentNode;
                var restoreHtmlStyle = htmlNode.style.cssText || '';
                var restoreBodyStyle = body.style.cssText || '';
                var scrollOffset = $mdUtil.scrollTop(body);
                var clientWidth = body.clientWidth;
                if (body.scrollHeight > body.clientHeight + 1) {
                  applyStyles(body, {
                    position: 'fixed',
                    width: '100%',
                    top: -scrollOffset + 'px'
                  });
                  applyStyles(htmlNode, {overflowY: 'scroll'});
                }
                if (body.clientWidth < clientWidth)
                  applyStyles(body, {overflow: 'hidden'});
                return function restoreScroll() {
                  body.style.cssText = restoreBodyStyle;
                  htmlNode.style.cssText = restoreHtmlStyle;
                  body.scrollTop = scrollOffset;
                  htmlNode.scrollTop = scrollOffset;
                };
              }
              function applyStyles(el, styles) {
                for (var key in styles) {
                  el.style[key] = styles[key];
                }
              }
            },
            enableScrolling: function() {
              var method = this.disableScrollAround._enableScrolling;
              method && method();
            },
            floatingScrollbars: function() {
              if (this.floatingScrollbars.cached === undefined) {
                var tempNode = angular.element('<div><div></div></div>').css({
                  width: '100%',
                  'z-index': -1,
                  position: 'absolute',
                  height: '35px',
                  'overflow-y': 'scroll'
                });
                tempNode.children().css('height', '60px');
                $document[0].body.appendChild(tempNode[0]);
                this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
                tempNode.remove();
              }
              return this.floatingScrollbars.cached;
            },
            forceFocus: function(element) {
              var node = element[0] || element;
              document.addEventListener('click', function focusOnClick(ev) {
                if (ev.target === node && ev.$focus) {
                  node.focus();
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  node.removeEventListener('click', focusOnClick);
                }
              }, true);
              var newEvent = document.createEvent('MouseEvents');
              newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null);
              newEvent.$material = true;
              newEvent.$focus = true;
              node.dispatchEvent(newEvent);
            },
            createBackdrop: function(scope, addClass) {
              return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
            },
            supplant: function(template, values, pattern) {
              pattern = pattern || /\{([^\{\}]*)\}/g;
              return template.replace(pattern, function(a, b) {
                var p = b.split('.'),
                    r = values;
                try {
                  for (var s in p) {
                    if (p.hasOwnProperty(s)) {
                      r = r[p[s]];
                    }
                  }
                } catch (e) {
                  r = a;
                }
                return (typeof r === 'string' || typeof r === 'number') ? r : a;
              });
            },
            fakeNgModel: function() {
              return {
                $fake: true,
                $setTouched: angular.noop,
                $setViewValue: function(value) {
                  this.$viewValue = value;
                  this.$render(value);
                  this.$viewChangeListeners.forEach(function(cb) {
                    cb();
                  });
                },
                $isEmpty: function(value) {
                  return ('' + value).length === 0;
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: [],
                $render: angular.noop
              };
            },
            debounce: function(func, wait, scope, invokeApply) {
              var timer;
              return function debounced() {
                var context = scope,
                    args = Array.prototype.slice.call(arguments);
                $timeout.cancel(timer);
                timer = $timeout(function() {
                  timer = undefined;
                  func.apply(context, args);
                }, wait || 10, invokeApply);
              };
            },
            throttle: function throttle(func, delay) {
              var recent;
              return function throttled() {
                var context = this;
                var args = arguments;
                var now = $mdUtil.now();
                if (!recent || (now - recent > delay)) {
                  func.apply(context, args);
                  recent = now;
                }
              };
            },
            time: function time(cb) {
              var start = $mdUtil.now();
              cb();
              return $mdUtil.now() - start;
            },
            valueOnUse: function(scope, key, getter) {
              var value = null,
                  args = Array.prototype.slice.call(arguments);
              var params = (args.length > 3) ? args.slice(3) : [];
              Object.defineProperty(scope, key, {get: function() {
                  if (value === null)
                    value = getter.apply(scope, params);
                  return value;
                }});
            },
            nextUid: function() {
              return '' + nextUniqueId++;
            },
            disconnectScope: function disconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (scope.$$destroyed)
                return;
              var parent = scope.$parent;
              scope.$$disconnected = true;
              if (parent.$$childHead === scope)
                parent.$$childHead = scope.$$nextSibling;
              if (parent.$$childTail === scope)
                parent.$$childTail = scope.$$prevSibling;
              if (scope.$$prevSibling)
                scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
              if (scope.$$nextSibling)
                scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
              scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (!scope.$$disconnected)
                return;
              var child = scope;
              var parent = child.$parent;
              child.$$disconnected = false;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
            },
            getClosest: function getClosest(el, tagName, onlyParent) {
              if (el instanceof angular.element)
                el = el[0];
              tagName = tagName.toUpperCase();
              if (onlyParent)
                el = el.parentNode;
              if (!el)
                return null;
              do {
                if (el.nodeName === tagName) {
                  return el;
                }
              } while (el = el.parentNode);
              return null;
            },
            elementContains: function(node, child) {
              var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
              var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                return (node === child) || !!(this.compareDocumentPosition(arg) & 16);
              });
              return findFn(child);
            },
            extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
              var found = scanTree(element);
              if (!found && !!warnNotFound) {
                $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));
              }
              return angular.element(found || element);
              function scanTree(element) {
                return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
              }
              function scanLevel(element) {
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    if (element[i].nodeName.toLowerCase() === nodeName) {
                      return element[i];
                    }
                  }
                }
                return null;
              }
              function scanChildren(element) {
                var found;
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    var target = element[i];
                    if (!found) {
                      for (var j = 0,
                          numChild = target.childNodes.length; j < numChild; j++) {
                        found = found || scanTree([target.childNodes[j]]);
                      }
                    }
                  }
                }
                return found;
              }
            },
            initOptionalProperties: function(scope, attr, defaults) {
              defaults = defaults || {};
              angular.forEach(scope.$$isolateBindings, function(binding, key) {
                if (binding.optional && angular.isUndefined(scope[key])) {
                  var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                  scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                }
              });
            },
            nextTick: function(callback, digest, scope) {
              var nextTick = $mdUtil.nextTick;
              var timeout = nextTick.timeout;
              var queue = nextTick.queue || [];
              queue.push(callback);
              if (digest == null)
                digest = true;
              nextTick.digest = nextTick.digest || digest;
              nextTick.queue = queue;
              return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));
              function processQueue() {
                var skip = scope && scope.$$destroyed;
                var queue = !skip ? nextTick.queue : [];
                var digest = !skip ? nextTick.digest : null;
                nextTick.queue = [];
                nextTick.timeout = null;
                nextTick.digest = false;
                queue.forEach(function(callback) {
                  callback();
                });
                if (digest)
                  $rootScope.$digest();
              }
            },
            processTemplate: function(template) {
              if (usesStandardSymbols) {
                return template;
              } else {
                if (!template || !angular.isString(template))
                  return template;
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              }
            },
            getParentWithPointerEvents: function(element) {
              var parent = element.parent();
              while (hasComputedStyle(parent, 'pointer-events', 'none')) {
                parent = parent.parent();
              }
              return parent;
            },
            getNearestContentElement: function(element) {
              var current = element.parent()[0];
              while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
                current = current.parentNode;
              }
              return current;
            },
            hasComputedStyle: hasComputedStyle
          };
          $mdUtil.dom.animator = $$mdAnimate($mdUtil);
          return $mdUtil;
          function getNode(el) {
            return el[0] || el;
          }
        }
        UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window"];
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
          if (this.length) {
            this[0].focus();
          }
          return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
          if (this.length) {
            this[0].blur();
          }
          return this;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdAria', AriaService);
        function AriaService($$rAF, $log, $window, $interpolate) {
          return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
          };
          function expect(element, attrName, defaultValue) {
            var node = angular.element(element)[0] || element;
            if (node && ((!node.hasAttribute(attrName) || node.getAttribute(attrName).length === 0) && !childHasAttribute(node, attrName))) {
              defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';
              if (defaultValue.length) {
                element.attr(attrName, defaultValue);
              } else {
                $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
              }
            }
          }
          function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
              expect(element, attrName, defaultValueGetter());
            });
          }
          function expectWithText(element, attrName) {
            var content = getText(element) || "";
            var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
            if (hasBinding) {
              expectAsync(element, attrName, function() {
                return getText(element);
              });
            } else {
              expect(element, attrName, content);
            }
          }
          function getText(element) {
            return (element.text() || "").trim();
          }
          function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(),
                hasAttr = false;
            function isHidden(el) {
              var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
              return (style.display === 'none');
            }
            if (hasChildren) {
              var children = node.childNodes;
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                  if (!isHidden(child)) {
                    hasAttr = true;
                  }
                }
              }
            }
            return hasAttr;
          }
        }
        AriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdCompiler', mdCompilerService);
        function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
          this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = angular.extend({}, options.resolve || {});
            var locals = angular.extend({}, options.locals || {});
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
              if (angular.isString(value)) {
                resolve[key] = $injector.get(value);
              } else {
                resolve[key] = $injector.invoke(value);
              }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
              resolve.$template = $http.get(templateUrl, {cache: $templateCache}).then(function(response) {
                return response.data;
              });
            } else {
              resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
              var compiledData;
              var template = transformTemplate(locals.$template, options);
              var element = options.element || angular.element('<div>').html(template.trim()).contents();
              var linkFn = $compile(element);
              return compiledData = {
                locals: locals,
                element: element,
                link: function link(scope) {
                  locals.$scope = scope;
                  if (controller) {
                    var invokeCtrl = $controller(controller, locals, true);
                    if (bindToController) {
                      angular.extend(invokeCtrl.instance, locals);
                    }
                    var ctrl = invokeCtrl();
                    element.data('$ngControllerController', ctrl);
                    element.children().data('$ngControllerController', ctrl);
                    if (controllerAs) {
                      scope[controllerAs] = ctrl;
                    }
                    compiledData.controller = ctrl;
                  }
                  return linkFn(scope);
                }
              };
            });
          };
        }
        mdCompilerService.$inject = ["$q", "$http", "$injector", "$compile", "$controller", "$templateCache"];
      })();
      (function() {
        "use strict";
        var HANDLERS = {};
        var pointer,
            lastPointer,
            forceSkipClickHijack = false;
        var lastLabelClickPos = null;
        var isInitialized = false;
        angular.module('material.core.gestures', []).provider('$mdGesture', MdGestureProvider).factory('$$MdGestureHandler', MdGestureHandler).run(attachToDocument);
        function MdGestureProvider() {}
        MdGestureProvider.prototype = {
          skipClickHijack: function() {
            return forceSkipClickHijack = true;
          },
          $get: ["$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
            return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
          }]
        };
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          var isIos = userAgent.match(/ipad|iphone|ipod/i);
          var isAndroid = userAgent.match(/android/i);
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          var self = {
            handler: addHandler,
            register: register,
            isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
          };
          if (self.isHijackingClicks) {
            var maxClickDistance = 6;
            self.handler('click', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('click')
            });
            self.handler('focus', {
              options: {maxDistance: maxClickDistance},
              onEnd: function(ev, pointer) {
                if (pointer.distance < this.state.options.maxDistance) {
                  if (canFocus(ev.target)) {
                    this.dispatchEvent(ev, 'focus', pointer);
                    ev.target.focus();
                  }
                }
                function canFocus(element) {
                  var focusableElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'];
                  return (element.getAttribute('tabindex') != '-1') && !element.hasAttribute('DISABLED') && (element.hasAttribute('tabindex') || element.hasAttribute('href') || (focusableElements.indexOf(element.nodeName) != -1));
                }
              }
            });
            self.handler('mouseup', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('mouseup')
            });
            self.handler('mousedown', {onStart: function(ev) {
                this.dispatchEvent(ev, 'mousedown');
              }});
          }
          function checkDistanceAndEmit(eventName) {
            return function(ev, pointer) {
              if (pointer.distance < this.state.options.maxDistance) {
                this.dispatchEvent(ev, eventName, pointer);
              }
            };
          }
          function register(element, handlerName, options) {
            var handler = HANDLERS[handlerName.replace(/^\$md./, '')];
            if (!handler) {
              throw new Error('Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object.keys(HANDLERS).join(', '));
            }
            return handler.registerElement(element, options);
          }
          function addHandler(name, definition) {
            var handler = new $$MdGestureHandler(name);
            angular.extend(handler, definition);
            HANDLERS[name] = handler;
            return self;
          }
          return self.handler('press', {
            onStart: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressdown');
            },
            onEnd: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressup');
            }
          }).handler('hold', {
            options: {
              maxDistance: 6,
              delay: 500
            },
            onCancel: function() {
              $timeout.cancel(this.state.timeout);
            },
            onStart: function(ev, pointer) {
              if (!this.state.registeredParent)
                return this.cancel();
              this.state.pos = {
                x: pointer.x,
                y: pointer.y
              };
              this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
                this.dispatchEvent(ev, '$md.hold');
                this.cancel();
              }), this.state.options.delay, false);
            },
            onMove: function(ev, pointer) {
              ev.preventDefault();
              var dx = this.state.pos.x - pointer.x;
              var dy = this.state.pos.y - pointer.y;
              if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
                this.cancel();
              }
            },
            onEnd: function() {
              this.onCancel();
            }
          }).handler('drag', {
            options: {
              minDistance: 6,
              horizontal: true,
              cancelMultiplier: 1.5
            },
            onStart: function(ev) {
              if (!this.state.registeredParent)
                this.cancel();
            },
            onMove: function(ev, pointer) {
              var shouldStartDrag,
                  shouldCancel;
              ev.preventDefault();
              if (!this.state.dragPointer) {
                if (this.state.options.horizontal) {
                  shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                } else {
                  shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                }
                if (shouldStartDrag) {
                  this.state.dragPointer = makeStartPointer(ev);
                  updatePointerState(ev, this.state.dragPointer);
                  this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);
                } else if (shouldCancel) {
                  this.cancel();
                }
              } else {
                this.dispatchDragMove(ev);
              }
            },
            dispatchDragMove: $$rAF.throttle(function(ev) {
              if (this.state.isRunning) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);
              }
            }),
            onEnd: function(ev, pointer) {
              if (this.state.dragPointer) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);
              }
            }
          }).handler('swipe', {
            options: {
              minVelocity: 0.65,
              minDistance: 10
            },
            onEnd: function(ev, pointer) {
              var eventType;
              if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';
                this.dispatchEvent(ev, eventType);
              } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown';
                this.dispatchEvent(ev, eventType);
              }
            }
          });
        }
        MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
        function GestureHandler(name) {
          this.name = name;
          this.state = {};
        }
        function MdGestureHandler() {
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          GestureHandler.prototype = {
            options: {},
            dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
            onStart: angular.noop,
            onMove: angular.noop,
            onEnd: angular.noop,
            onCancel: angular.noop,
            start: function(ev, pointer) {
              if (this.state.isRunning)
                return;
              var parentTarget = this.getNearestParent(ev.target);
              var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
              this.state = {
                isRunning: true,
                options: angular.extend({}, this.options, parentTargetOptions),
                registeredParent: parentTarget
              };
              this.onStart(ev, pointer);
            },
            move: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onMove(ev, pointer);
            },
            end: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onEnd(ev, pointer);
              this.state.isRunning = false;
            },
            cancel: function(ev, pointer) {
              this.onCancel(ev, pointer);
              this.state = {};
            },
            getNearestParent: function(node) {
              var current = node;
              while (current) {
                if ((current.$mdGesture || {})[this.name]) {
                  return current;
                }
                current = current.parentNode;
              }
              return null;
            },
            registerElement: function(element, options) {
              var self = this;
              element[0].$mdGesture = element[0].$mdGesture || {};
              element[0].$mdGesture[this.name] = options || {};
              element.on('$destroy', onDestroy);
              return onDestroy;
              function onDestroy() {
                delete element[0].$mdGesture[self.name];
                element.off('$destroy', onDestroy);
              }
            }
          };
          return GestureHandler;
          function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj = new angular.element.Event(eventType);
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            angular.extend(eventObj, {
              clientX: eventPointer.x,
              clientY: eventPointer.y,
              screenX: eventPointer.x,
              screenY: eventPointer.y,
              pageX: eventPointer.x,
              pageY: eventPointer.y,
              ctrlKey: srcEvent.ctrlKey,
              altKey: srcEvent.altKey,
              shiftKey: srcEvent.shiftKey,
              metaKey: srcEvent.metaKey
            });
            angular.element(eventPointer.target).trigger(eventObj);
          }
          function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj;
            if (eventType === 'click' || eventType == 'mouseup' || eventType == 'mousedown') {
              eventObj = document.createEvent('MouseEvents');
              eventObj.initMouseEvent(eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
            } else {
              eventObj = document.createEvent('CustomEvent');
              eventObj.initCustomEvent(eventType, true, true, {});
            }
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            eventPointer.target.dispatchEvent(eventObj);
          }
        }
        function attachToDocument($mdGesture, $$MdGestureHandler) {
          document.contains || (document.contains = function(node) {
            return document.body.contains(node);
          });
          if (!isInitialized && $mdGesture.isHijackingClicks) {
            document.addEventListener('click', clickHijacker, true);
            document.addEventListener('mouseup', mouseInputHijacker, true);
            document.addEventListener('mousedown', mouseInputHijacker, true);
            document.addEventListener('focus', mouseInputHijacker, true);
            isInitialized = true;
          }
          function mouseInputHijacker(ev) {
            var isKeyClick = !ev.clientX && !ev.clientY;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          }
          function clickHijacker(ev) {
            var isKeyClick = ev.clientX === 0 && ev.clientY === 0;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
              lastLabelClickPos = null;
            } else {
              lastLabelClickPos = null;
              if (ev.target.tagName.toLowerCase() == 'label') {
                lastLabelClickPos = {
                  x: ev.x,
                  y: ev.y
                };
              }
            }
          }
          var START_EVENTS = 'mousedown touchstart pointerdown';
          var MOVE_EVENTS = 'mousemove touchmove pointermove';
          var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';
          angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on('$$mdGestureReset', function gestureClearCache() {
            lastPointer = pointer = null;
          });
          function runHandlers(handlerEvent, event) {
            var handler;
            for (var name in HANDLERS) {
              handler = HANDLERS[name];
              if (handler instanceof $$MdGestureHandler) {
                if (handlerEvent === 'start') {
                  handler.cancel();
                }
                handler[handlerEvent](event, pointer);
              }
            }
          }
          function gestureStart(ev) {
            if (pointer)
              return;
            var now = +Date.now();
            if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {
              return;
            }
            pointer = makeStartPointer(ev);
            runHandlers('start', ev);
          }
          function gestureMove(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            runHandlers('move', ev);
          }
          function gestureEnd(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            pointer.endTime = +Date.now();
            runHandlers('end', ev);
            lastPointer = pointer;
            pointer = null;
          }
        }
        attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];
        function makeStartPointer(ev) {
          var point = getEventPoint(ev);
          var startPointer = {
            startTime: +Date.now(),
            target: ev.target,
            type: ev.type.charAt(0)
          };
          startPointer.startX = startPointer.x = point.pageX;
          startPointer.startY = startPointer.y = point.pageY;
          return startPointer;
        }
        function typesMatch(ev, pointer) {
          return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        function isInputEventFromLabelClick(event) {
          return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        function updatePointerState(ev, pointer) {
          var point = getEventPoint(ev);
          var x = pointer.x = point.pageX;
          var y = pointer.y = point.pageY;
          pointer.distanceX = x - pointer.startX;
          pointer.distanceY = y - pointer.startY;
          pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
          pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';
          pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : '';
          pointer.duration = +Date.now() - pointer.startTime;
          pointer.velocityX = pointer.distanceX / pointer.duration;
          pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        function getEventPoint(ev) {
          ev = ev.originalEvent || ev;
          return (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$$interimElement', InterimElementProvider);
        function InterimElementProvider() {
          createInterimElementProvider.$get = InterimElementFactory;
          InterimElementFactory.$inject = ["$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector"];
          return createInterimElementProvider;
          function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];
            var customMethods = {};
            var providerConfig = {presets: {}};
            var provider = {
              setDefaults: setDefaults,
              addPreset: addPreset,
              addMethod: addMethod,
              $get: factory
            };
            provider.addPreset('build', {methods: ['controller', 'controllerAs', 'resolve', 'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']});
            factory.$inject = ["$$interimElement", "$injector"];
            return provider;
            function setDefaults(definition) {
              providerConfig.optionsFactory = definition.options;
              providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
              return provider;
            }
            function addMethod(name, fn) {
              customMethods[name] = fn;
              return provider;
            }
            function addPreset(name, definition) {
              definition = definition || {};
              definition.methods = definition.methods || [];
              definition.options = definition.options || function() {
                return {};
              };
              if (/^cancel|hide|show$/.test(name)) {
                throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
              }
              if (definition.methods.indexOf('_options') > -1) {
                throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
              }
              providerConfig.presets[name] = {
                methods: definition.methods.concat(EXPOSED_METHODS),
                optionsFactory: definition.options,
                argOption: definition.argOption
              };
              return provider;
            }
            function addPresetMethod(presetName, methodName, method) {
              providerConfig.presets[presetName][methodName] = method;
            }
            function factory($$interimElement, $injector) {
              var defaultMethods;
              var defaultOptions;
              var interimElementService = $$interimElement();
              var publicService = {
                hide: interimElementService.hide,
                cancel: interimElementService.cancel,
                show: showInterimElement,
                destroy: destroyInterimElement
              };
              defaultMethods = providerConfig.methods || [];
              defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
              angular.forEach(customMethods, function(fn, name) {
                publicService[name] = fn;
              });
              angular.forEach(providerConfig.presets, function(definition, name) {
                var presetDefaults = invokeFactory(definition.optionsFactory, {});
                var presetMethods = (definition.methods || []).concat(defaultMethods);
                angular.extend(presetDefaults, {$type: name});
                function Preset(opts) {
                  this._options = angular.extend({}, presetDefaults, opts);
                }
                angular.forEach(presetMethods, function(name) {
                  Preset.prototype[name] = function(value) {
                    this._options[name] = value;
                    return this;
                  };
                });
                if (definition.argOption) {
                  var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);
                  publicService[methodName] = function(arg) {
                    var config = publicService[name](arg);
                    return publicService.show(config);
                  };
                }
                publicService[name] = function(arg) {
                  if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                    return (new Preset())[definition.argOption](arg);
                  } else {
                    return new Preset(arg);
                  }
                };
              });
              return publicService;
              function showInterimElement(opts) {
                opts = opts || {};
                if (opts._options)
                  opts = opts._options;
                return interimElementService.show(angular.extend({}, defaultOptions, opts));
              }
              function destroyInterimElement(opts) {
                return interimElementService.destroy(opts);
              }
              function invokeFactory(factory, defaultVal) {
                var locals = {};
                locals[interimFactoryName] = publicService;
                return $injector.invoke(factory || function() {
                  return defaultVal;
                }, {}, locals);
              }
            }
          }
          function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
            return function createInterimElementService() {
              var SHOW_CANCELLED = false;
              var service,
                  stack = [];
              return service = {
                show: show,
                hide: hide,
                cancel: cancel,
                destroy: destroy,
                $injector_: $injector
              };
              function show(options) {
                options = options || {};
                var interimElement = new InterimElement(options || {});
                var hideExisting = !options.skipHide && stack.length ? service.hide() : $q.when(true);
                hideExisting.finally(function() {
                  stack.push(interimElement);
                  interimElement.show().catch(function(reason) {
                    return reason;
                  });
                });
                return interimElement.deferred.promise;
              }
              function hide(reason, options) {
                if (!stack.length)
                  return $q.when(reason);
                options = options || {};
                if (options.closeAll) {
                  var promise = $q.all(stack.reverse().map(closeElement));
                  stack = [];
                  return promise;
                } else if (options.closeTo !== undefined) {
                  return $q.all(stack.splice(options.closeTo).map(closeElement));
                } else {
                  var interim = stack.pop();
                  return closeElement(interim);
                }
                function closeElement(interim) {
                  interim.remove(reason, false, options || {}).catch(function(reason) {
                    return reason;
                  });
                  return interim.deferred.promise;
                }
              }
              function cancel(reason, options) {
                var interim = stack.shift();
                if (!interim)
                  return $q.when(reason);
                interim.remove(reason, true, options || {}).catch(function(reason) {
                  return reason;
                });
                return interim.deferred.promise;
              }
              function destroy(target) {
                var interim = !target ? stack.shift() : null;
                var cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                if (cntr) {
                  var filtered = stack.filter(function(entry) {
                    var currNode = entry.options.element[0];
                    return (currNode === cntr);
                  });
                  if (filtered.length > 0) {
                    interim = filtered[0];
                    stack.splice(stack.indexOf(interim), 1);
                  }
                }
                return interim ? interim.remove(SHOW_CANCELLED, false, {'$destroy': true}) : $q.when(SHOW_CANCELLED);
              }
              function InterimElement(options) {
                var self,
                    element,
                    showAction = $q.when(true);
                options = configureScopeAndTransitions(options);
                return self = {
                  options: options,
                  deferred: $q.defer(),
                  show: createAndTransitionIn,
                  remove: transitionOutAndRemove
                };
                function createAndTransitionIn() {
                  return $q(function(resolve, reject) {
                    compileElement(options).then(function(compiledData) {
                      element = linkElement(compiledData, options);
                      showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                    }, rejectAll);
                    function rejectAll(fault) {
                      self.deferred.reject(fault);
                      reject(fault);
                    }
                  });
                }
                function transitionOutAndRemove(response, isCancelled, opts) {
                  if (!element)
                    return $q.when(false);
                  options = angular.extend(options || {}, opts || {});
                  options.cancelAutoHide && options.cancelAutoHide();
                  options.element.triggerHandler('$mdInterimElementRemove');
                  if (options.$destroy === true) {
                    return hideElement(options.element, options).then(function() {
                      (isCancelled && rejectAll(response)) || resolveAll(response);
                    });
                  } else {
                    $q.when(showAction).finally(function() {
                      hideElement(options.element, options).then(function() {
                        (isCancelled && rejectAll(response)) || resolveAll(response);
                      }, rejectAll);
                    });
                    return self.deferred.promise;
                  }
                  function resolveAll(response) {
                    self.deferred.resolve(response);
                  }
                  function rejectAll(fault) {
                    self.deferred.reject(fault);
                  }
                }
                function configureScopeAndTransitions(options) {
                  options = options || {};
                  if (options.template) {
                    options.template = $mdUtil.processTemplate(options.template);
                  }
                  return angular.extend({
                    preserveScope: false,
                    cancelAutoHide: angular.noop,
                    scope: options.scope || $rootScope.$new(options.isolateScope),
                    onShow: function transitionIn(scope, element, options) {
                      return $animate.enter(element, options.parent);
                    },
                    onRemove: function transitionOut(scope, element) {
                      return element && $animate.leave(element) || $q.when();
                    }
                  }, options);
                }
                function compileElement(options) {
                  var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;
                  return compiled || $q(function(resolve) {
                    resolve({
                      locals: {},
                      link: function() {
                        return options.element;
                      }
                    });
                  });
                }
                function linkElement(compileData, options) {
                  angular.extend(compileData.locals, options);
                  var element = compileData.link(options.scope);
                  options.element = element;
                  options.parent = findParent(element, options);
                  if (options.themable)
                    $mdTheming(element);
                  return element;
                }
                function findParent(element, options) {
                  var parent = options.parent;
                  if (angular.isFunction(parent)) {
                    parent = parent(options.scope, element, options);
                  } else if (angular.isString(parent)) {
                    parent = angular.element($document[0].querySelector(parent));
                  } else {
                    parent = angular.element(parent);
                  }
                  if (!(parent || {}).length) {
                    var el;
                    if ($rootElement[0] && $rootElement[0].querySelector) {
                      el = $rootElement[0].querySelector(':not(svg) > body');
                    }
                    if (!el)
                      el = $rootElement[0];
                    if (el.nodeName == '#comment') {
                      el = $document[0].body;
                    }
                    return angular.element(el);
                  }
                  return parent;
                }
                function startAutoHide() {
                  var autoHideTimer,
                      cancelAutoHide = angular.noop;
                  if (options.hideDelay) {
                    autoHideTimer = $timeout(service.hide, options.hideDelay);
                    cancelAutoHide = function() {
                      $timeout.cancel(autoHideTimer);
                    };
                  }
                  options.cancelAutoHide = function() {
                    cancelAutoHide();
                    options.cancelAutoHide = undefined;
                  };
                }
                function showElement(element, options, controller) {
                  var notifyShowing = options.onShowing || angular.noop;
                  var notifyComplete = options.onComplete || angular.noop;
                  notifyShowing(options.scope, element, options, controller);
                  return $q(function(resolve, reject) {
                    try {
                      $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                        notifyComplete(options.scope, element, options);
                        startAutoHide();
                        resolve(element);
                      }, reject);
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
                function hideElement(element, options) {
                  var announceRemoving = options.onRemoving || angular.noop;
                  return $$q(function(resolve, reject) {
                    try {
                      var action = $$q.when(options.onRemove(options.scope, element, options) || true);
                      announceRemoving(element, action);
                      if (options.$destroy == true) {
                        resolve(element);
                      } else {
                        action.then(function() {
                          if (!options.preserveScope && options.scope) {
                            options.scope.$destroy();
                          }
                          resolve(element);
                        }, reject);
                      }
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
              }
            };
          }
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var $mdUtil,
              $interpolate,
              $log;
          var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
          var WHITESPACE = /\s+/g;
          var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow'];
          var LAYOUT_OPTIONS = ['row', 'column'];
          var ALIGNMENT_MAIN_AXIS = ["", "start", "center", "end", "stretch", "space-around", "space-between"];
          var ALIGNMENT_CROSS_AXIS = ["", "start", "center", "end", "stretch"];
          var config = {
            enabled: true,
            breakpoints: []
          };
          registerLayoutAPI(angular.module('material.core.layout', ['ng']));
          function registerLayoutAPI(module) {
            var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var BREAKPOINTS = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"];
            var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
            var API_NO_VALUES = ["show", "hide", "layout-padding", "layout-margin"];
            angular.forEach(BREAKPOINTS, function(mqb) {
              angular.forEach(API_WITH_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
              });
              angular.forEach(API_NO_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
              });
            });
            module.directive('mdLayoutCss', disableLayoutDirective).directive('ngCloak', buildCloakInterceptor('ng-cloak')).directive('layoutWrap', attributeWithoutValue('layout-wrap')).directive('layoutNowrap', attributeWithoutValue('layout-nowrap')).directive('layoutNoWrap', attributeWithoutValue('layout-no-wrap')).directive('layoutFill', attributeWithoutValue('layout-fill')).directive('layoutLtMd', warnAttrNotSupported('layout-lt-md', true)).directive('layoutLtLg', warnAttrNotSupported('layout-lt-lg', true)).directive('flexLtMd', warnAttrNotSupported('flex-lt-md', true)).directive('flexLtLg', warnAttrNotSupported('flex-lt-lg', true)).directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md')).directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg')).directive('flexOrderLtMd', warnAttrNotSupported('flex-order-lt-md')).directive('flexOrderLtLg', warnAttrNotSupported('flex-order-lt-lg')).directive('offsetLtMd', warnAttrNotSupported('flex-offset-lt-md')).directive('offsetLtLg', warnAttrNotSupported('flex-offset-lt-lg')).directive('hideLtMd', warnAttrNotSupported('hide-lt-md')).directive('hideLtLg', warnAttrNotSupported('hide-lt-lg')).directive('showLtMd', warnAttrNotSupported('show-lt-md')).directive('showLtLg', warnAttrNotSupported('show-lt-lg'));
            function directiveNormalize(name) {
              return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
              });
            }
          }
          function disableLayoutDirective() {
            return {
              restrict: 'A',
              priority: '900',
              compile: function(element, attr) {
                config.enabled = false;
                return angular.noop;
              }
            };
          }
          function buildCloakInterceptor(className) {
            return ['$timeout', function($timeout) {
              return {
                restrict: 'A',
                priority: -10,
                compile: function(element) {
                  if (!config.enabled)
                    return angular.noop;
                  element.addClass(className);
                  return function(scope, element) {
                    $timeout(function() {
                      element.removeClass(className);
                    }, 10, false);
                  };
                }
              };
            }];
          }
          function attributeWithObserve(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeUsage(className, attr, element, $log);
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    linkFn = translateWithValueToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateWithValueToCssClass(scope, element, attrs) {
              var updateFn = updateClassWithValue(element, className, attrs);
              var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
              updateFn(getNormalizedAttrValue(className, attrs, ""));
              scope.$on("$destroy", function() {
                unwatch();
              });
            }
          }
          function attributeWithoutValue(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    translateToCssClass(null, element);
                    linkFn = translateToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateToCssClass(scope, element) {
              element.addClass(className);
            }
          }
          function updateClassWithValue(element, className) {
            var lastClass;
            return function updateClassFn(newValue) {
              var value = validateAttributeValue(className, newValue || "");
              if (angular.isDefined(value)) {
                if (lastClass)
                  element.removeClass(lastClass);
                lastClass = !value ? className : className + "-" + value.replace(WHITESPACE, "-");
                element.addClass(lastClass);
              }
            };
          }
          function warnAttrNotSupported(className) {
            var parts = className.split("-");
            return ["$log", function($log) {
              $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
              return angular.noop;
            }];
          }
          function validateAttributeUsage(className, attr, element, $log) {
            var message,
                usage,
                url;
            var nodeName = element[0].nodeName.toLowerCase();
            switch (className.replace(SUFFIXES, "")) {
              case "flex":
                if ((nodeName == "md-button") || (nodeName == "fieldset")) {
                  usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                  url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                  message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                  $log.warn($mdUtil.supplant(message, [usage, url]));
                }
            }
          }
          function validateAttributeValue(className, value, updateFn) {
            var origValue = value;
            if (!needsInterpolation(value)) {
              switch (className.replace(SUFFIXES, "")) {
                case 'layout':
                  if (!findIn(value, LAYOUT_OPTIONS)) {
                    value = LAYOUT_OPTIONS[0];
                  }
                  break;
                case 'flex':
                  if (!findIn(value, FLEX_OPTIONS)) {
                    if (isNaN(value)) {
                      value = '';
                    }
                  }
                  break;
                case 'flex-offset':
                case 'flex-order':
                  if (!value || isNaN(+value)) {
                    value = '0';
                  }
                  break;
                case 'layout-align':
                  var axis = extractAlignAxis(value);
                  value = $mdUtil.supplant("{main}-{cross}", axis);
                  break;
                case 'layout-padding':
                case 'layout-margin':
                case 'layout-fill':
                case 'layout-wrap':
                case 'layout-nowrap':
                case 'layout-nowrap':
                  value = '';
                  break;
              }
              if (value != origValue) {
                (updateFn || angular.noop)(value);
              }
            }
            return value;
          }
          function buildUpdateFn(element, className, attrs) {
            return function updateAttrValue(fallback) {
              if (!needsInterpolation(fallback)) {
                attrs[attrs.$normalize(className)] = fallback;
              }
            };
          }
          function needsInterpolation(value) {
            return (value || "").indexOf($interpolate.startSymbol()) > -1;
          }
          function getNormalizedAttrValue(className, attrs, defaultVal) {
            var normalizedAttr = attrs.$normalize(className);
            return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
          }
          function findIn(item, list, replaceWith) {
            item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
            var found = false;
            if (item) {
              list.forEach(function(it) {
                it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                found = found || (it === item);
              });
            }
            return found;
          }
          function extractAlignAxis(attrValue) {
            var axis = {
              main: "start",
              cross: "stretch"
            },
                values;
            attrValue = (attrValue || "");
            if (attrValue.indexOf("-") == 0 || attrValue.indexOf(" ") == 0) {
              attrValue = "none" + attrValue;
            }
            values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
            if (values.length && (values[0] === "space")) {
              values = [values[0] + "-" + values[1], values[2]];
            }
            if (values.length > 0)
              axis.main = values[0] || axis.main;
            if (values.length > 1)
              axis.cross = values[1] || axis.cross;
            if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0)
              axis.main = "start";
            if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0)
              axis.cross = "stretch";
            return axis;
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdComponentRegistry', ComponentRegistry);
        function ComponentRegistry($log, $q) {
          var self;
          var instances = [];
          var pendings = {};
          return self = {
            notFoundError: function(handle) {
              $log.error('No instance found for handle', handle);
            },
            getInstances: function() {
              return instances;
            },
            get: function(handle) {
              if (!isValidID(handle))
                return null;
              var i,
                  j,
                  instance;
              for (i = 0, j = instances.length; i < j; i++) {
                instance = instances[i];
                if (instance.$$mdHandle === handle) {
                  return instance;
                }
              }
              return null;
            },
            register: function(instance, handle) {
              if (!handle)
                return angular.noop;
              instance.$$mdHandle = handle;
              instances.push(instance);
              resolveWhen();
              return deregister;
              function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              }
              function resolveWhen() {
                var dfd = pendings[handle];
                if (dfd) {
                  dfd.resolve(instance);
                  delete pendings[handle];
                }
              }
            },
            when: function(handle) {
              if (isValidID(handle)) {
                var deferred = $q.defer();
                var instance = self.get(handle);
                if (instance) {
                  deferred.resolve(instance);
                } else {
                  pendings[handle] = deferred;
                }
                return deferred.promise;
              }
              return $q.reject("Invalid `md-component-id` value.");
            }
          };
          function isValidID(handle) {
            return handle && (handle !== "");
          }
        }
        ComponentRegistry.$inject = ["$log", "$q"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdButtonInkRipple', MdButtonInkRipple);
          function MdButtonInkRipple($mdInkRipple) {
            return {attach: function attachRipple(scope, element, options) {
                options = angular.extend(optionsForElement(element), options);
                return $mdInkRipple.attach(scope, element, options);
              }};
            function optionsForElement(element) {
              if (element.hasClass('md-icon-button')) {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  fitRipple: true,
                  center: true
                };
              } else {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  dimBackground: true
                };
              }
            }
            ;
          }
          MdButtonInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);
          function MdCheckboxInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: true,
                dimBackground: false,
                fitRipple: true
              }, options));
            }
            ;
          }
          MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdListInkRipple', MdListInkRipple);
          function MdListInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdListInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdInkRipple', InkRippleService).directive('mdInkRipple', InkRippleDirective).directive('mdNoInk', attrNoDirective).directive('mdNoBar', attrNoDirective).directive('mdNoStretch', attrNoDirective);
        var DURATION = 450;
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
          return {
            controller: angular.noop,
            link: function(scope, element, attr) {
              attr.hasOwnProperty('mdInkRippleCheckbox') ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
            }
          };
        }
        InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
        function InkRippleService($injector) {
          return {attach: attach};
          function attach(scope, element, options) {
            if (element.controller('mdNoInk'))
              return angular.noop;
            return $injector.instantiate(InkRippleCtrl, {
              $scope: scope,
              $element: element,
              rippleOptions: options
            });
          }
        }
        InkRippleService.$inject = ["$injector"];
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
          this.$window = $window;
          this.$timeout = $timeout;
          this.$mdUtil = $mdUtil;
          this.$scope = $scope;
          this.$element = $element;
          this.options = rippleOptions;
          this.mousedown = false;
          this.ripples = [];
          this.timeout = null;
          this.lastRipple = null;
          $mdUtil.valueOnUse(this, 'container', this.createContainer);
          this.$element.addClass('md-ink-ripple');
          ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple);
          ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color);
          this.bindEvents();
        }
        InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil"];
        function autoCleanup(self, cleanupFn) {
          if (self.mousedown || self.lastRipple) {
            self.mousedown = false;
            self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);
          }
        }
        InkRippleCtrl.prototype.color = function(value) {
          var self = this;
          if (angular.isDefined(value)) {
            self._color = self._parseColor(value);
          }
          return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
          function getElementColor() {
            var items = self.options && self.options.colorElement ? self.options.colorElement : [];
            var elem = items.length ? items[0] : self.$element[0];
            return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';
          }
        };
        InkRippleCtrl.prototype.calculateColor = function() {
          return this.color();
        };
        InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier) {
          multiplier = multiplier || 1;
          if (!color)
            return;
          if (color.indexOf('rgba') === 0)
            return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')');
          if (color.indexOf('rgb') === 0)
            return rgbToRGBA(color);
          if (color.indexOf('#') === 0)
            return hexToRGBA(color);
          function hexToRGBA(color) {
            var hex = color[0] === '#' ? color.substr(1) : color,
                dig = hex.length / 3,
                red = hex.substr(0, dig),
                green = hex.substr(dig, dig),
                blue = hex.substr(dig * 2);
            if (dig === 1) {
              red += red;
              green += green;
              blue += blue;
            }
            return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';
          }
          function rgbToRGBA(color) {
            return color.replace(')', ', 0.1)').replace('(', 'a(');
          }
        };
        InkRippleCtrl.prototype.bindEvents = function() {
          this.$element.on('mousedown', angular.bind(this, this.handleMousedown));
          this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup));
          this.$element.on('mouseleave', angular.bind(this, this.handleMouseup));
          this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));
        };
        InkRippleCtrl.prototype.handleMousedown = function(event) {
          if (this.mousedown)
            return;
          if (event.hasOwnProperty('originalEvent'))
            event = event.originalEvent;
          this.mousedown = true;
          if (this.options.center) {
            this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);
          } else {
            if (event.srcElement !== this.$element[0]) {
              var layerRect = this.$element[0].getBoundingClientRect();
              var layerX = event.clientX - layerRect.left;
              var layerY = event.clientY - layerRect.top;
              this.createRipple(layerX, layerY);
            } else {
              this.createRipple(event.offsetX, event.offsetY);
            }
          }
        };
        InkRippleCtrl.prototype.handleMouseup = function() {
          autoCleanup(this, this.clearRipples);
        };
        InkRippleCtrl.prototype.handleTouchmove = function() {
          autoCleanup(this, this.deleteRipples);
        };
        InkRippleCtrl.prototype.deleteRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.ripples[i].remove();
          }
        };
        InkRippleCtrl.prototype.clearRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.fadeInComplete(this.ripples[i]);
          }
        };
        InkRippleCtrl.prototype.createContainer = function() {
          var container = angular.element('<div class="md-ripple-container"></div>');
          this.$element.append(container);
          return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
          if (this.timeout) {
            this.$timeout.cancel(this.timeout);
            this.timeout = null;
          }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
          var element = this.$element[0];
          do {
            if (!element.tagName || element.tagName === 'BODY')
              break;
            if (element && angular.isFunction(element.hasAttribute)) {
              if (element.hasAttribute('disabled'))
                return false;
              if (this.inkRipple() === 'false' || this.inkRipple() === '0')
                return false;
            }
          } while (element = element.parentNode);
          return true;
        };
        InkRippleCtrl.prototype.inkRipple = function() {
          return this.$element.attr('md-ink-ripple');
        };
        InkRippleCtrl.prototype.createRipple = function(left, top) {
          if (!this.isRippleAllowed())
            return;
          var ctrl = this;
          var ripple = angular.element('<div class="md-ripple"></div>');
          var width = this.$element.prop('clientWidth');
          var height = this.$element.prop('clientHeight');
          var x = Math.max(Math.abs(width - left), left) * 2;
          var y = Math.max(Math.abs(height - top), top) * 2;
          var size = getSize(this.options.fitRipple, x, y);
          var color = this.calculateColor();
          ripple.css({
            left: left + 'px',
            top: top + 'px',
            background: 'black',
            width: size + 'px',
            height: size + 'px',
            backgroundColor: rgbaToRGB(color),
            borderColor: rgbaToRGB(color)
          });
          this.lastRipple = ripple;
          this.clearTimeout();
          this.timeout = this.$timeout(function() {
            ctrl.clearTimeout();
            if (!ctrl.mousedown)
              ctrl.fadeInComplete(ripple);
          }, DURATION * 0.35, false);
          if (this.options.dimBackground)
            this.container.css({backgroundColor: color});
          this.container.append(ripple);
          this.ripples.push(ripple);
          ripple.addClass('md-ripple-placed');
          this.$mdUtil.nextTick(function() {
            ripple.addClass('md-ripple-scaled md-ripple-active');
            ctrl.$timeout(function() {
              ctrl.clearRipples();
            }, DURATION, false);
          }, false);
          function rgbaToRGB(color) {
            return color ? color.replace('rgba', 'rgb').replace(/,[^\),]+\)/, ')') : 'rgb(0,0,0)';
          }
          function getSize(fit, x, y) {
            return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
          }
        };
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
          if (this.lastRipple === ripple) {
            if (!this.timeout && !this.mousedown) {
              this.removeRipple(ripple);
            }
          } else {
            this.removeRipple(ripple);
          }
        };
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
          var ctrl = this;
          var index = this.ripples.indexOf(ripple);
          if (index < 0)
            return;
          this.ripples.splice(this.ripples.indexOf(ripple), 1);
          ripple.removeClass('md-ripple-active');
          if (this.ripples.length === 0)
            this.container.css({backgroundColor: ''});
          this.$timeout(function() {
            ctrl.fadeOutComplete(ripple);
          }, DURATION, false);
        };
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
          ripple.remove();
          this.lastRipple = null;
        };
        function attrNoDirective() {
          return {controller: angular.noop};
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdTabInkRipple', MdTabInkRipple);
          function MdTabInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdTabInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming.palette', []).constant('$mdColorPalette', {
          'red': {
            '50': '#ffebee',
            '100': '#ffcdd2',
            '200': '#ef9a9a',
            '300': '#e57373',
            '400': '#ef5350',
            '500': '#f44336',
            '600': '#e53935',
            '700': '#d32f2f',
            '800': '#c62828',
            '900': '#b71c1c',
            'A100': '#ff8a80',
            'A200': '#ff5252',
            'A400': '#ff1744',
            'A700': '#d50000',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 A100',
            'contrastStrongLightColors': '400 500 600 700 A200 A400 A700'
          },
          'pink': {
            '50': '#fce4ec',
            '100': '#f8bbd0',
            '200': '#f48fb1',
            '300': '#f06292',
            '400': '#ec407a',
            '500': '#e91e63',
            '600': '#d81b60',
            '700': '#c2185b',
            '800': '#ad1457',
            '900': '#880e4f',
            'A100': '#ff80ab',
            'A200': '#ff4081',
            'A400': '#f50057',
            'A700': '#c51162',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '500 600 A200 A400 A700'
          },
          'purple': {
            '50': '#f3e5f5',
            '100': '#e1bee7',
            '200': '#ce93d8',
            '300': '#ba68c8',
            '400': '#ab47bc',
            '500': '#9c27b0',
            '600': '#8e24aa',
            '700': '#7b1fa2',
            '800': '#6a1b9a',
            '900': '#4a148c',
            'A100': '#ea80fc',
            'A200': '#e040fb',
            'A400': '#d500f9',
            'A700': '#aa00ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400 A700'
          },
          'deep-purple': {
            '50': '#ede7f6',
            '100': '#d1c4e9',
            '200': '#b39ddb',
            '300': '#9575cd',
            '400': '#7e57c2',
            '500': '#673ab7',
            '600': '#5e35b1',
            '700': '#512da8',
            '800': '#4527a0',
            '900': '#311b92',
            'A100': '#b388ff',
            'A200': '#7c4dff',
            'A400': '#651fff',
            'A700': '#6200ea',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200'
          },
          'indigo': {
            '50': '#e8eaf6',
            '100': '#c5cae9',
            '200': '#9fa8da',
            '300': '#7986cb',
            '400': '#5c6bc0',
            '500': '#3f51b5',
            '600': '#3949ab',
            '700': '#303f9f',
            '800': '#283593',
            '900': '#1a237e',
            'A100': '#8c9eff',
            'A200': '#536dfe',
            'A400': '#3d5afe',
            'A700': '#304ffe',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400'
          },
          'blue': {
            '50': '#e3f2fd',
            '100': '#bbdefb',
            '200': '#90caf9',
            '300': '#64b5f6',
            '400': '#42a5f5',
            '500': '#2196f3',
            '600': '#1e88e5',
            '700': '#1976d2',
            '800': '#1565c0',
            '900': '#0d47a1',
            'A100': '#82b1ff',
            'A200': '#448aff',
            'A400': '#2979ff',
            'A700': '#2962ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100',
            'contrastStrongLightColors': '500 600 700 A200 A400 A700'
          },
          'light-blue': {
            '50': '#e1f5fe',
            '100': '#b3e5fc',
            '200': '#81d4fa',
            '300': '#4fc3f7',
            '400': '#29b6f6',
            '500': '#03a9f4',
            '600': '#039be5',
            '700': '#0288d1',
            '800': '#0277bd',
            '900': '#01579b',
            'A100': '#80d8ff',
            'A200': '#40c4ff',
            'A400': '#00b0ff',
            'A700': '#0091ea',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900 A700',
            'contrastStrongLightColors': '600 700 800 A700'
          },
          'cyan': {
            '50': '#e0f7fa',
            '100': '#b2ebf2',
            '200': '#80deea',
            '300': '#4dd0e1',
            '400': '#26c6da',
            '500': '#00bcd4',
            '600': '#00acc1',
            '700': '#0097a7',
            '800': '#00838f',
            '900': '#006064',
            'A100': '#84ffff',
            'A200': '#18ffff',
            'A400': '#00e5ff',
            'A700': '#00b8d4',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'teal': {
            '50': '#e0f2f1',
            '100': '#b2dfdb',
            '200': '#80cbc4',
            '300': '#4db6ac',
            '400': '#26a69a',
            '500': '#009688',
            '600': '#00897b',
            '700': '#00796b',
            '800': '#00695c',
            '900': '#004d40',
            'A100': '#a7ffeb',
            'A200': '#64ffda',
            'A400': '#1de9b6',
            'A700': '#00bfa5',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '500 600 700 800 900',
            'contrastStrongLightColors': '500 600 700'
          },
          'green': {
            '50': '#e8f5e9',
            '100': '#c8e6c9',
            '200': '#a5d6a7',
            '300': '#81c784',
            '400': '#66bb6a',
            '500': '#4caf50',
            '600': '#43a047',
            '700': '#388e3c',
            '800': '#2e7d32',
            '900': '#1b5e20',
            'A100': '#b9f6ca',
            'A200': '#69f0ae',
            'A400': '#00e676',
            'A700': '#00c853',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900',
            'contrastStrongLightColors': '600 700'
          },
          'light-green': {
            '50': '#f1f8e9',
            '100': '#dcedc8',
            '200': '#c5e1a5',
            '300': '#aed581',
            '400': '#9ccc65',
            '500': '#8bc34a',
            '600': '#7cb342',
            '700': '#689f38',
            '800': '#558b2f',
            '900': '#33691e',
            'A100': '#ccff90',
            'A200': '#b2ff59',
            'A400': '#76ff03',
            'A700': '#64dd17',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'lime': {
            '50': '#f9fbe7',
            '100': '#f0f4c3',
            '200': '#e6ee9c',
            '300': '#dce775',
            '400': '#d4e157',
            '500': '#cddc39',
            '600': '#c0ca33',
            '700': '#afb42b',
            '800': '#9e9d24',
            '900': '#827717',
            'A100': '#f4ff81',
            'A200': '#eeff41',
            'A400': '#c6ff00',
            'A700': '#aeea00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '900',
            'contrastStrongLightColors': '900'
          },
          'yellow': {
            '50': '#fffde7',
            '100': '#fff9c4',
            '200': '#fff59d',
            '300': '#fff176',
            '400': '#ffee58',
            '500': '#ffeb3b',
            '600': '#fdd835',
            '700': '#fbc02d',
            '800': '#f9a825',
            '900': '#f57f17',
            'A100': '#ffff8d',
            'A200': '#ffff00',
            'A400': '#ffea00',
            'A700': '#ffd600',
            'contrastDefaultColor': 'dark'
          },
          'amber': {
            '50': '#fff8e1',
            '100': '#ffecb3',
            '200': '#ffe082',
            '300': '#ffd54f',
            '400': '#ffca28',
            '500': '#ffc107',
            '600': '#ffb300',
            '700': '#ffa000',
            '800': '#ff8f00',
            '900': '#ff6f00',
            'A100': '#ffe57f',
            'A200': '#ffd740',
            'A400': '#ffc400',
            'A700': '#ffab00',
            'contrastDefaultColor': 'dark'
          },
          'orange': {
            '50': '#fff3e0',
            '100': '#ffe0b2',
            '200': '#ffcc80',
            '300': '#ffb74d',
            '400': '#ffa726',
            '500': '#ff9800',
            '600': '#fb8c00',
            '700': '#f57c00',
            '800': '#ef6c00',
            '900': '#e65100',
            'A100': '#ffd180',
            'A200': '#ffab40',
            'A400': '#ff9100',
            'A700': '#ff6d00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '800 900',
            'contrastStrongLightColors': '800 900'
          },
          'deep-orange': {
            '50': '#fbe9e7',
            '100': '#ffccbc',
            '200': '#ffab91',
            '300': '#ff8a65',
            '400': '#ff7043',
            '500': '#ff5722',
            '600': '#f4511e',
            '700': '#e64a19',
            '800': '#d84315',
            '900': '#bf360c',
            'A100': '#ff9e80',
            'A200': '#ff6e40',
            'A400': '#ff3d00',
            'A700': '#dd2c00',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100 A200',
            'contrastStrongLightColors': '500 600 700 800 900 A400 A700'
          },
          'brown': {
            '50': '#efebe9',
            '100': '#d7ccc8',
            '200': '#bcaaa4',
            '300': '#a1887f',
            '400': '#8d6e63',
            '500': '#795548',
            '600': '#6d4c41',
            '700': '#5d4037',
            '800': '#4e342e',
            '900': '#3e2723',
            'A100': '#d7ccc8',
            'A200': '#bcaaa4',
            'A400': '#8d6e63',
            'A700': '#5d4037',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200',
            'contrastStrongLightColors': '300 400'
          },
          'grey': {
            '50': '#fafafa',
            '100': '#f5f5f5',
            '200': '#eeeeee',
            '300': '#e0e0e0',
            '400': '#bdbdbd',
            '500': '#9e9e9e',
            '600': '#757575',
            '700': '#616161',
            '800': '#424242',
            '900': '#212121',
            '1000': '#000000',
            'A100': '#ffffff',
            'A200': '#eeeeee',
            'A400': '#bdbdbd',
            'A700': '#616161',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900'
          },
          'blue-grey': {
            '50': '#eceff1',
            '100': '#cfd8dc',
            '200': '#b0bec5',
            '300': '#90a4ae',
            '400': '#78909c',
            '500': '#607d8b',
            '600': '#546e7a',
            '700': '#455a64',
            '800': '#37474f',
            '900': '#263238',
            'A100': '#cfd8dc',
            'A200': '#b0bec5',
            'A400': '#78909c',
            'A700': '#455a64',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300',
            'contrastStrongLightColors': '400 500'
          }
        });
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming', ['material.core.theming.palette']).directive('mdTheme', ThemingDirective).directive('mdThemable', ThemableDirective).provider('$mdTheming', ThemingProvider).run(generateAllThemes);
        var GENERATED = {};
        var PALETTES;
        var THEMES;
        var DARK_FOREGROUND = {
          name: 'dark',
          '1': 'rgba(0,0,0,0.87)',
          '2': 'rgba(0,0,0,0.54)',
          '3': 'rgba(0,0,0,0.26)',
          '4': 'rgba(0,0,0,0.12)'
        };
        var LIGHT_FOREGROUND = {
          name: 'light',
          '1': 'rgba(255,255,255,1.0)',
          '2': 'rgba(255,255,255,0.7)',
          '3': 'rgba(255,255,255,0.3)',
          '4': 'rgba(255,255,255,0.12)'
        };
        var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';
        var LIGHT_SHADOW = '';
        var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');
        var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)');
        var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');
        var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];
        var DEFAULT_COLOR_TYPE = 'primary';
        var LIGHT_DEFAULT_HUES = {
          'accent': {
            'default': 'A200',
            'hue-1': 'A100',
            'hue-2': 'A400',
            'hue-3': 'A700'
          },
          'background': {
            'default': 'A100',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': '900'
          }
        };
        var DARK_DEFAULT_HUES = {'background': {
            'default': '800',
            'hue-1': '600',
            'hue-2': '300',
            'hue-3': '900'
          }};
        THEME_COLOR_TYPES.forEach(function(colorType) {
          var defaultDefaultHues = {
            'default': '500',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': 'A100'
          };
          if (!LIGHT_DEFAULT_HUES[colorType])
            LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
          if (!DARK_DEFAULT_HUES[colorType])
            DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
        });
        var VALID_HUE_VALUES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'A100', 'A200', 'A400', 'A700'];
        var generateOnDemand = false;
        var nonce = null;
        function ThemingProvider($mdColorPalette) {
          PALETTES = {};
          THEMES = {};
          var themingProvider;
          var defaultTheme = 'default';
          var alwaysWatchTheme = false;
          angular.extend(PALETTES, $mdColorPalette);
          ThemingService.$inject = ["$rootScope", "$log"];
          return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            setNonce: function(nonceValue) {
              nonce = nonceValue;
            },
            setDefaultTheme: function(theme) {
              defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
              alwaysWatchTheme = alwaysWatch;
            },
            generateThemesOnDemand: function(onDemand) {
              generateOnDemand = onDemand;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
          };
          function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
          }
          function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
          }
          function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
              return !map[field];
            });
            if (missingColors.length) {
              throw new Error("Missing colors %1 in palette %2!".replace('%1', missingColors.join(', ')).replace('%2', name));
            }
            return map;
          }
          function registerTheme(name, inheritFrom) {
            if (THEMES[name])
              return THEMES[name];
            inheritFrom = inheritFrom || 'default';
            var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
              angular.forEach(parentTheme.colors, function(color, colorType) {
                theme.colors[colorType] = {
                  name: color.name,
                  hues: angular.extend({}, color.hues)
                };
              });
            }
            THEMES[name] = theme;
            return theme;
          }
          function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
              isDark = arguments.length === 0 ? true : !!isDark;
              if (isDark === self.isDark)
                return;
              self.isDark = isDark;
              self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
              self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
              var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
              var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
              angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                var color = self.colors[colorType];
                var oldDefaults = oldDefaultHues[colorType];
                if (color) {
                  for (var hueName in color.hues) {
                    if (color.hues[hueName] === oldDefaults[hueName]) {
                      color.hues[hueName] = newDefaults[hueName];
                    }
                  }
                }
              });
              return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
              self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {
                var color = self.colors[colorType] = {
                  name: paletteName,
                  hues: angular.extend({}, defaultHues, hues)
                };
                Object.keys(color.hues).forEach(function(name) {
                  if (!defaultHues[name]) {
                    throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace('%1', name).replace('%2', self.name).replace('%3', paletteName).replace('%4', Object.keys(defaultHues).join(', ')));
                  }
                });
                Object.keys(color.hues).map(function(key) {
                  return color.hues[key];
                }).forEach(function(hueValue) {
                  if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                    throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace('%1', hueValue).replace('%2', self.name).replace('%3', colorType).replace('%4', paletteName).replace('%5', VALID_HUE_VALUES.join(', ')));
                  }
                });
                return self;
              };
              self[colorType + 'Color'] = function() {
                var args = Array.prototype.slice.call(arguments);
                console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' + 'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');
                return self[colorType + 'Palette'].apply(self, args);
              };
            });
          }
          function ThemingService($rootScope, $log) {
            applyTheme.inherit = function(el, parent) {
              var ctrl = parent.controller('mdTheme');
              var attrThemeValue = el.attr('md-theme-watch');
              if ((alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {
                var deregisterWatch = $rootScope.$watch(function() {
                  return ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                }, changeTheme);
                el.on('$destroy', deregisterWatch);
              } else {
                var theme = ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                changeTheme(theme);
              }
              function changeTheme(theme) {
                if (!theme)
                  return;
                if (!registered(theme)) {
                  $log.warn('Attempted to use unregistered theme \'' + theme + '\'. ' + 'Register it with $mdThemingProvider.theme().');
                }
                var oldTheme = el.data('$mdThemeName');
                if (oldTheme)
                  el.removeClass('md-' + oldTheme + '-theme');
                el.addClass('md-' + theme + '-theme');
                el.data('$mdThemeName', theme);
                if (ctrl) {
                  el.data('$mdThemeController', ctrl);
                }
              }
            };
            applyTheme.THEMES = angular.extend({}, THEMES);
            applyTheme.defaultTheme = function() {
              return defaultTheme;
            };
            applyTheme.registered = registered;
            applyTheme.generateTheme = function(name) {
              generateTheme(name, nonce);
            };
            return applyTheme;
            function registered(themeName) {
              if (themeName === undefined || themeName === '')
                return true;
              return applyTheme.THEMES[themeName] !== undefined;
            }
            function applyTheme(scope, el) {
              if (el === undefined) {
                el = scope;
                scope = undefined;
              }
              if (scope === undefined) {
                scope = $rootScope;
              }
              applyTheme.inherit(el, el);
            }
          }
        }
        ThemingProvider.$inject = ["$mdColorPalette"];
        function ThemingDirective($mdTheming, $interpolate, $log) {
          return {
            priority: 100,
            link: {pre: function(scope, el, attrs) {
                var ctrl = {$setTheme: function(theme) {
                    if (!$mdTheming.registered(theme)) {
                      $log.warn('attempted to use unregistered theme \'' + theme + '\'');
                    }
                    ctrl.$mdTheme = theme;
                  }};
                el.data('$mdThemeController', ctrl);
                ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                attrs.$observe('mdTheme', ctrl.$setTheme);
              }}
          };
        }
        ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$log"];
        function ThemableDirective($mdTheming) {
          return $mdTheming;
        }
        ThemableDirective.$inject = ["$mdTheming"];
        function parseRules(theme, colorType, rules) {
          checkValidPalette(theme, colorType);
          rules = rules.replace(/THEME_NAME/g, theme.name);
          var generatedRules = [];
          var color = theme.colors[colorType];
          var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');
          var hueRegex = new RegExp('(\'|")?{{\\s*(' + colorType + ')-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|\')?', 'g');
          var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
          var palette = PALETTES[color.name];
          rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
            if (colorType === 'foreground') {
              if (hue == 'shadow') {
                return theme.foregroundShadow;
              } else {
                return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];
              }
            }
            if (hue.indexOf('hue') === 0) {
              hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || '')[contrast ? 'contrast' : 'value'], opacity);
          });
          angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
              return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);
            });
            if (hueName !== 'default') {
              newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);
            }
            if (theme.name == 'default') {
              var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
              newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                return match + ', ' + prefix + target + suffix;
              });
            }
            generatedRules.push(newRule);
          });
          return generatedRules;
        }
        var rulesByType = {};
        function generateAllThemes($injector) {
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';
          if (!firstChild)
            return;
          if (themeCss.length === 0)
            return;
          angular.forEach(PALETTES, sanitizePalette);
          var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
          }).map(function(rule) {
            return rule.trim() + '}';
          });
          var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');
          THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = '';
          });
          rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0,
                type; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf('.md-' + type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf(type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
          });
          if (generateOnDemand)
            return;
          angular.forEach(THEMES, function(theme) {
            if (!GENERATED[theme.name]) {
              generateTheme(theme.name, nonce);
            }
          });
          function sanitizePalette(palette) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var strongLightColors = palette.contrastStrongLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === 'string')
              lightColors = lightColors.split(' ');
            if (typeof strongLightColors === 'string')
              strongLightColors = strongLightColors.split(' ');
            if (typeof darkColors === 'string')
              darkColors = darkColors.split(' ');
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastStrongLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
              if (angular.isObject(hueValue))
                return;
              var rgbValue = colorToRgbaArray(hueValue);
              if (!rgbValue) {
                throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace('%1', hueValue).replace('%2', palette.name).replace('%3', hueName));
              }
              palette[hueName] = {
                value: rgbValue,
                contrast: getContrastColor()
              };
              function getContrastColor() {
                if (defaultContrast === 'light') {
                  if (darkColors.indexOf(hueName) > -1) {
                    return DARK_CONTRAST_COLOR;
                  } else {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  }
                } else {
                  if (lightColors.indexOf(hueName) > -1) {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  } else {
                    return DARK_CONTRAST_COLOR;
                  }
                }
              }
            });
          }
        }
        generateAllThemes.$inject = ["$injector"];
        function generateTheme(name, nonce) {
          var theme = THEMES[name];
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          if (!GENERATED[name]) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
              while (styleStrings.length) {
                var styleContent = styleStrings.shift();
                if (styleContent) {
                  var style = document.createElement('style');
                  style.setAttribute('md-theme-style', '');
                  if (nonce) {
                    style.setAttribute('nonce', nonce);
                  }
                  style.appendChild(document.createTextNode(styleContent));
                  head.insertBefore(style, firstChild);
                }
              }
            });
            if (theme.colors.primary.name == theme.colors.accent.name) {
              console.warn('$mdThemingProvider: Using the same palette for primary and' + ' accent. This violates the material design spec.');
            }
            GENERATED[theme.name] = true;
          }
        }
        function checkValidPalette(theme, colorType) {
          if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace('%1', theme.name).replace('%2', colorType).replace('%3', Object.keys(PALETTES).join(', ')));
          }
        }
        function colorToRgbaArray(clr) {
          if (angular.isArray(clr) && clr.length == 3)
            return clr;
          if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, '').split(',').map(function(value, i) {
              return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
            });
          }
          if (clr.charAt(0) == '#')
            clr = clr.substring(1);
          if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr))
            return;
          var dig = clr.length / 3;
          var red = clr.substr(0, dig);
          var grn = clr.substr(dig, dig);
          var blu = clr.substr(dig * 2);
          if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
          }
          return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
        }
        function rgba(rgbArray, opacity) {
          if (!rgbArray)
            return "rgb('0,0,0')";
          if (rgbArray.length == 4) {
            rgbArray = angular.copy(rgbArray);
            opacity ? rgbArray.pop() : opacity = rgbArray.pop();
          }
          return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ? 'rgba(' + rgbArray.join(',') + ',' + opacity + ')' : 'rgb(' + rgbArray.join(',') + ')';
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
          return function($mdUtil) {
            return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
          };
        }]);
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
          var self;
          return self = {
            translate3d: function(target, from, to, options) {
              return $animateCss(target, {
                from: from,
                to: to,
                addClass: options.transitionInClass
              }).start().then(function() {
                return reverseTranslate;
              });
              function reverseTranslate(newFrom) {
                return $animateCss(target, {
                  to: newFrom || from,
                  addClass: options.transitionOutClass,
                  removeClass: options.transitionInClass
                }).start();
              }
            },
            waitTransitionEnd: function(element, opts) {
              var TIMEOUT = 3000;
              return $q(function(resolve, reject) {
                opts = opts || {};
                var timer = $timeout(finished, opts.timeout || TIMEOUT);
                element.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                  if (ev && ev.target !== element[0])
                    return;
                  if (ev)
                    $timeout.cancel(timer);
                  element.off($mdConstant.CSS.TRANSITIONEND, finished);
                  resolve();
                }
              });
            },
            calculateZoomToOrigin: function(element, originator) {
              var origin = originator.element;
              var bounds = originator.bounds;
              var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
              var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
              var zoomStyle = buildZoom({
                centerX: 0,
                centerY: 0,
                scaleX: 0.5,
                scaleY: 0.5
              });
              if (origin || bounds) {
                var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
                var dialogRect = self.copyRect(element[0].getBoundingClientRect());
                var dialogCenterPt = self.centerPointFor(dialogRect);
                var originCenterPt = self.centerPointFor(originBnds);
                zoomStyle = buildZoom({
                  centerX: originCenterPt.x - dialogCenterPt.x,
                  centerY: originCenterPt.y - dialogCenterPt.y,
                  scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100,
                  scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100
                });
              }
              return zoomStyle;
              function currentBounds() {
                var cntr = element ? element.parent() : null;
                var parent = cntr ? cntr.parent() : null;
                return parent ? self.clientRect(parent) : null;
              }
            },
            toCss: function(raw) {
              var css = {};
              var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';
              angular.forEach(raw, function(value, key) {
                if (angular.isUndefined(value))
                  return;
                if (lookups.indexOf(key) >= 0) {
                  css[key] = value + 'px';
                } else {
                  switch (key) {
                    case 'transition':
                      convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                      break;
                    case 'transform':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                      break;
                    case 'transformOrigin':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                      break;
                  }
                }
              });
              return css;
              function convertToVendor(key, vendor, value) {
                angular.forEach(vendor.split(' '), function(key) {
                  css[key] = value;
                });
              }
            },
            toTransformCss: function(transform, addTransition, transition) {
              var css = {};
              angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function(key) {
                css[key] = transform;
              });
              if (addTransition) {
                transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                css['transition'] = transition;
              }
              return css;
            },
            copyRect: function(source, destination) {
              if (!source)
                return null;
              destination = destination || {};
              angular.forEach('left top right bottom width height'.split(' '), function(key) {
                destination[key] = Math.round(source[key]);
              });
              destination.width = destination.width || (destination.right - destination.left);
              destination.height = destination.height || (destination.bottom - destination.top);
              return destination;
            },
            clientRect: function(element) {
              var bounds = angular.element(element)[0].getBoundingClientRect();
              var isPositiveSizeClientRect = function(rect) {
                return rect && (rect.width > 0) && (rect.height > 0);
              };
              return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
            },
            centerPointFor: function(targetRect) {
              return targetRect ? {
                x: Math.round(targetRect.left + (targetRect.width / 2)),
                y: Math.round(targetRect.top + (targetRect.height / 2))
              } : {
                x: 0,
                y: 0
              };
            }
          };
        }
        ;
      })();
      (function() {
        "use strict";
        "use strict";
        if (angular.version.minor >= 4) {
          angular.module('material.core.animate', []);
        } else {
          (function() {
            var forEach = angular.forEach;
            var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
            var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition';
            var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation';
            var PREFIX = WEBKIT ? '-webkit-' : '';
            var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend';
            var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend';
            var $$ForceReflowFactory = ['$document', function($document) {
              return function() {
                return $document[0].body.clientWidth + 1;
              };
            }];
            var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
              return function() {
                var passed = false;
                $$rAF(function() {
                  passed = true;
                });
                return function(fn) {
                  passed ? fn() : $$rAF(fn);
                };
              };
            }];
            var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
              var INITIAL_STATE = 0;
              var DONE_PENDING_STATE = 1;
              var DONE_COMPLETE_STATE = 2;
              function AnimateRunner(host) {
                this.setHost(host);
                this._doneCallbacks = [];
                this._runInAnimationFrame = $$rAFMutex();
                this._state = 0;
              }
              AnimateRunner.prototype = {
                setHost: function(host) {
                  this.host = host || {};
                },
                done: function(fn) {
                  if (this._state === DONE_COMPLETE_STATE) {
                    fn();
                  } else {
                    this._doneCallbacks.push(fn);
                  }
                },
                progress: angular.noop,
                getPromise: function() {
                  if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                      self.done(function(status) {
                        status === false ? reject() : resolve();
                      });
                    });
                  }
                  return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                  return this.getPromise().then(resolveHandler, rejectHandler);
                },
                'catch': function(handler) {
                  return this.getPromise()['catch'](handler);
                },
                'finally': function(handler) {
                  return this.getPromise()['finally'](handler);
                },
                pause: function() {
                  if (this.host.pause) {
                    this.host.pause();
                  }
                },
                resume: function() {
                  if (this.host.resume) {
                    this.host.resume();
                  }
                },
                end: function() {
                  if (this.host.end) {
                    this.host.end();
                  }
                  this._resolve(true);
                },
                cancel: function() {
                  if (this.host.cancel) {
                    this.host.cancel();
                  }
                  this._resolve(false);
                },
                complete: function(response) {
                  var self = this;
                  if (self._state === INITIAL_STATE) {
                    self._state = DONE_PENDING_STATE;
                    self._runInAnimationFrame(function() {
                      self._resolve(response);
                    });
                  }
                },
                _resolve: function(response) {
                  if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function(fn) {
                      fn(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                  }
                }
              };
              return AnimateRunner;
            }];
            angular.module('material.core.animate', []).factory('$$forceReflow', $$ForceReflowFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).factory('$$rAFMutex', $$rAFMutexFactory).factory('$animateCss', ['$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout) {
              function init(element, options) {
                var temporaryStyles = [];
                var node = getDomNode(element);
                if (options.transitionStyle) {
                  temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);
                }
                if (options.keyframeStyle) {
                  temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);
                }
                if (options.delay) {
                  temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);
                }
                if (options.duration) {
                  temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);
                }
                var hasCompleteStyles = options.keyframeStyle || (options.to && (options.duration > 0 || options.transitionStyle));
                var hasCompleteClasses = !!options.addClass || !!options.removeClass;
                var hasCompleteAnimation = hasCompleteStyles || hasCompleteClasses;
                blockTransition(element, true);
                applyAnimationFromStyles(element, options);
                var animationClosed = false;
                var events,
                    eventFn;
                return {
                  close: $window.close,
                  start: function() {
                    var runner = new $$AnimateRunner();
                    waitUntilQuiet(function() {
                      blockTransition(element, false);
                      if (!hasCompleteAnimation) {
                        return close();
                      }
                      forEach(temporaryStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                      });
                      applyClasses(element, options);
                      var timings = computeTimings(element);
                      if (timings.duration === 0) {
                        return close();
                      }
                      var moreStyles = [];
                      if (options.easing) {
                        if (timings.transitionDuration) {
                          moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);
                        }
                        if (timings.animationDuration) {
                          moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);
                        }
                      }
                      if (options.delay && timings.animationDelay) {
                        moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);
                      }
                      if (options.duration && timings.animationDuration) {
                        moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);
                      }
                      forEach(moreStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                        temporaryStyles.push(entry);
                      });
                      var maxDelay = timings.delay;
                      var maxDelayTime = maxDelay * 1000;
                      var maxDuration = timings.duration;
                      var maxDurationTime = maxDuration * 1000;
                      var startTime = Date.now();
                      events = [];
                      if (timings.transitionDuration) {
                        events.push(TRANSITION_EVENTS);
                      }
                      if (timings.animationDuration) {
                        events.push(ANIMATION_EVENTS);
                      }
                      events = events.join(' ');
                      eventFn = function(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event;
                        var timeStamp = ev.timeStamp || Date.now();
                        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                          close();
                        }
                      };
                      element.on(events, eventFn);
                      applyAnimationToStyles(element, options);
                      $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
                    });
                    return runner;
                    function close() {
                      if (animationClosed)
                        return;
                      animationClosed = true;
                      if (events && eventFn) {
                        element.off(events, eventFn);
                      }
                      applyClasses(element, options);
                      applyAnimationStyles(element, options);
                      forEach(temporaryStyles, function(entry) {
                        node.style[camelCase(entry[0])] = '';
                      });
                      runner.complete(true);
                      return runner;
                    }
                  }
                };
              }
              function applyClasses(element, options) {
                if (options.addClass) {
                  $$jqLite.addClass(element, options.addClass);
                  options.addClass = null;
                }
                if (options.removeClass) {
                  $$jqLite.removeClass(element, options.removeClass);
                  options.removeClass = null;
                }
              }
              function computeTimings(element) {
                var node = getDomNode(element);
                var cs = $window.getComputedStyle(node);
                var tdr = parseMaxTime(cs[prop('transitionDuration')]);
                var adr = parseMaxTime(cs[prop('animationDuration')]);
                var tdy = parseMaxTime(cs[prop('transitionDelay')]);
                var ady = parseMaxTime(cs[prop('animationDelay')]);
                adr *= (parseInt(cs[prop('animationIterationCount')], 10) || 1);
                var duration = Math.max(adr, tdr);
                var delay = Math.max(ady, tdy);
                return {
                  duration: duration,
                  delay: delay,
                  animationDuration: adr,
                  transitionDuration: tdr,
                  animationDelay: ady,
                  transitionDelay: tdy
                };
                function prop(key) {
                  return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1) : key;
                }
              }
              function parseMaxTime(str) {
                var maxValue = 0;
                var values = (str || "").split(/\s*,\s*/);
                forEach(values, function(value) {
                  if (value.charAt(value.length - 1) == 's') {
                    value = value.substring(0, value.length - 1);
                  }
                  value = parseFloat(value) || 0;
                  maxValue = maxValue ? Math.max(value, maxValue) : value;
                });
                return maxValue;
              }
              var cancelLastRAFRequest;
              var rafWaitQueue = [];
              function waitUntilQuiet(callback) {
                if (cancelLastRAFRequest) {
                  cancelLastRAFRequest();
                }
                rafWaitQueue.push(callback);
                cancelLastRAFRequest = $$rAF(function() {
                  cancelLastRAFRequest = null;
                  var pageWidth = $$forceReflow();
                  for (var i = 0; i < rafWaitQueue.length; i++) {
                    rafWaitQueue[i](pageWidth);
                  }
                  rafWaitQueue.length = 0;
                });
              }
              function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options);
                applyAnimationToStyles(element, options);
              }
              function applyAnimationFromStyles(element, options) {
                if (options.from) {
                  element.css(options.from);
                  options.from = null;
                }
              }
              function applyAnimationToStyles(element, options) {
                if (options.to) {
                  element.css(options.to);
                  options.to = null;
                }
              }
              function getDomNode(element) {
                for (var i = 0; i < element.length; i++) {
                  if (element[i].nodeType === 1)
                    return element[i];
                }
              }
              function blockTransition(element, bool) {
                var node = getDomNode(element);
                var key = camelCase(PREFIX + 'transition-delay');
                node.style[key] = bool ? '-9999s' : '';
              }
              return init;
            }]);
            function camelCase(str) {
              return str.replace(/-[a-z]/g, function(str) {
                return str.charAt(1).toUpperCase();
              });
            }
          })();
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.backdrop', ['material.core']).directive('mdBackdrop', ["$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $animate, $rootElement, $window, $log, $$rAF, $document) {
          var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
          return {
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attrs) {
            var body = $window.getComputedStyle($document[0].body);
            if (body.position == 'fixed') {
              var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
              element.css({height: hViewport + 'px'});
            }
            if ($animate.pin)
              $animate.pin(element, $rootElement);
            $$rAF(function() {
              var parent = element.parent()[0];
              if (parent) {
                if (parent.nodeName == 'BODY') {
                  element.css({position: 'fixed'});
                }
                var styles = $window.getComputedStyle(parent);
                if (styles.position == 'static') {
                  $log.warn(ERROR_CSS_POSITION);
                }
              }
              $mdTheming.inherit(element, element.parent());
            });
          }
        }]);
      })();
      (function() {
        "use strict";
        angular.module('material.components.button', ['material.core']).directive('mdButton', MdButtonDirective);
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
          return {
            restrict: 'EA',
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
          };
          function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
          }
          function getTemplate(element, attr) {
            if (isAnchor(attr)) {
              return '<a class="md-button" ng-transclude></a>';
            } else {
              var btnType = (typeof attr.type === 'undefined') ? 'button' : attr.type;
              return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            $mdButtonInkRipple.attach(scope, element);
            $mdAria.expectWithText(element, 'aria-label');
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
              scope.$watch(attr.ngDisabled, function(isDisabled) {
                element.attr('tabindex', isDisabled ? -1 : 0);
              });
            }
            element.on('click', function(e) {
              if (attr.disabled === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });
            scope.mouseActive = false;
            element.on('mousedown', function() {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                element.addClass('md-focused');
              }
            }).on('blur', function(ev) {
              element.removeClass('md-focused');
            });
          }
        }
        MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.card', ['material.core']).directive('mdCard', mdCardDirective);
        function mdCardDirective($mdTheming) {
          return {
            restrict: 'E',
            link: function($scope, $element) {
              $mdTheming($element);
            }
          };
        }
        mdCardDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.checkbox', ['material.core']).directive('mdCheckbox', MdCheckboxDirective);
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
          inputDirective = inputDirective[0];
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            transclude: true,
            require: '?ngModel',
            priority: 210,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            tAttrs.type = 'checkbox';
            tAttrs.tabindex = tAttrs.tabindex || '0';
            tElement.attr('role', tAttrs.type);
            tElement.on('click', function(event) {
              if (this.hasAttribute('disabled')) {
                event.stopImmediatePropagation();
              }
            });
            return function postLink(scope, element, attr, ngModelCtrl) {
              ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
              $mdTheming(element);
              if (attr.ngChecked) {
                scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
              }
              $$watchExpr('ngDisabled', 'tabindex', {
                true: '-1',
                false: attr.tabindex
              });
              $mdAria.expectWithText(element, 'aria-label');
              inputDirective.link.pre(scope, {
                on: angular.noop,
                0: {}
              }, attr, [ngModelCtrl]);
              scope.mouseActive = false;
              element.on('click', listener).on('keypress', keypressHandler).on('mousedown', function() {
                scope.mouseActive = true;
                $timeout(function() {
                  scope.mouseActive = false;
                }, 100);
              }).on('focus', function() {
                if (scope.mouseActive === false) {
                  element.addClass('md-focused');
                }
              }).on('blur', function() {
                element.removeClass('md-focused');
              });
              ngModelCtrl.$render = render;
              function $$watchExpr(expr, htmlAttr, valueOpts) {
                if (attr[expr]) {
                  scope.$watch(attr[expr], function(val) {
                    if (valueOpts[val]) {
                      element.attr(htmlAttr, valueOpts[val]);
                    }
                  });
                }
              }
              function keypressHandler(ev) {
                var keyCode = ev.which || ev.keyCode;
                if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                  ev.preventDefault();
                  if (!element.hasClass('md-focused')) {
                    element.addClass('md-focused');
                  }
                  listener(ev);
                }
              }
              function listener(ev) {
                if (element[0].hasAttribute('disabled')) {
                  return;
                }
                scope.$apply(function() {
                  var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                  ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                  ngModelCtrl.$render();
                });
              }
              function render() {
                if (ngModelCtrl.$viewValue) {
                  element.addClass(CHECKED_CSS);
                } else {
                  element.removeClass(CHECKED_CSS);
                }
              }
            };
          }
        }
        MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.bottomSheet', ['material.core', 'material.components.backdrop']).directive('mdBottomSheet', MdBottomSheetDirective).provider('$mdBottomSheet', MdBottomSheetProvider);
        function MdBottomSheetDirective($mdBottomSheet) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdBottomSheet.destroy();
              });
            }
          };
        }
        MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
        function MdBottomSheetProvider($$interimElementProvider) {
          var CLOSING_VELOCITY = 0.5;
          var PADDING = 80;
          bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture"];
          return $$interimElementProvider('$mdBottomSheet').setDefaults({
            methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'],
            options: bottomSheetDefaults
          });
          function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {
            var backdrop;
            return {
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              escapeToClose: true,
              clickOutsideToClose: true,
              disableParentScroll: true
            };
            function onShow(scope, element, options, controller) {
              element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');
              backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
              if (options.clickOutsideToClose) {
                backdrop.on('click', function() {
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                });
              }
              $mdTheming.inherit(backdrop, options.parent);
              $animate.enter(backdrop, options.parent, null);
              var bottomSheet = new BottomSheet(element, options.parent);
              options.bottomSheet = bottomSheet;
              $mdTheming.inherit(bottomSheet.element, options.parent);
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent);
              }
              return $animate.enter(bottomSheet.element, options.parent).then(function() {
                var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector('button') || element[0].querySelector('a') || element[0].querySelector('[ng-click]'));
                focusable.focus();
                if (options.escapeToClose) {
                  options.rootElementKeyupCallback = function(e) {
                    if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                      $mdUtil.nextTick($mdBottomSheet.cancel, true);
                    }
                  };
                  $rootElement.on('keyup', options.rootElementKeyupCallback);
                }
              });
            }
            function onRemove(scope, element, options) {
              var bottomSheet = options.bottomSheet;
              $animate.leave(backdrop);
              return $animate.leave(bottomSheet.element).then(function() {
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                bottomSheet.cleanup();
              });
            }
            function BottomSheet(element, parent) {
              var deregister = $mdGesture.register(parent, 'drag', {horizontal: false});
              parent.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              return {
                element: element,
                cleanup: function cleanup() {
                  deregister();
                  parent.off('$md.dragstart', onDragStart);
                  parent.off('$md.drag', onDrag);
                  parent.off('$md.dragend', onDragEnd);
                }
              };
              function onDragStart(ev) {
                element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');
              }
              function onDrag(ev) {
                var transform = ev.pointer.distanceY;
                if (transform < 5) {
                  transform = Math.max(-PADDING, transform / 2);
                }
                element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');
              }
              function onDragEnd(ev) {
                if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                  var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;
                  var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);
                  element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                } else {
                  element.css($mdConstant.CSS.TRANSITION_DURATION, '');
                  element.css($mdConstant.CSS.TRANSFORM, '');
                }
              }
            }
          }
        }
        MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips', ['material.core', 'material.components.autocomplete']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.dialog', ['material.core', 'material.components.backdrop']).directive('mdDialog', MdDialogDirective).provider('$mdDialog', MdDialogProvider);
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
          return {
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              $$rAF(function() {
                var images;
                var content = element[0].querySelector('md-dialog-content');
                if (content) {
                  images = content.getElementsByTagName('img');
                  addOverflowClass();
                  angular.element(images).on('load', addOverflowClass);
                }
                scope.$on('$destroy', function() {
                  $mdDialog.destroy(element);
                });
                function addOverflowClass() {
                  element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);
                }
              });
            }
          };
        }
        MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
        function MdDialogProvider($$interimElementProvider) {
          var topFocusTrap,
              bottomFocusTrap;
          advancedDialogOptions.$inject = ["$mdDialog", "$mdTheming"];
          dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector"];
          return $$interimElementProvider('$mdDialog').setDefaults({
            methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen'],
            options: dialogDefaultOptions
          }).addPreset('alert', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme', 'css'],
            options: advancedDialogOptions
          }).addPreset('confirm', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'],
            options: advancedDialogOptions
          });
          function advancedDialogOptions($mdDialog, $mdTheming) {
            return {
              template: ['<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', '      <p>{{::dialog.mdTextContent}}</p>', '    </div>', '  </md-dialog-content>', '  <md-dialog-actions>', '    <md-button ng-if="dialog.$type == \'confirm\'"' + '               ng-click="dialog.abort()" class="md-primary">', '      {{ dialog.cancel }}', '    </md-button>', '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type!=\'confirm\'">', '      {{ dialog.ok }}', '    </md-button>', '  </md-dialog-actions>', '</md-dialog>'].join('').replace(/\s\s+/g, ''),
              controller: function mdDialogCtrl() {
                this.hide = function() {
                  $mdDialog.hide(true);
                };
                this.abort = function() {
                  $mdDialog.cancel();
                };
              },
              controllerAs: 'dialog',
              bindToController: true,
              theme: $mdTheming.defaultTheme()
            };
          }
          function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector) {
            return {
              hasBackdrop: true,
              isolateScope: true,
              onShow: onShow,
              onShowing: beforeShow,
              onRemove: onRemove,
              clickOutsideToClose: false,
              escapeToClose: true,
              targetEvent: null,
              closeTo: null,
              openFrom: null,
              focusOnOpen: true,
              disableParentScroll: true,
              autoWrap: true,
              fullscreen: false,
              transformTemplate: function(template, options) {
                return '<div class="md-dialog-container">' + validatedTemplate(template) + '</div>';
                function validatedTemplate(template) {
                  if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {
                    return '<md-dialog>' + (template || '') + '</md-dialog>';
                  } else {
                    return template || '';
                  }
                }
              }
            };
            function beforeShow(scope, element, options, controller) {
              if (controller) {
                controller.mdHtmlContent = controller.htmlContent || options.htmlContent || '';
                controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || '';
                if (controller.mdHtmlContent && !$injector.has('$sanitize')) {
                  throw Error('The ngSanitize module must be loaded in order to use htmlContent.');
                }
                if (controller.mdHtmlContent && controller.mdTextContent) {
                  throw Error('md-dialog cannot have both `htmlContent` and `textContent`');
                }
              }
            }
            function onShow(scope, element, options, controller) {
              angular.element($document[0].body).addClass('md-dialog-is-showing');
              captureParentAndFromToElements(options);
              configureAria(element.find('md-dialog'), options);
              showBackdrop(scope, element, options);
              return dialogPopIn(element, options).then(function() {
                activateListeners(element, options);
                lockScreenReader(element, options);
                warnDeprecatedActions();
                focusOnOpen();
              });
              function warnDeprecatedActions() {
                var badActions = element[0].querySelectorAll('.md-actions');
                if (badActions.length > 0) {
                  $log.warn('Using a class of md-actions is deprected, please use <md-dialog-actions>.');
                }
              }
              function focusOnOpen() {
                if (options.focusOnOpen) {
                  var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                  target.focus();
                }
                function findCloseButton() {
                  var closeButton = element[0].querySelector('.dialog-close');
                  if (!closeButton) {
                    var actionButtons = element[0].querySelectorAll('.md-actions button, md-dialog-actions button');
                    closeButton = actionButtons[actionButtons.length - 1];
                  }
                  return angular.element(closeButton);
                }
              }
            }
            function onRemove(scope, element, options) {
              options.deactivateListeners();
              options.unlockScreenReader();
              options.hideBackdrop(options.$destroy);
              if (topFocusTrap && topFocusTrap.parentNode) {
                topFocusTrap.parentNode.removeChild(topFocusTrap);
              }
              if (bottomFocusTrap && bottomFocusTrap.parentNode) {
                bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
              }
              return !!options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return dialogPopOut(element, options);
              }
              function detachAndClean() {
                angular.element($document[0].body).removeClass('md-dialog-is-showing');
                element.remove();
                if (!options.$destroy)
                  options.origin.focus();
              }
            }
            function captureParentAndFromToElements(options) {
              options.origin = angular.extend({
                element: null,
                bounds: null,
                focus: angular.noop
              }, options.origin || {});
              options.parent = getDomElement(options.parent, $rootElement);
              options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
              options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
              if (options.targetEvent) {
                options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
              }
              function getBoundingClientRect(element, orig) {
                var source = angular.element((element || {}));
                if (source && source.length) {
                  var bounds = {
                    top: 0,
                    left: 0,
                    height: 0,
                    width: 0
                  };
                  var hasFn = angular.isFunction(source[0].getBoundingClientRect);
                  return angular.extend(orig || {}, {
                    element: hasFn ? source : undefined,
                    bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                    focus: angular.bind(source, source.focus)
                  });
                }
              }
              function getDomElement(element, defaultElement) {
                if (angular.isString(element)) {
                  var simpleSelector = element,
                      container = $document[0].querySelectorAll(simpleSelector);
                  element = container.length ? container[0] : null;
                }
                return angular.element(element || defaultElement);
              }
            }
            function activateListeners(element, options) {
              var window = angular.element($window);
              var onWindowResize = $mdUtil.debounce(function() {
                stretchDialogContainerToViewport(element, options);
              }, 60);
              var removeListeners = [];
              var smartClose = function() {
                var closeFn = (options.$type == 'alert') ? $mdDialog.hide : $mdDialog.cancel;
                $mdUtil.nextTick(closeFn, true);
              };
              if (options.escapeToClose) {
                var parentTarget = options.parent;
                var keyHandlerFn = function(ev) {
                  if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                element.on('keydown', keyHandlerFn);
                parentTarget.on('keydown', keyHandlerFn);
                removeListeners.push(function() {
                  element.off('keydown', keyHandlerFn);
                  parentTarget.off('keydown', keyHandlerFn);
                });
              }
              window.on('resize', onWindowResize);
              removeListeners.push(function() {
                window.off('resize', onWindowResize);
              });
              if (options.clickOutsideToClose) {
                var target = element;
                var sourceElem;
                var mousedownHandler = function(ev) {
                  sourceElem = ev.target;
                };
                var mouseupHandler = function(ev) {
                  if (sourceElem === target[0] && ev.target === target[0]) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                target.on('mousedown', mousedownHandler);
                target.on('mouseup', mouseupHandler);
                removeListeners.push(function() {
                  target.off('mousedown', mousedownHandler);
                  target.off('mouseup', mouseupHandler);
                });
              }
              options.deactivateListeners = function() {
                removeListeners.forEach(function(removeFn) {
                  removeFn();
                });
                options.deactivateListeners = null;
              };
            }
            function showBackdrop(scope, element, options) {
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
                $animate.enter(options.backdrop, options.parent);
              }
              options.hideBackdrop = function hideBackdrop($destroy) {
                if (options.backdrop) {
                  if (!!$destroy)
                    options.backdrop.remove();
                  else
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                options.hideBackdrop = null;
              };
            }
            function configureAria(element, options) {
              var role = (options.$type === 'alert') ? 'alertdialog' : 'dialog';
              var dialogContent = element.find('md-dialog-content');
              var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());
              element.attr({
                'role': role,
                'tabIndex': '-1'
              });
              if (dialogContent.length === 0) {
                dialogContent = element;
              }
              dialogContent.attr('id', dialogId);
              element.attr('aria-describedby', dialogId);
              if (options.ariaLabel) {
                $mdAria.expect(element, 'aria-label', options.ariaLabel);
              } else {
                $mdAria.expectAsync(element, 'aria-label', function() {
                  var words = dialogContent.text().split(/\s+/);
                  if (words.length > 3)
                    words = words.slice(0, 3).concat('...');
                  return words.join(' ');
                });
              }
              topFocusTrap = document.createElement('div');
              topFocusTrap.classList.add('md-dialog-focus-trap');
              topFocusTrap.tabIndex = 0;
              bottomFocusTrap = topFocusTrap.cloneNode(false);
              var focusHandler = function() {
                element.focus();
              };
              topFocusTrap.addEventListener('focus', focusHandler);
              bottomFocusTrap.addEventListener('focus', focusHandler);
              element[0].parentNode.insertBefore(topFocusTrap, element[0]);
              element.append(bottomFocusTrap);
            }
            function lockScreenReader(element, options) {
              var isHidden = true;
              walkDOM(element[0]);
              options.unlockScreenReader = function() {
                isHidden = false;
                walkDOM(element[0]);
                options.unlockScreenReader = null;
              };
              function walkDOM(element) {
                while (element.parentNode) {
                  if (element === document.body) {
                    return;
                  }
                  var children = element.parentNode.children;
                  for (var i = 0; i < children.length; i++) {
                    if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {
                      children[i].setAttribute('aria-hidden', isHidden);
                    }
                  }
                  walkDOM(element = element.parentNode);
                }
              }
            }
            function stretchDialogContainerToViewport(container, options) {
              var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed';
              var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
              var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
              container.css({
                top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + 'px',
                height: height ? height + 'px' : '100%'
              });
              return container;
            }
            function dialogPopIn(container, options) {
              options.parent.append(container);
              stretchDialogContainerToViewport(container, options);
              var dialogEl = container.find('md-dialog');
              var animator = $mdUtil.dom.animator;
              var buildTranslateToOrigin = animator.calculateZoomToOrigin;
              var translateOptions = {
                transitionInClass: 'md-transition-in',
                transitionOutClass: 'md-transition-out'
              };
              var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
              var to = animator.toTransformCss("");
              if (options.fullscreen) {
                dialogEl.addClass('md-dialog-fullscreen');
              }
              return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                options.reverseAnimate = function() {
                  delete options.reverseAnimate;
                  if (options.closeTo) {
                    translateOptions = {
                      transitionInClass: 'md-transition-out',
                      transitionOutClass: 'md-transition-in'
                    };
                    from = to;
                    to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                    return animator.translate3d(dialogEl, from, to, translateOptions);
                  }
                  return animateReversal(animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                };
                return true;
              });
            }
            function dialogPopOut(container, options) {
              return options.reverseAnimate();
            }
            function isNodeOneOf(elem, nodeTypeArray) {
              if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
                return true;
              }
            }
          }
        }
        MdDialogProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.divider', ['material.core']).directive('mdDivider', MdDividerDirective);
        function MdDividerDirective($mdTheming) {
          return {
            restrict: 'E',
            link: $mdTheming
          };
        }
        MdDividerDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']).directive('mdCalendar', calendarDirective);
          var TBODY_HEIGHT = 265;
          var TBODY_SINGLE_ROW_HEIGHT = 45;
          function calendarDirective() {
            return {
              template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' + '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container" ' + 'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month ' + 'md-month-offset="$index" class="md-calendar-month" ' + 'md-start-index="ctrl.getSelectedMonthIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '"></tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>',
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                dateFilter: '=mdDateFilter'
              },
              require: ['ngModel', 'mdCalendar'],
              controller: CalendarCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var mdCalendarCtrl = controllers[1];
                mdCalendarCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          var nextUniqueId = 0;
          var firstRenderableDate = null;
          function CalendarCtrl($element, $attrs, $scope, $animate, $q, $mdConstant, $mdTheming, $$mdDateUtil, $mdDateLocale, $mdInkRipple, $mdUtil) {
            $mdTheming($element);
            this.items = {length: 2000};
            if (this.maxDate && this.minDate) {
              var numMonths = $$mdDateUtil.getMonthDistance(this.minDate, this.maxDate) + 1;
              numMonths = Math.max(numMonths, 1);
              numMonths += 1;
              this.items.length = numMonths;
            }
            this.$animate = $animate;
            this.$q = $q;
            this.$mdInkRipple = $mdInkRipple;
            this.$mdUtil = $mdUtil;
            this.keyCode = $mdConstant.KEY_CODE;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.$scope = $scope;
            this.calendarElement = $element[0].querySelector('.md-calendar');
            this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');
            this.today = this.dateUtil.createDateAtMidnight();
            this.firstRenderableDate = this.dateUtil.incrementMonths(this.today, -this.items.length / 2);
            if (this.minDate && this.minDate > this.firstRenderableDate) {
              this.firstRenderableDate = this.minDate;
            } else if (this.maxDate) {
              var monthDifference = this.items.length - 2;
              this.firstRenderableDate = this.dateUtil.incrementMonths(this.maxDate, -(this.items.length - 2));
            }
            this.id = nextUniqueId++;
            this.ngModelCtrl = null;
            this.selectedDate = null;
            this.displayDate = null;
            this.focusDate = null;
            this.isInitialized = false;
            this.isMonthTransitionInProgress = false;
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            var self = this;
            this.cellClickHandler = function() {
              var cellElement = this;
              if (this.hasAttribute('data-timestamp')) {
                $scope.$apply(function() {
                  var timestamp = Number(cellElement.getAttribute('data-timestamp'));
                  self.setNgModelValue(self.dateUtil.createDateAtMidnight(timestamp));
                });
              }
            };
            this.attachCalendarEventListeners();
          }
          CalendarCtrl.$inject = ["$element", "$attrs", "$scope", "$animate", "$q", "$mdConstant", "$mdTheming", "$$mdDateUtil", "$mdDateLocale", "$mdInkRipple", "$mdUtil"];
          CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              self.changeSelectedDate(self.ngModelCtrl.$viewValue);
            };
          };
          CalendarCtrl.prototype.buildInitialCalendarDisplay = function() {
            this.buildWeekHeader();
            this.hideVerticalScrollbar();
            this.displayDate = this.selectedDate || this.today;
            this.isInitialized = true;
          };
          CalendarCtrl.prototype.hideVerticalScrollbar = function() {
            var element = this.$element[0];
            var scrollMask = element.querySelector('.md-calendar-scroll-mask');
            var scroller = this.calendarScroller;
            var headerWidth = element.querySelector('.md-calendar-day-header').clientWidth;
            var scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
            scrollMask.style.width = headerWidth + 'px';
            scroller.style.width = (headerWidth + scrollbarWidth) + 'px';
            scroller.style.paddingRight = scrollbarWidth + 'px';
          };
          CalendarCtrl.prototype.attachCalendarEventListeners = function() {
            this.$element.on('keydown', angular.bind(this, this.handleKeyEvent));
          };
          CalendarCtrl.prototype.handleKeyEvent = function(event) {
            var self = this;
            this.$scope.$apply(function() {
              if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {
                self.$scope.$emit('md-calendar-close');
                if (event.which == self.keyCode.TAB) {
                  event.preventDefault();
                }
                return;
              }
              if (event.which === self.keyCode.ENTER) {
                self.setNgModelValue(self.displayDate);
                event.preventDefault();
                return;
              }
              var date = self.getFocusDateFromKeyEvent(event);
              if (date) {
                date = self.boundDateByMinAndMax(date);
                event.preventDefault();
                event.stopPropagation();
                self.changeDisplayDate(date).then(function() {
                  self.focus(date);
                });
              }
            });
          };
          CalendarCtrl.prototype.getFocusDateFromKeyEvent = function(event) {
            var dateUtil = this.dateUtil;
            var keyCode = this.keyCode;
            switch (event.which) {
              case keyCode.RIGHT_ARROW:
                return dateUtil.incrementDays(this.displayDate, 1);
              case keyCode.LEFT_ARROW:
                return dateUtil.incrementDays(this.displayDate, -1);
              case keyCode.DOWN_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, 1) : dateUtil.incrementDays(this.displayDate, 7);
              case keyCode.UP_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, -1) : dateUtil.incrementDays(this.displayDate, -7);
              case keyCode.PAGE_DOWN:
                return dateUtil.incrementMonths(this.displayDate, 1);
              case keyCode.PAGE_UP:
                return dateUtil.incrementMonths(this.displayDate, -1);
              case keyCode.HOME:
                return dateUtil.getFirstDateOfMonth(this.displayDate);
              case keyCode.END:
                return dateUtil.getLastDateOfMonth(this.displayDate);
              default:
                return null;
            }
          };
          CalendarCtrl.prototype.getSelectedMonthIndex = function() {
            return this.dateUtil.getMonthDistance(this.firstRenderableDate, this.selectedDate || this.today);
          };
          CalendarCtrl.prototype.scrollToMonth = function(date) {
            if (!this.dateUtil.isValidDate(date)) {
              return;
            }
            var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
            this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
          };
          CalendarCtrl.prototype.setNgModelValue = function(date) {
            this.$scope.$emit('md-calendar-change', date);
            this.ngModelCtrl.$setViewValue(date);
            this.ngModelCtrl.$render();
          };
          CalendarCtrl.prototype.focus = function(opt_date) {
            var date = opt_date || this.selectedDate || this.today;
            var previousFocus = this.calendarElement.querySelector('.md-focus');
            if (previousFocus) {
              previousFocus.classList.remove(FOCUSED_DATE_CLASS);
            }
            var cellId = this.getDateId(date);
            var cell = document.getElementById(cellId);
            if (cell) {
              cell.classList.add(FOCUSED_DATE_CLASS);
              cell.focus();
            } else {
              this.focusDate = date;
            }
          };
          CalendarCtrl.prototype.boundDateByMinAndMax = function(date) {
            var boundDate = date;
            if (this.minDate && date < this.minDate) {
              boundDate = new Date(this.minDate.getTime());
            }
            if (this.maxDate && date > this.maxDate) {
              boundDate = new Date(this.maxDate.getTime());
            }
            return boundDate;
          };
          CalendarCtrl.prototype.changeSelectedDate = function(date) {
            var self = this;
            var previousSelectedDate = this.selectedDate;
            this.selectedDate = date;
            this.changeDisplayDate(date).then(function() {
              if (previousSelectedDate) {
                var prevDateCell = document.getElementById(self.getDateId(previousSelectedDate));
                if (prevDateCell) {
                  prevDateCell.classList.remove(SELECTED_DATE_CLASS);
                  prevDateCell.setAttribute('aria-selected', 'false');
                }
              }
              if (date) {
                var dateCell = document.getElementById(self.getDateId(date));
                if (dateCell) {
                  dateCell.classList.add(SELECTED_DATE_CLASS);
                  dateCell.setAttribute('aria-selected', 'true');
                }
              }
            });
          };
          CalendarCtrl.prototype.changeDisplayDate = function(date) {
            if (!this.isInitialized) {
              this.buildInitialCalendarDisplay();
              return this.$q.when();
            }
            if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {
              return this.$q.when();
            }
            this.isMonthTransitionInProgress = true;
            var animationPromise = this.animateDateChange(date);
            this.displayDate = date;
            var self = this;
            animationPromise.then(function() {
              self.isMonthTransitionInProgress = false;
            });
            return animationPromise;
          };
          CalendarCtrl.prototype.animateDateChange = function(date) {
            this.scrollToMonth(date);
            return this.$q.when();
          };
          CalendarCtrl.prototype.buildWeekHeader = function() {
            var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
            var shortDays = this.dateLocale.shortDays;
            var row = document.createElement('tr');
            for (var i = 0; i < 7; i++) {
              var th = document.createElement('th');
              th.textContent = shortDays[(i + firstDayOfWeek) % 7];
              row.appendChild(th);
            }
            this.$element.find('thead').append(row);
          };
          CalendarCtrl.prototype.getDateId = function(date) {
            return ['md', this.id, date.getFullYear(), date.getMonth(), date.getDate()].join('-');
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarMonth', mdCalendarMonthDirective);
          function mdCalendarMonthDirective() {
            return {
              require: ['^^mdCalendar', 'mdCalendarMonth'],
              scope: {offset: '=mdMonthOffset'},
              controller: CalendarMonthCtrl,
              controllerAs: 'mdMonthCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var monthCtrl = controllers[1];
                monthCtrl.calendarCtrl = calendarCtrl;
                monthCtrl.generateContent();
                scope.$watch(function() {
                  return monthCtrl.offset;
                }, function(offset, oldOffset) {
                  if (offset != oldOffset) {
                    monthCtrl.generateContent();
                  }
                });
              }
            };
          }
          var TODAY_CLASS = 'md-calendar-date-today';
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          function CalendarMonthCtrl($element, $$mdDateUtil, $mdDateLocale) {
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.calendarCtrl = null;
            this.offset;
            this.focusAfterAppend = null;
          }
          CalendarMonthCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
          CalendarMonthCtrl.prototype.generateContent = function() {
            var calendarCtrl = this.calendarCtrl;
            var date = this.dateUtil.incrementMonths(calendarCtrl.firstRenderableDate, this.offset);
            this.$element.empty();
            this.$element.append(this.buildCalendarForMonth(date));
            if (this.focusAfterAppend) {
              this.focusAfterAppend.classList.add(FOCUSED_DATE_CLASS);
              this.focusAfterAppend.focus();
              this.focusAfterAppend = null;
            }
          };
          CalendarMonthCtrl.prototype.buildDateCell = function(opt_date) {
            var calendarCtrl = this.calendarCtrl;
            var cell = document.createElement('td');
            cell.tabIndex = -1;
            cell.classList.add('md-calendar-date');
            cell.setAttribute('role', 'gridcell');
            if (opt_date) {
              cell.setAttribute('tabindex', '-1');
              cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date));
              cell.id = calendarCtrl.getDateId(opt_date);
              cell.setAttribute('data-timestamp', opt_date.getTime());
              if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {
                cell.classList.add(TODAY_CLASS);
              }
              if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                cell.classList.add(SELECTED_DATE_CLASS);
                cell.setAttribute('aria-selected', 'true');
              }
              var cellText = this.dateLocale.dates[opt_date.getDate()];
              if (this.isDateEnabled(opt_date)) {
                var selectionIndicator = document.createElement('span');
                cell.appendChild(selectionIndicator);
                selectionIndicator.classList.add('md-calendar-date-selection-indicator');
                selectionIndicator.textContent = cellText;
                cell.addEventListener('click', calendarCtrl.cellClickHandler);
                if (calendarCtrl.focusDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.focusDate)) {
                  this.focusAfterAppend = cell;
                }
              } else {
                cell.classList.add('md-calendar-date-disabled');
                cell.textContent = cellText;
              }
            }
            return cell;
          };
          CalendarMonthCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
          };
          CalendarMonthCtrl.prototype.buildDateRow = function(rowNumber) {
            var row = document.createElement('tr');
            row.setAttribute('role', 'row');
            row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber));
            return row;
          };
          CalendarMonthCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
            var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date();
            var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
            var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
            var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);
            var monthBody = document.createDocumentFragment();
            var rowNumber = 1;
            var row = this.buildDateRow(rowNumber);
            monthBody.appendChild(row);
            var isFinalMonth = this.offset === this.calendarCtrl.items.length - 1;
            var blankCellOffset = 0;
            var monthLabelCell = document.createElement('td');
            monthLabelCell.classList.add('md-calendar-month-label');
            if (this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate) {
              monthLabelCell.classList.add('md-calendar-month-label-disabled');
            }
            monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
            if (firstDayOfTheWeek <= 2) {
              monthLabelCell.setAttribute('colspan', '7');
              var monthLabelRow = this.buildDateRow();
              monthLabelRow.appendChild(monthLabelCell);
              monthBody.insertBefore(monthLabelRow, row);
              if (isFinalMonth) {
                return monthBody;
              }
            } else {
              blankCellOffset = 2;
              monthLabelCell.setAttribute('colspan', '2');
              row.appendChild(monthLabelCell);
            }
            for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {
              row.appendChild(this.buildDateCell());
            }
            var dayOfWeek = firstDayOfTheWeek;
            var iterationDate = firstDayOfMonth;
            for (var d = 1; d <= numberOfDaysInMonth; d++) {
              if (dayOfWeek === 7) {
                if (isFinalMonth) {
                  return monthBody;
                }
                dayOfWeek = 0;
                rowNumber++;
                row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
              }
              iterationDate.setDate(d);
              var cell = this.buildDateCell(iterationDate);
              row.appendChild(cell);
              dayOfWeek++;
            }
            while (row.childNodes.length < 7) {
              row.appendChild(this.buildDateCell());
            }
            while (monthBody.childNodes.length < 6) {
              var whitespaceRow = this.buildDateRow();
              for (var i = 0; i < 7; i++) {
                whitespaceRow.appendChild(this.buildDateCell());
              }
              monthBody.appendChild(whitespaceRow);
            }
            return monthBody;
          };
          CalendarMonthCtrl.prototype.getLocaleDay_ = function(date) {
            return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').config(["$provide", function($provide) {
            function DateLocaleProvider() {
              this.months = null;
              this.shortMonths = null;
              this.days = null;
              this.shortDays = null;
              this.dates = null;
              this.firstDayOfWeek = 0;
              this.formatDate = null;
              this.parseDate = null;
              this.monthHeaderFormatter = null;
              this.weekNumberFormatter = null;
              this.longDateFormatter = null;
              this.msgCalendar = '';
              this.msgOpenCalendar = '';
            }
            DateLocaleProvider.prototype.$get = function($locale) {
              function defaultFormatDate(date) {
                if (!date) {
                  return '';
                }
                var localeTime = date.toLocaleTimeString();
                var formatDate = date;
                if (date.getHours() == 0 && (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {
                  formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);
                }
                return formatDate.toLocaleDateString();
              }
              function defaultParseDate(dateString) {
                return new Date(dateString);
              }
              function defaultIsDateComplete(dateString) {
                dateString = dateString.trim();
                var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                return re.test(dateString);
              }
              function defaultMonthHeaderFormatter(date) {
                return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();
              }
              function defaultWeekNumberFormatter(number) {
                return 'Week ' + number;
              }
              function defaultLongDateFormatter(date) {
                return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(' ');
              }
              var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                return day[0];
              });
              var defaultDates = Array(32);
              for (var i = 1; i <= 31; i++) {
                defaultDates[i] = i;
              }
              var defaultMsgCalendar = 'Calendar';
              var defaultMsgOpenCalendar = 'Open calendar';
              var service = {
                months: this.months || $locale.DATETIME_FORMATS.MONTH,
                shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                days: this.days || $locale.DATETIME_FORMATS.DAY,
                shortDays: this.shortDays || defaultShortDays,
                dates: this.dates || defaultDates,
                firstDayOfWeek: this.firstDayOfWeek || 0,
                formatDate: this.formatDate || defaultFormatDate,
                parseDate: this.parseDate || defaultParseDate,
                isDateComplete: this.isDateComplete || defaultIsDateComplete,
                monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                msgCalendar: this.msgCalendar || defaultMsgCalendar,
                msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
              };
              return service;
            };
            DateLocaleProvider.prototype.$get.$inject = ["$locale"];
            $provide.provider('$mdDateLocale', new DateLocaleProvider());
          }]);
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdDatepicker', datePickerDirective);
          function datePickerDirective() {
            return {
              template: '<md-button class="md-datepicker-button md-icon-button" type="button" ' + 'tabindex="-1" aria-hidden="true" ' + 'ng-click="ctrl.openCalendarPane($event)">' + '<md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"></md-icon>' + '</md-button>' + '<div class="md-datepicker-input-container" ' + 'ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' + '<input class="md-datepicker-input" aria-haspopup="true" ' + 'ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)">' + '<md-button type="button" md-no-ink ' + 'class="md-datepicker-triangle-button md-icon-button" ' + 'ng-click="ctrl.openCalendarPane($event)" ' + 'aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}">' + '<div class="md-datepicker-expand-triangle"></div>' + '</md-button>' + '</div>' + '<div class="md-datepicker-calendar-pane md-whiteframe-z1">' + '<div class="md-datepicker-input-mask">' + '<div class="md-datepicker-input-mask-opaque"></div>' + '</div>' + '<div class="md-datepicker-calendar">' + '<md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" ' + 'md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"' + 'md-date-filter="ctrl.dateFilter"' + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' + '</md-calendar>' + '</div>' + '</div>',
              require: ['ngModel', 'mdDatepicker', '?^mdInputContainer'],
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                placeholder: '@mdPlaceholder',
                dateFilter: '=mdDateFilter'
              },
              controller: DatePickerCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attr, controllers) {
                var ngModelCtrl = controllers[0];
                var mdDatePickerCtrl = controllers[1];
                var mdInputContainer = controllers[2];
                if (mdInputContainer) {
                  throw Error('md-datepicker should not be placed inside md-input-container.');
                }
                mdDatePickerCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var EXTRA_INPUT_SIZE = 3;
          var INVALID_CLASS = 'md-datepicker-invalid';
          var DEFAULT_DEBOUNCE_INTERVAL = 500;
          var CALENDAR_PANE_HEIGHT = 368;
          var CALENDAR_PANE_WIDTH = 360;
          function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
            this.$compile = $compile;
            this.$timeout = $timeout;
            this.$window = $window;
            this.dateLocale = $mdDateLocale;
            this.dateUtil = $$mdDateUtil;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$$rAF = $$rAF;
            this.documentElement = angular.element(document.documentElement);
            this.ngModelCtrl = null;
            this.inputElement = $element[0].querySelector('input');
            this.ngInputElement = angular.element(this.inputElement);
            this.inputContainer = $element[0].querySelector('.md-datepicker-input-container');
            this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane');
            this.calendarButton = $element[0].querySelector('.md-datepicker-button');
            this.inputMask = $element[0].querySelector('.md-datepicker-input-mask-opaque');
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
            this.date = null;
            this.isFocused = false;
            this.isDisabled;
            this.setDisabled($element[0].disabled || angular.isString($attrs['disabled']));
            this.isCalendarOpen = false;
            this.calendarPaneOpenedFrom = null;
            this.calendarPane.id = 'md-date-pane' + $mdUtil.nextUid();
            $mdTheming($element);
            this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
            this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            this.installPropertyInterceptors();
            this.attachChangeListeners();
            this.attachInteractionListeners();
            var self = this;
            $scope.$on('$destroy', function() {
              self.detachCalendarPane();
            });
          }
          DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF"];
          DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              var value = self.ngModelCtrl.$viewValue;
              if (value && !(value instanceof Date)) {
                throw Error('The ng-model for md-datepicker must be a Date instance. ' + 'Currently the model is a: ' + (typeof value));
              }
              self.date = value;
              self.inputElement.value = self.dateLocale.formatDate(value);
              self.resizeInputElement();
              self.updateErrorState();
            };
          };
          DatePickerCtrl.prototype.attachChangeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-change', function(event, date) {
              self.ngModelCtrl.$setViewValue(date);
              self.date = date;
              self.inputElement.value = self.dateLocale.formatDate(date);
              self.closeCalendarPane();
              self.resizeInputElement();
              self.updateErrorState();
            });
            self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement));
            self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
          };
          DatePickerCtrl.prototype.attachInteractionListeners = function() {
            var self = this;
            var $scope = this.$scope;
            var keyCodes = this.$mdConstant.KEY_CODE;
            self.ngInputElement.on('keydown', function(event) {
              if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                self.openCalendarPane(event);
                $scope.$digest();
              }
            });
            $scope.$on('md-calendar-close', function() {
              self.closeCalendarPane();
            });
          };
          DatePickerCtrl.prototype.installPropertyInterceptors = function() {
            var self = this;
            if (this.$attrs['ngDisabled']) {
              var scope = this.$scope.$parent;
              if (scope) {
                scope.$watch(this.$attrs['ngDisabled'], function(isDisabled) {
                  self.setDisabled(isDisabled);
                });
              }
            }
            Object.defineProperty(this, 'placeholder', {
              get: function() {
                return self.inputElement.placeholder;
              },
              set: function(value) {
                self.inputElement.placeholder = value || '';
              }
            });
          };
          DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
            this.isDisabled = isDisabled;
            this.inputElement.disabled = isDisabled;
            this.calendarButton.disabled = isDisabled;
          };
          DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
            var date = opt_date || this.date;
            this.clearErrorState();
            if (this.dateUtil.isValidDate(date)) {
              date = this.dateUtil.createDateAtMidnight(date);
              if (this.dateUtil.isValidDate(this.minDate)) {
                var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                this.ngModelCtrl.$setValidity('mindate', date >= minDate);
              }
              if (this.dateUtil.isValidDate(this.maxDate)) {
                var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                this.ngModelCtrl.$setValidity('maxdate', date <= maxDate);
              }
              if (angular.isFunction(this.dateFilter)) {
                this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));
              }
            } else {
              this.ngModelCtrl.$setValidity('valid', date == null);
            }
            if (!this.ngModelCtrl.$valid) {
              this.inputContainer.classList.add(INVALID_CLASS);
            }
          };
          DatePickerCtrl.prototype.clearErrorState = function() {
            this.inputContainer.classList.remove(INVALID_CLASS);
            ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function(field) {
              this.ngModelCtrl.$setValidity(field, true);
            }, this);
          };
          DatePickerCtrl.prototype.resizeInputElement = function() {
            this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
          };
          DatePickerCtrl.prototype.handleInputEvent = function() {
            var inputString = this.inputElement.value;
            var parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
            this.dateUtil.setDateTimeToMidnight(parsedDate);
            var isValidInput = inputString == '' || (this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate));
            if (isValidInput) {
              this.ngModelCtrl.$setViewValue(parsedDate);
              this.date = parsedDate;
            }
            this.updateErrorState(parsedDate);
          };
          DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
          };
          DatePickerCtrl.prototype.attachCalendarPane = function() {
            var calendarPane = this.calendarPane;
            calendarPane.style.transform = '';
            this.$element.addClass('md-datepicker-open');
            var elementRect = this.inputContainer.getBoundingClientRect();
            var bodyRect = document.body.getBoundingClientRect();
            var paneTop = elementRect.top - bodyRect.top;
            var paneLeft = elementRect.left - bodyRect.left;
            var viewportTop = (bodyRect.top < 0 && document.body.scrollTop == 0) ? -bodyRect.top : document.body.scrollTop;
            var viewportLeft = (bodyRect.left < 0 && document.body.scrollLeft == 0) ? -bodyRect.left : document.body.scrollLeft;
            var viewportBottom = viewportTop + this.$window.innerHeight;
            var viewportRight = viewportLeft + this.$window.innerWidth;
            if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
              if (viewportRight - CALENDAR_PANE_WIDTH > 0) {
                paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
              } else {
                paneLeft = viewportLeft;
                var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                calendarPane.style.transform = 'scale(' + scale + ')';
              }
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
              paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            calendarPane.style.left = paneLeft + 'px';
            calendarPane.style.top = paneTop + 'px';
            document.body.appendChild(calendarPane);
            this.inputMask.style.left = elementRect.width + 'px';
            this.$$rAF(function() {
              calendarPane.classList.add('md-pane-open');
            });
          };
          DatePickerCtrl.prototype.detachCalendarPane = function() {
            this.$element.removeClass('md-datepicker-open');
            this.calendarPane.classList.remove('md-pane-open');
            this.calendarPane.classList.remove('md-datepicker-pos-adjusted');
            if (this.calendarPane.parentNode) {
              this.calendarPane.parentNode.removeChild(this.calendarPane);
            }
          };
          DatePickerCtrl.prototype.openCalendarPane = function(event) {
            if (!this.isCalendarOpen && !this.isDisabled) {
              this.isCalendarOpen = true;
              this.calendarPaneOpenedFrom = event.target;
              this.$mdUtil.disableScrollAround(this.calendarPane);
              this.attachCalendarPane();
              this.focusCalendar();
              var self = this;
              this.$mdUtil.nextTick(function() {
                self.documentElement.on('click touchstart', self.bodyClickHandler);
              }, false);
              window.addEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.closeCalendarPane = function() {
            if (this.isCalendarOpen) {
              this.isCalendarOpen = false;
              this.detachCalendarPane();
              this.calendarPaneOpenedFrom.focus();
              this.calendarPaneOpenedFrom = null;
              this.$mdUtil.enableScrolling();
              this.ngModelCtrl.$setTouched();
              this.documentElement.off('click touchstart', this.bodyClickHandler);
              window.removeEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.getCalendarCtrl = function() {
            return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');
          };
          DatePickerCtrl.prototype.focusCalendar = function() {
            var self = this;
            this.$mdUtil.nextTick(function() {
              self.getCalendarCtrl().focus();
            }, false);
          };
          DatePickerCtrl.prototype.setFocused = function(isFocused) {
            if (!isFocused) {
              this.ngModelCtrl.$setTouched();
            }
            this.isFocused = isFocused;
          };
          DatePickerCtrl.prototype.handleBodyClick = function(event) {
            if (this.isCalendarOpen) {
              var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar');
              if (!isInCalendar) {
                this.closeCalendarPane();
              }
              this.$scope.$digest();
            }
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').factory('$$mdDateUtil', function() {
            return {
              getFirstDateOfMonth: getFirstDateOfMonth,
              getNumberOfDaysInMonth: getNumberOfDaysInMonth,
              getDateInNextMonth: getDateInNextMonth,
              getDateInPreviousMonth: getDateInPreviousMonth,
              isInNextMonth: isInNextMonth,
              isInPreviousMonth: isInPreviousMonth,
              getDateMidpoint: getDateMidpoint,
              isSameMonthAndYear: isSameMonthAndYear,
              getWeekOfMonth: getWeekOfMonth,
              incrementDays: incrementDays,
              incrementMonths: incrementMonths,
              getLastDateOfMonth: getLastDateOfMonth,
              isSameDay: isSameDay,
              getMonthDistance: getMonthDistance,
              isValidDate: isValidDate,
              setDateTimeToMidnight: setDateTimeToMidnight,
              createDateAtMidnight: createDateAtMidnight,
              isDateWithinRange: isDateWithinRange
            };
            function getFirstDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), 1);
            }
            function getNumberOfDaysInMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            }
            function getDateInNextMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 1);
            }
            function getDateInPreviousMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() - 1, 1);
            }
            function isSameMonthAndYear(d1, d2) {
              return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
            }
            function isSameDay(d1, d2) {
              return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
            }
            function isInNextMonth(startDate, endDate) {
              var nextMonth = getDateInNextMonth(startDate);
              return isSameMonthAndYear(nextMonth, endDate);
            }
            function isInPreviousMonth(startDate, endDate) {
              var previousMonth = getDateInPreviousMonth(startDate);
              return isSameMonthAndYear(endDate, previousMonth);
            }
            function getDateMidpoint(d1, d2) {
              return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
            }
            function getWeekOfMonth(date) {
              var firstDayOfMonth = getFirstDateOfMonth(date);
              return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
            }
            function incrementDays(date, numberOfDays) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
            }
            function incrementMonths(date, numberOfMonths) {
              var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
              var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
              if (numberOfDaysInMonth < date.getDate()) {
                dateInTargetMonth.setDate(numberOfDaysInMonth);
              } else {
                dateInTargetMonth.setDate(date.getDate());
              }
              return dateInTargetMonth;
            }
            function getMonthDistance(start, end) {
              return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
            }
            function getLastDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
            }
            function isValidDate(date) {
              return date != null && date.getTime && !isNaN(date.getTime());
            }
            function setDateTimeToMidnight(date) {
              if (isValidDate(date)) {
                date.setHours(0, 0, 0, 0);
              }
            }
            function createDateAtMidnight(opt_value) {
              var date;
              if (angular.isUndefined(opt_value)) {
                date = new Date();
              } else {
                date = new Date(opt_value);
              }
              setDateTimeToMidnight(date);
              return date;
            }
            function isDateWithinRange(date, minDate, maxDate) {
              var dateAtMidnight = createDateAtMidnight(date);
              var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null;
              var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
              return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
            }
          });
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.content', ['material.core']).directive('mdContent', mdContentDirective);
        function mdContentDirective($mdTheming) {
          return {
            restrict: 'E',
            controller: ['$scope', '$element', ContentController],
            link: function(scope, element, attr) {
              var node = element[0];
              $mdTheming(element);
              scope.$broadcast('$mdContentLoaded', element);
              iosScrollFix(element[0]);
            }
          };
          function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }
        }
        mdContentDirective.$inject = ["$mdTheming"];
        function iosScrollFix(node) {
          angular.element(node).on('$md.pressdown', function(ev) {
            if (ev.pointer.type !== 't')
              return;
            if (ev.$materialScrollFixed)
              return;
            ev.$materialScrollFixed = true;
            if (node.scrollTop === 0) {
              node.scrollTop = 1;
            } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
              node.scrollTop -= 1;
            }
          });
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabActions', ['material.core']).directive('mdFabActions', MdFabActionsDirective);
          function MdFabActionsDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],
              compile: function(element, attributes) {
                var children = element.children();
                var hasNgRepeat = false;
                angular.forEach(['', 'data-', 'x-'], function(prefix) {
                  hasNgRepeat = hasNgRepeat || (children.attr(prefix + 'ng-repeat') ? true : false);
                });
                if (hasNgRepeat) {
                  children.addClass('md-fab-action-item');
                } else {
                  children.wrap('<div class="md-fab-action-item">');
                }
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabShared', ['material.core']).controller('FabController', FabController);
          function FabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
            var vm = this;
            vm.open = function() {
              $scope.$evalAsync("vm.isOpen = true");
            };
            vm.close = function() {
              $scope.$evalAsync("vm.isOpen = false");
              $element.find('md-fab-trigger')[0].focus();
            };
            vm.toggle = function() {
              $scope.$evalAsync("vm.isOpen = !vm.isOpen");
            };
            setupDefaults();
            setupListeners();
            setupWatchers();
            var initialAnimationAttempts = 0;
            fireInitialAnimations();
            function setupDefaults() {
              vm.direction = vm.direction || 'down';
              vm.isOpen = vm.isOpen || false;
              resetActionIndex();
              $element.addClass('md-animations-waiting');
            }
            function setupListeners() {
              var eventTypes = ['click', 'focusin', 'focusout'];
              angular.forEach(eventTypes, function(eventType) {
                $element.on(eventType, parseEvents);
              });
              $scope.$on('$destroy', function() {
                angular.forEach(eventTypes, function(eventType) {
                  $element.off(eventType, parseEvents);
                });
                disableKeyboard();
              });
            }
            var closeTimeout;
            function parseEvents(event) {
              if (event.type == 'click') {
                handleItemClick(event);
              }
              if (event.type == 'focusout' && !closeTimeout) {
                closeTimeout = $timeout(function() {
                  vm.close();
                }, 100, false);
              }
              if (event.type == 'focusin' && closeTimeout) {
                $timeout.cancel(closeTimeout);
                closeTimeout = null;
              }
            }
            function resetActionIndex() {
              vm.currentActionIndex = -1;
            }
            function setupWatchers() {
              $scope.$watch('vm.direction', function(newDir, oldDir) {
                $animate.removeClass($element, 'md-' + oldDir);
                $animate.addClass($element, 'md-' + newDir);
                resetActionIndex();
              });
              var trigger,
                  actions;
              $scope.$watch('vm.isOpen', function(isOpen) {
                resetActionIndex();
                if (!trigger || !actions) {
                  trigger = getTriggerElement();
                  actions = getActionsElement();
                }
                if (isOpen) {
                  enableKeyboard();
                } else {
                  disableKeyboard();
                }
                var toAdd = isOpen ? 'md-is-open' : '';
                var toRemove = isOpen ? '' : 'md-is-open';
                trigger.attr('aria-haspopup', true);
                trigger.attr('aria-expanded', isOpen);
                actions.attr('aria-hidden', !isOpen);
                $animate.setClass($element, toAdd, toRemove);
              });
            }
            function fireInitialAnimations() {
              if ($element[0].scrollHeight > 0) {
                $animate.addClass($element, 'md-animations-ready').then(function() {
                  $element.removeClass('md-animations-waiting');
                });
              } else if (initialAnimationAttempts < 10) {
                $timeout(fireInitialAnimations, 100);
                initialAnimationAttempts = initialAnimationAttempts + 1;
              }
            }
            function enableKeyboard() {
              $element.on('keydown', keyPressed);
              $mdUtil.nextTick(function() {
                angular.element(document).on('click touchend', checkForOutsideClick);
              });
            }
            function disableKeyboard() {
              $element.off('keydown', keyPressed);
              angular.element(document).off('click touchend', checkForOutsideClick);
            }
            function checkForOutsideClick(event) {
              if (event.target) {
                var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger');
                var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions');
                if (!closestTrigger && !closestActions) {
                  vm.close();
                }
              }
            }
            function keyPressed(event) {
              switch (event.which) {
                case $mdConstant.KEY_CODE.ESCAPE:
                  vm.close();
                  event.preventDefault();
                  return false;
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                  doKeyLeft(event);
                  return false;
                case $mdConstant.KEY_CODE.UP_ARROW:
                  doKeyUp(event);
                  return false;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  doKeyRight(event);
                  return false;
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  doKeyDown(event);
                  return false;
              }
            }
            function doActionPrev(event) {
              focusAction(event, -1);
            }
            function doActionNext(event) {
              focusAction(event, 1);
            }
            function focusAction(event, direction) {
              var actions = resetActionTabIndexes();
              vm.currentActionIndex = vm.currentActionIndex + direction;
              vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
              vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
              var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
              angular.element(focusElement).attr('tabindex', 0);
              focusElement.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
            function resetActionTabIndexes() {
              var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item');
              angular.forEach(actions, function(action) {
                angular.element(angular.element(action).children()[0]).attr('tabindex', -1);
              });
              return actions;
            }
            function doKeyLeft(event) {
              if (vm.direction === 'left') {
                doActionNext(event);
              } else {
                doActionPrev(event);
              }
            }
            function doKeyUp(event) {
              if (vm.direction === 'down') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyRight(event) {
              if (vm.direction === 'left') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyDown(event) {
              if (vm.direction === 'up') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function isTrigger(element) {
              return $mdUtil.getClosest(element, 'md-fab-trigger');
            }
            function isAction(element) {
              return $mdUtil.getClosest(element, 'md-fab-actions');
            }
            function handleItemClick(event) {
              if (isTrigger(event.target)) {
                vm.toggle();
              }
              if (isAction(event.target)) {
                vm.close();
              }
            }
            function getTriggerElement() {
              return $element.find('md-fab-trigger');
            }
            function getActionsElement() {
              return $element.find('md-fab-actions');
            }
          }
          FabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var cssAnimationDuration = 300;
          angular.module('material.components.fabSpeedDial', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabSpeedDial', MdFabSpeedDialDirective).animation('.md-fling', MdFabSpeedDialFlingAnimation).animation('.md-scale', MdFabSpeedDialScaleAnimation).service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation).service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation);
          function MdFabSpeedDialDirective() {
            return {
              restrict: 'E',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: FabSpeedDialLink
            };
            function FabSpeedDialLink(scope, element) {
              element.prepend('<div class="md-css-variables"></div>');
            }
          }
          function MdFabSpeedDialFlingAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            function runAnimation(element) {
              if (element.hasClass('md-animations-waiting') && !element.hasClass('md-animations-ready')) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var triggerElement = el.querySelector('md-fab-trigger');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style;
                styles.transform = styles.webkitTransform = '';
                styles.transitionDelay = '';
                styles.opacity = 1;
                styles.zIndex = (items.length - index) + startZIndex;
              });
              triggerElement.style.zIndex = startZIndex + items.length + 1;
              if (!ctrl.isOpen) {
                angular.forEach(items, function(item, index) {
                  var newPosition,
                      axis;
                  var styles = item.style;
                  var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
                  var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                  switch (ctrl.direction) {
                    case 'up':
                      newPosition = (item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'down':
                      newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'left':
                      newPosition = (item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                    case 'right':
                      newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                  }
                  var newTranslate = 'translate' + axis + '(' + newPosition + 'px)';
                  styles.transform = styles.webkitTransform = newTranslate;
                });
              }
            }
            return {
              addClass: function(element, className, done) {
                if (element.hasClass('md-fling')) {
                  runAnimation(element);
                  delayDone(done);
                } else {
                  done();
                }
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
          function MdFabSpeedDialScaleAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            var delay = 65;
            function runAnimation(element) {
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style,
                    offsetDelay = index * delay;
                styles.opacity = ctrl.isOpen ? 1 : 0;
                styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';
                styles.transitionDelay = (ctrl.isOpen ? offsetDelay : (items.length - offsetDelay)) + 'ms';
                styles.zIndex = (items.length - index) + startZIndex;
              });
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabToolbar', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabToolbar', MdFabToolbarDirective).animation('.md-fab-toolbar', MdFabToolbarAnimation).service('mdFabToolbarAnimation', MdFabToolbarAnimation);
          function MdFabToolbarDirective() {
            return {
              restrict: 'E',
              transclude: true,
              template: '<div class="md-fab-toolbar-wrapper">' + '  <div class="md-fab-toolbar-content" ng-transclude></div>' + '</div>',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: link
            };
            function link(scope, element, attributes) {
              element.addClass('md-fab-toolbar');
              element.find('md-fab-trigger').find('button').prepend('<div class="md-fab-toolbar-background"></div>');
            }
          }
          function MdFabToolbarAnimation() {
            function runAnimation(element, className, done) {
              if (!className) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabToolbar');
              var backgroundElement = el.querySelector('.md-fab-toolbar-background');
              var triggerElement = el.querySelector('md-fab-trigger button');
              var toolbarElement = el.querySelector('md-toolbar');
              var iconElement = el.querySelector('md-fab-trigger button md-icon');
              var actions = element.find('md-fab-actions').children();
              if (triggerElement && backgroundElement) {
                var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');
                var width = el.offsetWidth;
                var height = el.offsetHeight;
                var scale = 2 * (width / triggerElement.offsetWidth);
                backgroundElement.style.backgroundColor = color;
                backgroundElement.style.borderRadius = width + 'px';
                if (ctrl.isOpen) {
                  toolbarElement.style.pointerEvents = 'initial';
                  backgroundElement.style.width = triggerElement.offsetWidth + 'px';
                  backgroundElement.style.height = triggerElement.offsetHeight + 'px';
                  backgroundElement.style.transform = 'scale(' + scale + ')';
                  backgroundElement.style.transitionDelay = '0ms';
                  iconElement && (iconElement.style.transitionDelay = '.3s');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = (actions.length - index) * 25 + 'ms';
                  });
                } else {
                  toolbarElement.style.pointerEvents = 'none';
                  backgroundElement.style.transform = 'scale(1)';
                  backgroundElement.style.top = '0';
                  if (element.hasClass('md-right')) {
                    backgroundElement.style.left = '0';
                    backgroundElement.style.right = null;
                  }
                  if (element.hasClass('md-left')) {
                    backgroundElement.style.right = '0';
                    backgroundElement.style.left = null;
                  }
                  backgroundElement.style.transitionDelay = '200ms';
                  iconElement && (iconElement.style.transitionDelay = '0ms');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = 200 + (index * 25) + 'ms';
                  });
                }
              }
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              },
              removeClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.gridList', ['material.core']).directive('mdGridList', GridListDirective).directive('mdGridTile', GridTileDirective).directive('mdGridTileFooter', GridTileCaptionDirective).directive('mdGridTileHeader', GridTileCaptionDirective).factory('$mdGridLayout', GridLayoutFactory);
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
          return {
            restrict: 'E',
            controller: GridListController,
            scope: {mdOnLayout: '&'},
            link: postLink
          };
          function postLink(scope, element, attrs, ctrl) {
            element.attr('role', 'list');
            ctrl.layoutDelegate = layoutDelegate;
            var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
                unwatchAttrs = watchMedia();
            scope.$on('$destroy', unwatchMedia);
            function watchMedia() {
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia(mediaName);
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
              }
              return $mdMedia.watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);
            }
            function unwatchMedia() {
              ctrl.layoutDelegate = angular.noop;
              unwatchAttrs();
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
              }
            }
            function layoutIfMediaMatch(mediaName) {
              if (mediaName == null) {
                ctrl.invalidateLayout();
              } else if ($mdMedia(mediaName)) {
                ctrl.invalidateLayout();
              }
            }
            var lastLayoutProps;
            function layoutDelegate(tilesInvalidated) {
              var tiles = getTileElements();
              var props = {
                tileSpans: getTileSpans(tiles),
                colCount: getColumnCount(),
                rowMode: getRowMode(),
                rowHeight: getRowHeight(),
                gutter: getGutter()
              };
              if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {
                return;
              }
              var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                return {
                  grid: {
                    element: element,
                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                  },
                  tiles: tilePositions.map(function(ps, i) {
                    return {
                      element: angular.element(tiles[i]),
                      style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                    };
                  })
                };
              }).reflow().performance();
              scope.mdOnLayout({$event: {performance: performance}});
              lastLayoutProps = props;
            }
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            function expr(exprStr) {
              return startSymbol + exprStr + endSymbol;
            }
            var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');
            var POSITION = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');
            var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');
            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
              var hShare = (1 / colCount) * 100;
              var hGutterShare = (colCount - 1) / colCount;
              var hUnit = UNIT({
                share: hShare,
                gutterShare: hGutterShare,
                gutter: gutter
              });
              var style = {
                left: POSITION({
                  unit: hUnit,
                  offset: position.col,
                  gutter: gutter
                }),
                width: DIMENSION({
                  unit: hUnit,
                  span: spans.col,
                  gutter: gutter
                }),
                paddingTop: '',
                marginTop: '',
                top: '',
                height: ''
              };
              switch (rowMode) {
                case 'fixed':
                  style.top = POSITION({
                    unit: rowHeight,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
                case 'ratio':
                  var vShare = hShare / rowHeight;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: hGutterShare,
                    gutter: gutter
                  });
                  style.paddingTop = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  style.marginTop = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  var vGutterShare = (rowCount - 1) / rowCount;
                  var vShare = (1 / rowCount) * 100;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: vGutterShare,
                    gutter: gutter
                  });
                  style.top = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
              }
              return style;
            }
            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
              var style = {};
              switch (rowMode) {
                case 'fixed':
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: rowCount,
                    gutter: gutter
                  });
                  style.paddingBottom = '';
                  break;
                case 'ratio':
                  var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
                      hShare = (1 / colCount) * 100,
                      vShare = hShare * (1 / rowHeight),
                      vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                      });
                  style.height = '';
                  style.paddingBottom = DIMENSION({
                    unit: vUnit,
                    span: rowCount,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  break;
              }
              return style;
            }
            function getTileElements() {
              return [].filter.call(element.children(), function(ele) {
                return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;
              });
            }
            function getTileSpans(tileElements) {
              return [].map.call(tileElements, function(ele) {
                var ctrl = angular.element(ele).controller('mdGridTile');
                return {
                  row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,
                  col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1
                };
              });
            }
            function getColumnCount() {
              var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);
              if (isNaN(colCount)) {
                throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';
              }
              return colCount;
            }
            function getGutter() {
              return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);
            }
            function getRowHeight() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              switch (getRowMode()) {
                case 'fixed':
                  return applyDefaultUnit(rowHeight);
                case 'ratio':
                  var whRatio = rowHeight.split(':');
                  return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
                case 'fit':
                  return 0;
              }
            }
            function getRowMode() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              if (rowHeight == 'fit') {
                return 'fit';
              } else if (rowHeight.indexOf(':') !== -1) {
                return 'ratio';
              } else {
                return 'fixed';
              }
            }
            function applyDefaultUnit(val) {
              return /\D$/.test(val) ? val : val + 'px';
            }
          }
        }
        GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
        function GridListController($mdUtil) {
          this.layoutInvalidated = false;
          this.tilesInvalidated = false;
          this.$timeout_ = $mdUtil.nextTick;
          this.layoutDelegate = angular.noop;
        }
        GridListController.$inject = ["$mdUtil"];
        GridListController.prototype = {
          invalidateTiles: function() {
            this.tilesInvalidated = true;
            this.invalidateLayout();
          },
          invalidateLayout: function() {
            if (this.layoutInvalidated) {
              return;
            }
            this.layoutInvalidated = true;
            this.$timeout_(angular.bind(this, this.layout));
          },
          layout: function() {
            try {
              this.layoutDelegate(this.tilesInvalidated);
            } finally {
              this.layoutInvalidated = false;
              this.tilesInvalidated = false;
            }
          }
        };
        function GridLayoutFactory($mdUtil) {
          var defaultAnimator = GridTileAnimator;
          GridLayout.animateWith = function(customAnimator) {
            defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
          };
          return GridLayout;
          function GridLayout(colCount, tileSpans) {
            var self,
                layoutInfo,
                gridStyles,
                layoutTime,
                mapTime,
                reflowTime;
            layoutTime = $mdUtil.time(function() {
              layoutInfo = calculateGridFor(colCount, tileSpans);
            });
            return self = {
              layoutInfo: function() {
                return layoutInfo;
              },
              map: function(updateFn) {
                mapTime = $mdUtil.time(function() {
                  var info = self.layoutInfo();
                  gridStyles = updateFn(info.positioning, info.rowCount);
                });
                return self;
              },
              reflow: function(animatorFn) {
                reflowTime = $mdUtil.time(function() {
                  var animator = animatorFn || defaultAnimator;
                  animator(gridStyles.grid, gridStyles.tiles);
                });
                return self;
              },
              performance: function() {
                return {
                  tileCount: tileSpans.length,
                  layoutTime: layoutTime,
                  mapTime: mapTime,
                  reflowTime: reflowTime,
                  totalTime: layoutTime + mapTime + reflowTime
                };
              }
            };
          }
          function GridTileAnimator(grid, tiles) {
            grid.element.css(grid.style);
            tiles.forEach(function(t) {
              t.element.css(t.style);
            });
          }
          function calculateGridFor(colCount, tileSpans) {
            var curCol = 0,
                curRow = 0,
                spaceTracker = newSpaceTracker();
            return {
              positioning: tileSpans.map(function(spans, i) {
                return {
                  spans: spans,
                  position: reserveSpace(spans, i)
                };
              }),
              rowCount: curRow + Math.max.apply(Math, spaceTracker)
            };
            function reserveSpace(spans, i) {
              if (spans.col > colCount) {
                throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' + '(' + spans.col + ') that exceeds the column count ' + '(' + colCount + ')';
              }
              var start = 0,
                  end = 0;
              while (end - start < spans.col) {
                if (curCol >= colCount) {
                  nextRow();
                  continue;
                }
                start = spaceTracker.indexOf(0, curCol);
                if (start === -1 || (end = findEnd(start + 1)) === -1) {
                  start = end = 0;
                  nextRow();
                  continue;
                }
                curCol = end + 1;
              }
              adjustRow(start, spans.col, spans.row);
              curCol = start + spans.col;
              return {
                col: start,
                row: curRow
              };
            }
            function nextRow() {
              curCol = 0;
              curRow++;
              adjustRow(0, colCount, -1);
            }
            function adjustRow(from, cols, by) {
              for (var i = from; i < from + cols; i++) {
                spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
              }
            }
            function findEnd(start) {
              var i;
              for (i = start; i < spaceTracker.length; i++) {
                if (spaceTracker[i] !== 0) {
                  return i;
                }
              }
              if (i === spaceTracker.length) {
                return i;
              }
            }
            function newSpaceTracker() {
              var tracker = [];
              for (var i = 0; i < colCount; i++) {
                tracker.push(0);
              }
              return tracker;
            }
          }
        }
        GridLayoutFactory.$inject = ["$mdUtil"];
        function GridTileDirective($mdMedia) {
          return {
            restrict: 'E',
            require: '^mdGridList',
            template: '<figure ng-transclude></figure>',
            transclude: true,
            scope: {},
            controller: ["$attrs", function($attrs) {
              this.$attrs = $attrs;
            }],
            link: postLink
          };
          function postLink(scope, element, attrs, gridCtrl) {
            element.attr('role', 'listitem');
            var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
            gridCtrl.invalidateTiles();
            scope.$on('$destroy', function() {
              element[0].$$mdDestroyed = true;
              unwatchAttrs();
              gridCtrl.invalidateLayout();
            });
            if (angular.isDefined(scope.$parent.$index)) {
              scope.$watch(function() {
                return scope.$parent.$index;
              }, function indexChanged(newIdx, oldIdx) {
                if (newIdx === oldIdx) {
                  return;
                }
                gridCtrl.invalidateTiles();
              });
            }
          }
        }
        GridTileDirective.$inject = ["$mdMedia"];
        function GridTileCaptionDirective() {
          return {
            template: '<figcaption ng-transclude></figcaption>',
            transclude: true
          };
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabTrigger', ['material.core']).directive('mdFabTrigger', MdFabTriggerDirective);
          function MdFabTriggerDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar']
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon', ['material.core']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.input', ['material.core']).directive('mdInputContainer', mdInputContainerDirective).directive('label', labelDirective).directive('input', inputTextareaDirective).directive('textarea', inputTextareaDirective).directive('mdMaxlength', mdMaxlengthDirective).directive('placeholder', placeholderDirective).directive('ngMessages', ngMessagesDirective).directive('ngMessage', ngMessageDirective).directive('ngMessageExp', ngMessageDirective).directive('mdSelectOnFocus', mdSelectOnFocusDirective).animation('.md-input-invalid', mdInputInvalidMessagesAnimation).animation('.md-input-messages-animation', ngMessagesAnimation).animation('.md-input-message-animation', ngMessageAnimation);
        function mdInputContainerDirective($mdTheming, $parse) {
          ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
          return {
            restrict: 'E',
            link: postLink,
            controller: ContainerCtrl
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            if (element.find('md-icon').length)
              element.addClass('md-has-icon');
          }
          function ContainerCtrl($scope, $element, $attrs, $animate) {
            var self = this;
            self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
            self.delegateClick = function() {
              self.input.focus();
            };
            self.element = $element;
            self.setFocused = function(isFocused) {
              $element.toggleClass('md-input-focused', !!isFocused);
            };
            self.setHasValue = function(hasValue) {
              $element.toggleClass('md-input-has-value', !!hasValue);
            };
            self.setHasPlaceholder = function(hasPlaceholder) {
              $element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);
            };
            self.setInvalid = function(isInvalid) {
              if (isInvalid) {
                $animate.addClass($element, 'md-input-invalid');
              } else {
                $animate.removeClass($element, 'md-input-invalid');
              }
            };
            $scope.$watch(function() {
              return self.label && self.input;
            }, function(hasLabelAndInput) {
              if (hasLabelAndInput && !self.label.attr('for')) {
                self.label.attr('for', self.input.attr('id'));
              }
            });
          }
        }
        mdInputContainerDirective.$inject = ["$mdTheming", "$parse"];
        function labelDirective() {
          return {
            restrict: 'E',
            require: '^?mdInputContainer',
            link: function(scope, element, attr, containerCtrl) {
              if (!containerCtrl || attr.mdNoFloat || element.hasClass('md-container-ignore'))
                return;
              containerCtrl.label = element;
              scope.$on('$destroy', function() {
                containerCtrl.label = null;
              });
            }
          };
        }
        function inputTextareaDirective($mdUtil, $window, $mdAria) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', '?ngModel'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var hasNgModel = !!ctrls[1];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            var isReadonly = angular.isDefined(attr.readonly);
            if (!containerCtrl)
              return;
            if (containerCtrl.input) {
              throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
            }
            containerCtrl.input = element;
            var errorsSpacer = angular.element('<div class="md-errors-spacer">');
            element.after(errorsSpacer);
            if (!containerCtrl.label) {
              $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
            }
            element.addClass('md-input');
            if (!element.attr('id')) {
              element.attr('id', 'input_' + $mdUtil.nextUid());
            }
            if (element[0].tagName.toLowerCase() === 'textarea') {
              setupTextarea();
            }
            if (!hasNgModel) {
              inputCheckValue();
            }
            var isErrorGetter = containerCtrl.isErrorGetter || function() {
              return ngModelCtrl.$invalid && (ngModelCtrl.$touched || isParentFormSubmitted());
            };
            var isParentFormSubmitted = function() {
              var parent = $mdUtil.getClosest(element, 'form');
              var form = parent ? angular.element(parent).controller('form') : null;
              return form ? form.$submitted : false;
            };
            scope.$watch(isErrorGetter, containerCtrl.setInvalid);
            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
            ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
            element.on('input', inputCheckValue);
            if (!isReadonly) {
              element.on('focus', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(true);
                });
              }).on('blur', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(false);
                  inputCheckValue();
                });
              });
            }
            scope.$on('$destroy', function() {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            });
            function ngModelPipelineCheckValue(arg) {
              containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
              return arg;
            }
            function inputCheckValue() {
              containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
            }
            function setupTextarea() {
              if (angular.isDefined(element.attr('md-no-autogrow'))) {
                return;
              }
              var node = element[0];
              var container = containerCtrl.element[0];
              var min_rows = NaN;
              var lineHeight = null;
              if (node.hasAttribute('rows')) {
                min_rows = parseInt(node.getAttribute('rows'));
              }
              var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
              function pipelineListener(value) {
                onChangeTextarea();
                return value;
              }
              if (ngModelCtrl) {
                ngModelCtrl.$formatters.push(pipelineListener);
                ngModelCtrl.$viewChangeListeners.push(pipelineListener);
              } else {
                onChangeTextarea();
              }
              element.on('keydown input', onChangeTextarea);
              if (isNaN(min_rows)) {
                element.attr('rows', '1');
                element.on('scroll', onScroll);
              }
              angular.element($window).on('resize', onChangeTextarea);
              scope.$on('$destroy', function() {
                angular.element($window).off('resize', onChangeTextarea);
              });
              function growTextarea() {
                container.style.height = container.offsetHeight + 'px';
                element.addClass('md-no-flex');
                if (isNaN(min_rows)) {
                  node.style.height = "auto";
                  node.scrollTop = 0;
                  var height = getHeight();
                  if (height)
                    node.style.height = height + 'px';
                } else {
                  node.setAttribute("rows", 1);
                  if (!lineHeight) {
                    node.style.minHeight = '0';
                    lineHeight = element.prop('clientHeight');
                    node.style.minHeight = null;
                  }
                  var rows = Math.min(min_rows, Math.round(node.scrollHeight / lineHeight));
                  node.setAttribute("rows", rows);
                  node.style.height = lineHeight * rows + "px";
                }
                element.removeClass('md-no-flex');
                container.style.height = 'auto';
              }
              function getHeight() {
                var line = node.scrollHeight - node.offsetHeight;
                return node.offsetHeight + (line > 0 ? line : 0);
              }
              function onScroll(e) {
                node.scrollTop = 0;
                var line = node.scrollHeight - node.offsetHeight;
                var height = node.offsetHeight + line;
                node.style.height = height + 'px';
              }
              if (angular.isDefined(element.attr('md-detect-hidden'))) {
                var handleHiddenChange = function() {
                  var wasHidden = false;
                  return function() {
                    var isHidden = node.offsetHeight === 0;
                    if (isHidden === false && wasHidden === true) {
                      growTextarea();
                    }
                    wasHidden = isHidden;
                  };
                }();
                scope.$watch(function() {
                  $mdUtil.nextTick(handleHiddenChange, false);
                  return true;
                });
              }
            }
          }
        }
        inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria"];
        function mdMaxlengthDirective($animate, $mdUtil) {
          return {
            restrict: 'A',
            require: ['ngModel', '^mdInputContainer'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl,
                errorsSpacer;
            $mdUtil.nextTick(function() {
              errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer'));
              charCountEl = angular.element('<div class="md-char-counter">');
              errorsSpacer.append(charCountEl);
              attr.$set('ngTrim', 'false');
              ngModelCtrl.$formatters.push(renderCharCount);
              ngModelCtrl.$viewChangeListeners.push(renderCharCount);
              element.on('input keydown keyup', function() {
                renderCharCount();
              });
              scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                  if (!charCountEl.parent().length) {
                    $animate.enter(charCountEl, errorsSpacer);
                  }
                  renderCharCount();
                } else {
                  $animate.leave(charCountEl);
                }
              });
              ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                  return true;
                }
                return (modelValue || element.val() || viewValue || '').length <= maxlength;
              };
            });
            function renderCharCount(value) {
              if (!charCountEl.parent) {
                return value;
              }
              charCountEl.text(String(element.val() || value || '').length + '/' + maxlength);
              return value;
            }
          }
        }
        mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
        function placeholderDirective($log) {
          return {
            restrict: 'A',
            require: '^^?mdInputContainer',
            priority: 200,
            link: postLink
          };
          function postLink(scope, element, attr, inputContainer) {
            if (!inputContainer)
              return;
            var label = inputContainer.element.find('label');
            var hasNoFloat = angular.isDefined(inputContainer.element.attr('md-no-float'));
            if ((label && label.length) || hasNoFloat) {
              inputContainer.setHasPlaceholder(true);
              return;
            }
            var placeholderText = attr.placeholder;
            element.removeAttr('placeholder');
            if (inputContainer.input && inputContainer.input[0].nodeName != 'MD-SELECT') {
              var placeholder = '<label ng-click="delegateClick()">' + placeholderText + '</label>';
              inputContainer.element.addClass('md-icon-float');
              inputContainer.element.prepend(placeholder);
            }
          }
        }
        placeholderDirective.$inject = ["$log"];
        function mdSelectOnFocusDirective() {
          return {
            restrict: 'A',
            link: postLink
          };
          function postLink(scope, element, attr) {
            if (element[0].nodeName !== 'INPUT' && element[0].nodeName !== "TEXTAREA")
              return;
            element.on('focus', onFocus);
            scope.$on('$destroy', function() {
              element.off('focus', onFocus);
            });
            function onFocus() {
              element[0].select();
            }
          }
        }
        var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault'];
        function ngMessagesDirective() {
          return {
            restrict: 'EA',
            link: postLink,
            require: '^^?mdInputContainer'
          };
          function postLink(scope, element, attrs, inputContainer) {
            if (!inputContainer)
              return;
            element.toggleClass('md-input-messages-animation', true);
            element.toggleClass('md-auto-hide', true);
            if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {
              element.toggleClass('md-auto-hide', false);
            }
          }
          function hasVisibiltyDirective(attrs) {
            return visibilityDirectives.some(function(attr) {
              return attrs[attr];
            });
          }
        }
        function ngMessageDirective($mdUtil) {
          return {
            restrict: 'EA',
            compile: compile,
            priority: 100
          };
          function compile(element) {
            var inputContainer = $mdUtil.getClosest(element, "md-input-container");
            if (!inputContainer)
              return;
            element.toggleClass('md-input-message-animation', true);
            return {};
          }
        }
        ngMessageDirective.$inject = ["$mdUtil"];
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
          return {addClass: function(element, className, done) {
              var messages = getMessagesElement(element);
              if (className == "md-input-invalid" && messages.hasClass('md-auto-hide')) {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }};
        }
        mdInputInvalidMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessagesAnimation($q, $animateCss) {
          return {
            enter: function(element, done) {
              showInputMessages(element, $animateCss, $q).finally(done);
            },
            leave: function(element, done) {
              hideInputMessages(element, $animateCss, $q).finally(done);
            },
            addClass: function(element, className, done) {
              if (className == "ng-hide") {
                hideInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            },
            removeClass: function(element, className, done) {
              if (className == "ng-hide") {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }
          };
        }
        ngMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessageAnimation($animateCss) {
          return {
            enter: function(element, done) {
              var messages = getMessagesElement(element);
              if (messages.hasClass('md-auto-hide')) {
                done();
                return;
              }
              return showMessage(element, $animateCss);
            },
            leave: function(element, done) {
              return hideMessage(element, $animateCss);
            }
          };
        }
        ngMessageAnimation.$inject = ["$animateCss"];
        function showInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = showMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = hideMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          return $animateCss(element, {
            event: 'enter',
            structural: true,
            from: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            to: {
              "opacity": 1,
              "margin-top": "0"
            },
            duration: 0.3
          });
        }
        function hideMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          var styles = window.getComputedStyle(element[0]);
          if (styles.opacity == 0) {
            return $animateCss(element, {});
          }
          return $animateCss(element, {
            event: 'leave',
            structural: true,
            from: {
              "opacity": 1,
              "margin-top": 0
            },
            to: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            duration: 0.3
          });
        }
        function getInputElement(element) {
          var inputContainer = element.controller('mdInputContainer');
          return inputContainer.element;
        }
        function getMessagesElement(element) {
          var input = getInputElement(element);
          var selector = 'ng-messages,data-ng-messages,x-ng-messages,' + '[ng-messages],[data-ng-messages],[x-ng-messages]';
          return angular.element(input[0].querySelector(selector));
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar', ['material.core', 'material.components.menu']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.list', ['material.core']).controller('MdListController', MdListController).directive('mdList', mdListDirective).directive('mdListItem', mdListItemDirective);
        function mdListDirective($mdTheming) {
          return {
            restrict: 'E',
            compile: function(tEl) {
              tEl[0].setAttribute('role', 'list');
              return $mdTheming;
            }
          };
        }
        mdListDirective.$inject = ["$mdTheming"];
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
          var proxiedTypes = ['md-checkbox', 'md-switch'];
          return {
            restrict: 'E',
            controller: 'MdListController',
            compile: function(tEl, tAttrs) {
              var secondaryItem = tEl[0].querySelector('.md-secondary');
              var hasProxiedElement;
              var proxyElement;
              tEl[0].setAttribute('role', 'listitem');
              if (tAttrs.ngClick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {
                wrapIn('button');
              } else {
                for (var i = 0,
                    type; type = proxiedTypes[i]; ++i) {
                  if (proxyElement = tEl[0].querySelector(type)) {
                    hasProxiedElement = true;
                    break;
                  }
                }
                if (hasProxiedElement) {
                  wrapIn('div');
                } else if (!tEl[0].querySelector('md-button:not(.md-secondary):not(.md-exclude)')) {
                  tEl.addClass('md-no-proxy');
                }
              }
              wrapSecondary();
              setupToggleAria();
              function setupToggleAria() {
                var toggleTypes = ['md-switch', 'md-checkbox'];
                var toggle;
                for (var i = 0,
                    toggleType; toggleType = toggleTypes[i]; ++i) {
                  if (toggle = tEl.find(toggleType)[0]) {
                    if (!toggle.hasAttribute('aria-label')) {
                      var p = tEl.find('p')[0];
                      if (!p)
                        return;
                      toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);
                    }
                  }
                }
              }
              function wrapIn(type) {
                var container;
                if (type == 'div') {
                  container = angular.element('<div class="md-no-style md-list-item-inner">');
                  container.append(tEl.contents());
                  tEl.addClass('md-proxy-focus');
                } else {
                  container = angular.element('<md-button class="md-no-style"><div class="md-list-item-inner"></div></md-button>');
                  copyAttributes(tEl[0], container[0]);
                  container.children().eq(0).append(tEl.contents());
                }
                tEl[0].setAttribute('tabindex', '-1');
                tEl.append(container);
              }
              function wrapSecondary() {
                if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {
                  $mdAria.expect(secondaryItem, 'aria-label');
                  var buttonWrapper = angular.element('<md-button class="md-secondary-container md-icon-button">');
                  copyAttributes(secondaryItem, buttonWrapper[0]);
                  secondaryItem.setAttribute('tabindex', '-1');
                  secondaryItem.classList.remove('md-secondary');
                  buttonWrapper.append(secondaryItem);
                  secondaryItem = buttonWrapper[0];
                }
                if (secondaryItem && (secondaryItem.hasAttribute('ng-click') || (tAttrs.ngClick && isProxiedElement(secondaryItem)))) {
                  tEl.addClass('md-with-secondary');
                  tEl.append(secondaryItem);
                }
              }
              function copyAttributes(item, wrapper) {
                var copiedAttrs = ['ng-if', 'ng-click', 'aria-label', 'ng-disabled', 'ui-sref', 'href', 'ng-href', 'ng-attr-ui-sref'];
                angular.forEach(copiedAttrs, function(attr) {
                  if (item.hasAttribute(attr)) {
                    wrapper.setAttribute(attr, item.getAttribute(attr));
                    item.removeAttribute(attr);
                  }
                });
              }
              function isProxiedElement(el) {
                return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
              }
              function isButton(el) {
                var nodeName = el.nodeName.toUpperCase();
                return nodeName == "MD-BUTTON" || nodeName == "BUTTON";
              }
              return postLink;
              function postLink($scope, $element, $attr, ctrl) {
                var proxies = [],
                    firstChild = $element[0].firstElementChild,
                    hasClick = firstChild && hasClickEvent(firstChild);
                computeProxies();
                computeClickable();
                if ($element.hasClass('md-proxy-focus') && proxies.length) {
                  angular.forEach(proxies, function(proxy) {
                    proxy = angular.element(proxy);
                    $scope.mouseActive = false;
                    proxy.on('mousedown', function() {
                      $scope.mouseActive = true;
                      $timeout(function() {
                        $scope.mouseActive = false;
                      }, 100);
                    }).on('focus', function() {
                      if ($scope.mouseActive === false) {
                        $element.addClass('md-focused');
                      }
                      proxy.on('blur', function proxyOnBlur() {
                        $element.removeClass('md-focused');
                        proxy.off('blur', proxyOnBlur);
                      });
                    });
                  });
                }
                function hasClickEvent(element) {
                  var attr = element.attributes;
                  for (var i = 0; i < attr.length; i++) {
                    if ($attr.$normalize(attr[i].name) === 'ngClick')
                      return true;
                  }
                  return false;
                }
                function computeProxies() {
                  var children = $element.children();
                  if (children.length && !children[0].hasAttribute('ng-click')) {
                    angular.forEach(proxiedTypes, function(type) {
                      angular.forEach(firstChild.querySelectorAll(type), function(child) {
                        proxies.push(child);
                      });
                    });
                  }
                }
                function computeClickable() {
                  if (proxies.length == 1 || hasClick) {
                    $element.addClass('md-clickable');
                    if (!hasClick) {
                      ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));
                    }
                  }
                }
                if (!hasClick && !proxies.length) {
                  firstChild && firstChild.addEventListener('keypress', function(e) {
                    if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA' && !e.target.isContentEditable) {
                      var keyCode = e.which || e.keyCode;
                      if (keyCode == $mdConstant.KEY_CODE.SPACE) {
                        if (firstChild) {
                          firstChild.click();
                          e.preventDefault();
                          e.stopPropagation();
                        }
                      }
                    }
                  });
                }
                $element.off('click');
                $element.off('keypress');
                if (proxies.length == 1 && firstChild) {
                  $element.children().eq(0).on('click', function(e) {
                    var parentButton = $mdUtil.getClosest(e.target, 'BUTTON');
                    if (!parentButton && firstChild.contains(e.target)) {
                      angular.forEach(proxies, function(proxy) {
                        if (e.target !== proxy && !proxy.contains(e.target)) {
                          angular.element(proxy).triggerHandler('click');
                        }
                      });
                    }
                  });
                }
              }
            }
          };
        }
        mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
        function MdListController($scope, $element, $mdListInkRipple) {
          var ctrl = this;
          ctrl.attachRipple = attachRipple;
          function attachRipple(scope, element) {
            var options = {};
            $mdListInkRipple.attach(scope, element, options);
          }
        }
        MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu', ['material.core', 'material.components.backdrop']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular', ['material.core']).directive('mdProgressCircular', MdProgressCircularDirective);
        function MdProgressCircularDirective($mdTheming, $mdUtil, $log) {
          var DEFAULT_PROGRESS_SIZE = 100;
          var DEFAULT_SCALING = 0.5;
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate";
          return {
            restrict: 'E',
            scope: true,
            template: '<div class="md-scale-wrapper">' + '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + '</div>' + '<div class="md-right">' + '<div class="md-half-circle"></div>' + '</div>' + '</div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var circle = element;
            var spinnerWrapper = angular.element(element.children()[0]);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            element.attr('md-mode', mode());
            updateScale();
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() == MODE_DETERMINATE) {
                  animateIndicator(percentValue);
                }
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    spinnerWrapper.removeClass('ng-hide');
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function updateScale() {
              circle.css({
                width: (100 * getDiameterRatio()) + 'px',
                height: (100 * getDiameterRatio()) + 'px'
              });
              circle.children().eq(0).css(toVendorCSS({transform: $mdUtil.supplant('translate(-50%, -50%) scale( {0} )', [getDiameterRatio()])}));
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            var leftC,
                rightC,
                gap;
            function animateIndicator(value) {
              if (!mode())
                return;
              leftC = leftC || angular.element(element[0].querySelector('.md-left > .md-half-circle'));
              rightC = rightC || angular.element(element[0].querySelector('.md-right > .md-half-circle'));
              gap = gap || angular.element(element[0].querySelector('.md-gap'));
              var gapStyles = removeEmptyValues({
                borderBottomColor: (value <= 50) ? "transparent !important" : "",
                transition: (value <= 50) ? "" : "borderBottomColor 0.1s linear"
              }),
                  leftStyles = removeEmptyValues({
                    transition: (value <= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value <= 50 ? 135 : (((value - 50) / 50 * 180) + 135)])
                  }),
                  rightStyles = removeEmptyValues({
                    transition: (value >= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value >= 50 ? 45 : (value / 50 * 180 - 135)])
                  });
              leftC.css(toVendorCSS(leftStyles));
              rightC.css(toVendorCSS(rightStyles));
              gap.css(toVendorCSS(gapStyles));
            }
            function getDiameterRatio() {
              if (!attr.mdDiameter)
                return DEFAULT_SCALING;
              var match = /([0-9]*)%/.exec(attr.mdDiameter);
              var value = Math.max(0, (match && match[1] / 100) || parseFloat(attr.mdDiameter));
              return (value > 1) ? value / DEFAULT_PROGRESS_SIZE : value;
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
          function removeEmptyValues(target) {
            for (var key in target) {
              if (target.hasOwnProperty(key)) {
                if (target[key] == "")
                  delete target[key];
              }
            }
            return target;
          }
        }
        MdProgressCircularDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressLinear', ['material.core']).directive('mdProgressLinear', MdProgressLinearDirective);
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate",
              MODE_BUFFER = "buffer",
              MODE_QUERY = "query";
          return {
            restrict: 'E',
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs, transclude) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            var bar1 = angular.element(element[0].querySelector('.md-bar1')),
                bar2 = angular.element(element[0].querySelector('.md-bar2')),
                container = angular.element(element[0].querySelector('.md-container'));
            element.attr('md-mode', mode());
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() != MODE_QUERY)
                  animateIndicator(bar2, percentValue);
              });
              attr.$observe('mdBufferValue', function(value) {
                animateIndicator(bar1, clamp(value));
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_QUERY:
                  case MODE_BUFFER:
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    container.removeClass('ng-hide' + ' ' + lastMode);
                    container.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      container.removeClass(lastMode);
                    container.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                  case MODE_BUFFER:
                  case MODE_QUERY:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
            function animateIndicator(target, value) {
              if (!mode())
                return;
              var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value - 100) / 2, value / 100]);
              var styles = toVendorCSS({transform: to});
              angular.element(target).css(styles);
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
        }
        MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.radioButton', ['material.core']).directive('mdRadioGroup', mdRadioGroupDirective).directive('mdRadioButton', mdRadioButtonDirective);
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
          RadioGroupController.prototype = createRadioGroupControllerProto();
          return {
            restrict: 'E',
            controller: ['$element', RadioGroupController],
            require: ['mdRadioGroup', '?ngModel'],
            link: {pre: linkRadioGroup}
          };
          function linkRadioGroup(scope, element, attr, ctrls) {
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            rgCtrl.init(ngModelCtrl);
            scope.mouseActive = false;
            element.attr({
              'role': 'radiogroup',
              'tabIndex': element.attr('tabindex') || '0'
            }).on('keydown', keydownListener).on('mousedown', function(event) {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                rgCtrl.$element.addClass('md-focused');
              }
            }).on('blur', function() {
              rgCtrl.$element.removeClass('md-focused');
            });
            function setFocus() {
              if (!element.hasClass('md-focused')) {
                element.addClass('md-focused');
              }
            }
            function keydownListener(ev) {
              var keyCode = ev.which || ev.keyCode;
              if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) {
                return;
              }
              switch (keyCode) {
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                case $mdConstant.KEY_CODE.UP_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectPrevious();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectNext();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.ENTER:
                  var form = angular.element($mdUtil.getClosest(element[0], 'form'));
                  if (form.length > 0) {
                    form.triggerHandler('submit');
                  }
                  break;
              }
            }
          }
          function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
          }
          function createRadioGroupControllerProto() {
            return {
              init: function(ngModelCtrl) {
                this._ngModelCtrl = ngModelCtrl;
                this._ngModelCtrl.$render = angular.bind(this, this.render);
              },
              add: function(rbRender) {
                this._radioButtonRenderFns.push(rbRender);
              },
              remove: function(rbRender) {
                var index = this._radioButtonRenderFns.indexOf(rbRender);
                if (index !== -1) {
                  this._radioButtonRenderFns.splice(index, 1);
                }
              },
              render: function() {
                this._radioButtonRenderFns.forEach(function(rbRender) {
                  rbRender();
                });
              },
              setViewValue: function(value, eventType) {
                this._ngModelCtrl.$setViewValue(value, eventType);
                this.render();
              },
              getViewValue: function() {
                return this._ngModelCtrl.$viewValue;
              },
              selectNext: function() {
                return changeSelectedButton(this.$element, 1);
              },
              selectPrevious: function() {
                return changeSelectedButton(this.$element, -1);
              },
              setActiveDescendant: function(radioId) {
                this.$element.attr('aria-activedescendant', radioId);
              }
            };
          }
          function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);
            if (buttons.count()) {
              var validate = function(button) {
                return !angular.element(button).attr("disabled");
              };
              var selected = parent[0].querySelector('md-radio-button.md-checked');
              var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();
              angular.element(target).triggerHandler('click');
            }
          }
        }
        mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            require: '^mdRadioGroup',
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            link: link
          };
          function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            initialize();
            function initialize(controller) {
              if (!rgCtrl) {
                throw 'RadioGroupController not found.';
              }
              rgCtrl.add(render);
              attr.$observe('value', render);
              element.on('click', listener).on('$destroy', function() {
                rgCtrl.remove(render);
              });
            }
            function listener(ev) {
              if (element[0].hasAttribute('disabled'))
                return;
              scope.$apply(function() {
                rgCtrl.setViewValue(attr.value, ev && ev.type);
              });
            }
            function render() {
              var checked = (rgCtrl.getViewValue() == attr.value);
              if (checked === lastChecked) {
                return;
              }
              lastChecked = checked;
              element.attr('aria-checked', checked);
              if (checked) {
                markParentAsChecked(true);
                element.addClass(CHECKED_CSS);
                rgCtrl.setActiveDescendant(element.attr('id'));
              } else {
                markParentAsChecked(false);
                element.removeClass(CHECKED_CSS);
              }
              function markParentAsChecked(addClass) {
                if (element.parent()[0].nodeName != "MD-RADIO-GROUP") {
                  element.parent()[!!addClass ? 'addClass' : 'removeClass'](CHECKED_CSS);
                }
              }
            }
            function configureAria(element, scope) {
              scope.ariaId = buildAriaID();
              element.attr({
                'id': scope.ariaId,
                'role': 'radio',
                'aria-checked': 'false'
              });
              $mdAria.expectWithText(element, 'aria-label');
              function buildAriaID() {
                return attr.id || ('radio' + "_" + $mdUtil.nextUid());
              }
            }
          }
        }
        mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        var SELECT_EDGE_MARGIN = 8;
        var selectNextId = 0;
        angular.module('material.components.select', ['material.core', 'material.components.backdrop']).directive('mdSelect', SelectDirective).directive('mdSelectMenu', SelectMenuDirective).directive('mdOption', OptionDirective).directive('mdOptgroup', OptgroupDirective).provider('$mdSelect', SelectProvider);
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'],
            compile: compile,
            controller: function() {}
          };
          function compile(element, attr) {
            var valueEl = angular.element('<md-select-value><span></span></md-select-value>');
            valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
            valueEl.addClass('md-select-value');
            if (!valueEl[0].hasAttribute('id')) {
              valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());
            }
            if (!element.find('md-content').length) {
              element.append(angular.element('<md-content>').append(element.contents()));
            }
            if (attr.mdOnOpen) {
              element.find('md-content').prepend(angular.element('<div>' + ' <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone"></md-progress-circular>' + '</div>'));
              element.find('md-option').attr('ng-show', '$$loadingAsyncDone');
            }
            if (attr.name) {
              var autofillClone = angular.element('<select class="md-visually-hidden">');
              autofillClone.attr({
                'name': '.' + attr.name,
                'ng-model': attr.ngModel,
                'aria-hidden': 'true',
                'tabindex': '-1'
              });
              var opts = element.find('md-option');
              angular.forEach(opts, function(el) {
                var newEl = angular.element('<option>' + el.innerHTML + '</option>');
                if (el.hasAttribute('ng-value'))
                  newEl.attr('ng-value', el.getAttribute('ng-value'));
                else if (el.hasAttribute('value'))
                  newEl.attr('value', el.getAttribute('value'));
                autofillClone.append(newEl);
              });
              element.parent().append(autofillClone);
            }
            var multiple = angular.isDefined(attr.multiple) ? 'multiple' : '';
            var selectTemplate = '' + '<div class="md-select-menu-container" aria-hidden="true">' + '<md-select-menu {0}>{1}</md-select-menu>' + '</div>';
            selectTemplate = $mdUtil.supplant(selectTemplate, [multiple, element.html()]);
            element.empty().append(valueEl);
            element.append(selectTemplate);
            attr.tabindex = attr.tabindex || '0';
            return function postLink(scope, element, attr, ctrls) {
              var untouched = true;
              var isDisabled,
                  ariaLabelBase;
              var containerCtrl = ctrls[0];
              var mdSelectCtrl = ctrls[1];
              var ngModelCtrl = ctrls[2];
              var formCtrl = ctrls[3];
              var valueEl = element.find('md-select-value');
              var isReadonly = angular.isDefined(attr.readonly);
              if (containerCtrl) {
                var isErrorGetter = containerCtrl.isErrorGetter || function() {
                  return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                };
                if (containerCtrl.input) {
                  throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                }
                containerCtrl.input = element;
                if (!containerCtrl.label) {
                  $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
                }
                scope.$watch(isErrorGetter, containerCtrl.setInvalid);
              }
              var selectContainer,
                  selectScope,
                  selectMenuCtrl;
              findSelectContainer();
              $mdTheming(element);
              if (attr.name && formCtrl) {
                var selectEl = element.parent()[0].querySelector('select[name=".' + attr.name + '"]');
                $mdUtil.nextTick(function() {
                  var controller = angular.element(selectEl).controller('ngModel');
                  if (controller) {
                    formCtrl.$removeControl(controller);
                  }
                });
              }
              if (formCtrl && angular.isDefined(attr.multiple)) {
                $mdUtil.nextTick(function() {
                  var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
                  if (hasModelValue) {
                    formCtrl.$setPristine();
                  }
                });
              }
              var originalRender = ngModelCtrl.$render;
              ngModelCtrl.$render = function() {
                originalRender();
                syncLabelText();
                syncAriaLabel();
                inputCheckValue();
              };
              attr.$observe('placeholder', ngModelCtrl.$render);
              mdSelectCtrl.setLabelText = function(text) {
                mdSelectCtrl.setIsPlaceholder(!text);
                var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : '');
                text = text || tmpPlaceholder || '';
                var target = valueEl.children().eq(0);
                target.html(text);
              };
              mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                if (isPlaceholder) {
                  valueEl.addClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.addClass('md-placeholder');
                  }
                } else {
                  valueEl.removeClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.removeClass('md-placeholder');
                  }
                }
              };
              if (!isReadonly) {
                element.on('focus', function(ev) {
                  if (containerCtrl && containerCtrl.element.hasClass('md-input-has-value')) {
                    containerCtrl.setFocused(true);
                  }
                });
                $mdUtil.nextTick(function() {
                  element.on('blur', function() {
                    if (untouched) {
                      untouched = false;
                      ngModelCtrl.$setUntouched();
                    }
                    if (selectScope.isOpen)
                      return;
                    containerCtrl && containerCtrl.setFocused(false);
                    inputCheckValue();
                  });
                });
              }
              mdSelectCtrl.triggerClose = function() {
                $parse(attr.mdOnClose)(scope);
              };
              scope.$$postDigest(function() {
                initAriaLabel();
                syncLabelText();
                syncAriaLabel();
              });
              function initAriaLabel() {
                var labelText = element.attr('aria-label') || element.attr('placeholder');
                if (!labelText && containerCtrl && containerCtrl.label) {
                  labelText = containerCtrl.label.text();
                }
                ariaLabelBase = labelText;
                $mdAria.expect(element, 'aria-label', labelText);
              }
              scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);
              function syncLabelText() {
                if (selectContainer) {
                  selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');
                  mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                }
              }
              function syncAriaLabel() {
                if (!ariaLabelBase)
                  return;
                var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria'});
                element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);
              }
              var deregisterWatcher;
              attr.$observe('ngMultiple', function(val) {
                if (deregisterWatcher)
                  deregisterWatcher();
                var parser = $parse(val);
                deregisterWatcher = scope.$watch(function() {
                  return parser(scope);
                }, function(multiple, prevVal) {
                  if (multiple === undefined && prevVal === undefined)
                    return;
                  if (multiple) {
                    element.attr('multiple', 'multiple');
                  } else {
                    element.removeAttr('multiple');
                  }
                  element.attr('aria-multiselectable', multiple ? 'true' : 'false');
                  if (selectContainer) {
                    selectMenuCtrl.setMultiple(multiple);
                    originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                      originalRender();
                      syncLabelText();
                      syncAriaLabel();
                      inputCheckValue();
                    };
                    ngModelCtrl.$render();
                  }
                });
              });
              attr.$observe('disabled', function(disabled) {
                if (angular.isString(disabled)) {
                  disabled = true;
                }
                if (isDisabled !== undefined && isDisabled === disabled) {
                  return;
                }
                isDisabled = disabled;
                if (disabled) {
                  element.attr({
                    'tabindex': -1,
                    'aria-disabled': 'true'
                  });
                  element.off('click', openSelect);
                  element.off('keydown', handleKeypress);
                } else {
                  element.attr({
                    'tabindex': attr.tabindex,
                    'aria-disabled': 'false'
                  });
                  element.on('click', openSelect);
                  element.on('keydown', handleKeypress);
                }
              });
              if (!attr.disabled && !attr.ngDisabled) {
                element.attr({
                  'tabindex': attr.tabindex,
                  'aria-disabled': 'false'
                });
                element.on('click', openSelect);
                element.on('keydown', handleKeypress);
              }
              var ariaAttrs = {
                role: 'listbox',
                'aria-expanded': 'false',
                'aria-multiselectable': attr.multiple !== undefined && !attr.ngMultiple ? 'true' : 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_' + $mdUtil.nextUid();
              }
              var containerId = 'select_container_' + $mdUtil.nextUid();
              selectContainer.attr('id', containerId);
              ariaAttrs['aria-owns'] = containerId;
              element.attr(ariaAttrs);
              scope.$on('$destroy', function() {
                $mdSelect.destroy().finally(function() {
                  if (containerCtrl) {
                    containerCtrl.setFocused(false);
                    containerCtrl.setHasValue(false);
                    containerCtrl.input = null;
                  }
                  ngModelCtrl.$setTouched();
                });
              });
              function inputCheckValue() {
                containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
              }
              function findSelectContainer() {
                selectContainer = angular.element(element[0].querySelector('.md-select-menu-container'));
                selectScope = scope;
                if (attr.mdContainerClass) {
                  var value = selectContainer[0].getAttribute('class') + ' ' + attr.mdContainerClass;
                  selectContainer[0].setAttribute('class', value);
                }
                selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');
                selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                element.on('$destroy', function() {
                  selectContainer.remove();
                });
              }
              function handleKeypress(e) {
                var allowedCodes = [32, 13, 38, 40];
                if (allowedCodes.indexOf(e.keyCode) != -1) {
                  e.preventDefault();
                  openSelect(e);
                } else {
                  if (e.keyCode <= 90 && e.keyCode >= 31) {
                    e.preventDefault();
                    var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                    if (!node)
                      return;
                    var optionCtrl = angular.element(node).controller('mdOption');
                    if (!selectMenuCtrl.isMultiple) {
                      selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                    }
                    selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                    selectMenuCtrl.refreshViewValue();
                  }
                }
              }
              function openSelect() {
                selectScope.isOpen = true;
                element.attr('aria-expanded', 'true');
                $mdSelect.show({
                  scope: selectScope,
                  preserveScope: true,
                  skipCompile: true,
                  element: selectContainer,
                  target: element[0],
                  selectCtrl: mdSelectCtrl,
                  preserveElement: true,
                  hasBackdrop: true,
                  loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
                }).finally(function() {
                  selectScope.isOpen = false;
                  element.focus();
                  element.attr('aria-expanded', 'false');
                  ngModelCtrl.$setTouched();
                });
              }
            };
          }
        }
        SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse"];
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
          SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
          return {
            restrict: 'E',
            require: ['mdSelectMenu'],
            scope: true,
            controller: SelectMenuController,
            link: {pre: preLink}
          };
          function preLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            $mdTheming(element);
            element.on('click', clickListener);
            element.on('keypress', keyListener);
            function keyListener(e) {
              if (e.keyCode == 13 || e.keyCode == 32) {
                clickListener(e);
              }
            }
            function clickListener(ev) {
              var option = $mdUtil.getClosest(ev.target, 'md-option');
              var optionCtrl = option && angular.element(option).data('$mdOptionController');
              if (!option || !optionCtrl)
                return;
              if (option.hasAttribute('disabled')) {
                ev.stopImmediatePropagation();
                return false;
              }
              var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
              var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
              scope.$apply(function() {
                if (selectCtrl.isMultiple) {
                  if (isSelected) {
                    selectCtrl.deselect(optionHashKey);
                  } else {
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                } else {
                  if (!isSelected) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                }
                selectCtrl.refreshViewValue();
              });
            }
          }
          function SelectMenuController($scope, $attrs, $element) {
            var self = this;
            self.isMultiple = angular.isDefined($attrs.multiple);
            self.selected = {};
            self.options = {};
            $scope.$watchCollection(function() {
              return self.options;
            }, function() {
              self.ngModel.$render();
            });
            var deregisterCollectionWatch;
            var defaultIsEmpty;
            self.setMultiple = function(isMultiple) {
              var ngModel = self.ngModel;
              defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
              self.isMultiple = isMultiple;
              if (deregisterCollectionWatch)
                deregisterCollectionWatch();
              if (self.isMultiple) {
                ngModel.$validators['md-multiple'] = validateArray;
                ngModel.$render = renderMultiple;
                $scope.$watchCollection(self.modelBinding, function(value) {
                  if (validateArray(value))
                    renderMultiple(value);
                  self.ngModel.$setPristine();
                });
                ngModel.$isEmpty = function(value) {
                  return !value || value.length === 0;
                };
              } else {
                delete ngModel.$validators['md-multiple'];
                ngModel.$render = renderSingular;
              }
              function validateArray(modelValue, viewValue) {
                return angular.isArray(modelValue || viewValue || []);
              }
            };
            var searchStr = '';
            var clearSearchTimeout,
                optNodes,
                optText;
            var CLEAR_SEARCH_AFTER = 300;
            self.optNodeForKeyboardSearch = function(e) {
              clearSearchTimeout && clearTimeout(clearSearchTimeout);
              clearSearchTimeout = setTimeout(function() {
                clearSearchTimeout = undefined;
                searchStr = '';
                optText = undefined;
                optNodes = undefined;
              }, CLEAR_SEARCH_AFTER);
              searchStr += String.fromCharCode(e.keyCode);
              var search = new RegExp('^' + searchStr, 'i');
              if (!optNodes) {
                optNodes = $element.find('md-option');
                optText = new Array(optNodes.length);
                angular.forEach(optNodes, function(el, i) {
                  optText[i] = el.textContent.trim();
                });
              }
              for (var i = 0; i < optText.length; ++i) {
                if (search.test(optText[i])) {
                  return optNodes[i];
                }
              }
            };
            self.init = function(ngModel, binding) {
              self.ngModel = ngModel;
              self.modelBinding = binding;
              if (ngModel.$options && ngModel.$options.trackBy) {
                var trackByLocals = {};
                var trackByParsed = $parse(ngModel.$options.trackBy);
                self.hashGetter = function(value, valueScope) {
                  trackByLocals.$value = value;
                  return trackByParsed(valueScope || $scope, trackByLocals);
                };
              } else {
                self.hashGetter = function getHashValue(value) {
                  if (angular.isObject(value)) {
                    return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
                  }
                  return value;
                };
              }
              self.setMultiple(self.isMultiple);
            };
            self.selectedLabels = function(opts) {
              opts = opts || {};
              var mode = opts.mode || 'html';
              var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));
              if (selectedOptionEls.length) {
                var mapFn;
                if (mode == 'html') {
                  mapFn = function(el) {
                    var html = el.innerHTML;
                    var rippleContainer = el.querySelector('.md-ripple-container');
                    return rippleContainer ? html.replace(rippleContainer.outerHTML, '') : html;
                  };
                } else if (mode == 'aria') {
                  mapFn = function(el) {
                    return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent;
                  };
                }
                return selectedOptionEls.map(mapFn).join(', ');
              } else {
                return '';
              }
            };
            self.select = function(hashKey, hashedValue) {
              var option = self.options[hashKey];
              option && option.setSelected(true);
              self.selected[hashKey] = hashedValue;
            };
            self.deselect = function(hashKey) {
              var option = self.options[hashKey];
              option && option.setSelected(false);
              delete self.selected[hashKey];
            };
            self.addOption = function(hashKey, optionCtrl) {
              if (angular.isDefined(self.options[hashKey])) {
                throw new Error('Duplicate md-option values are not allowed in a select. ' + 'Duplicate value "' + optionCtrl.value + '" found.');
              }
              self.options[hashKey] = optionCtrl;
              if (angular.isDefined(self.selected[hashKey])) {
                self.select(hashKey, optionCtrl.value);
                self.refreshViewValue();
              }
            };
            self.removeOption = function(hashKey) {
              delete self.options[hashKey];
            };
            self.refreshViewValue = function() {
              var values = [];
              var option;
              for (var hashKey in self.selected) {
                if ((option = self.options[hashKey])) {
                  values.push(option.value);
                } else {
                  values.push(self.selected[hashKey]);
                }
              }
              var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy;
              var newVal = self.isMultiple ? values : values[0];
              var prevVal = self.ngModel.$modelValue;
              if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                self.ngModel.$setViewValue(newVal);
                self.ngModel.$render();
              }
            };
            function renderMultiple() {
              var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
              if (!angular.isArray(newSelectedValues))
                return;
              var oldSelected = Object.keys(self.selected);
              var newSelectedHashes = newSelectedValues.map(self.hashGetter);
              var deselected = oldSelected.filter(function(hash) {
                return newSelectedHashes.indexOf(hash) === -1;
              });
              deselected.forEach(self.deselect);
              newSelectedHashes.forEach(function(hashKey, i) {
                self.select(hashKey, newSelectedValues[i]);
              });
            }
            function renderSingular() {
              var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
              Object.keys(self.selected).forEach(self.deselect);
              self.select(self.hashGetter(value), value);
            }
          }
        }
        SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdTheming"];
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
          OptionController.$inject = ["$element"];
          return {
            restrict: 'E',
            require: ['mdOption', '^^mdSelectMenu'],
            controller: OptionController,
            compile: compile
          };
          function compile(element, attr) {
            element.append(angular.element('<div class="md-text">').append(element.contents()));
            element.attr('tabindex', attr.tabindex || '0');
            return postLink;
          }
          function postLink(scope, element, attr, ctrls) {
            var optionCtrl = ctrls[0];
            var selectCtrl = ctrls[1];
            if (angular.isDefined(attr.ngValue)) {
              scope.$watch(attr.ngValue, setOptionValue);
            } else if (angular.isDefined(attr.value)) {
              setOptionValue(attr.value);
            } else {
              scope.$watch(function() {
                return element.text().trim();
              }, setOptionValue);
            }
            attr.$observe('disabled', function(disabled) {
              if (disabled) {
                element.attr('tabindex', '-1');
              } else {
                element.attr('tabindex', '0');
              }
            });
            scope.$$postDigest(function() {
              attr.$observe('selected', function(selected) {
                if (!angular.isDefined(selected))
                  return;
                if (typeof selected == 'string')
                  selected = true;
                if (selected) {
                  if (!selectCtrl.isMultiple) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                  }
                  selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                } else {
                  selectCtrl.deselect(optionCtrl.hashKey);
                }
                selectCtrl.refreshViewValue();
              });
            });
            $mdButtonInkRipple.attach(scope, element);
            configureAria();
            function setOptionValue(newValue, oldValue, prevAttempt) {
              if (!selectCtrl.hashGetter) {
                if (!prevAttempt) {
                  scope.$$postDigest(function() {
                    setOptionValue(newValue, oldValue, true);
                  });
                }
                return;
              }
              var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
              var newHashKey = selectCtrl.hashGetter(newValue, scope);
              optionCtrl.hashKey = newHashKey;
              optionCtrl.value = newValue;
              selectCtrl.removeOption(oldHashKey, optionCtrl);
              selectCtrl.addOption(newHashKey, optionCtrl);
            }
            scope.$on('$destroy', function() {
              selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
            });
            function configureAria() {
              var ariaAttrs = {
                'role': 'option',
                'aria-selected': 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();
              }
              element.attr(ariaAttrs);
            }
          }
          function OptionController($element) {
            this.selected = false;
            this.setSelected = function(isSelected) {
              if (isSelected && !this.selected) {
                $element.attr({
                  'selected': 'selected',
                  'aria-selected': 'true'
                });
              } else if (!isSelected && this.selected) {
                $element.removeAttr('selected');
                $element.attr('aria-selected', 'false');
              }
              this.selected = isSelected;
            };
          }
        }
        OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil"];
        function OptgroupDirective() {
          return {
            restrict: 'E',
            compile: compile
          };
          function compile(el, attrs) {
            var labelElement = el.find('label');
            if (!labelElement.length) {
              labelElement = angular.element('<label>');
              el.prepend(labelElement);
            }
            labelElement.addClass('md-container-ignore');
            if (attrs.label)
              labelElement.text(attrs.label);
          }
        }
        function SelectProvider($$interimElementProvider) {
          selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
          return $$interimElementProvider('$mdSelect').setDefaults({
            methods: ['target'],
            options: selectDefaultOptions
          });
          function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
            var ERRROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true
            };
            function onRemove(scope, element, opts) {
              opts = opts || {};
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? cleanElement() : animateRemoval().then(cleanElement);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function cleanElement() {
                element.removeClass('md-active');
                element.attr('aria-hidden', 'true');
                element[0].style.display = 'none';
                announceClosed(opts);
                if (!opts.$destroy && opts.restoreFocus) {
                  opts.target.focus();
                }
              }
            }
            function onShow(scope, element, opts) {
              watchAsyncLoad();
              sanitizeAndConfigure(scope, opts);
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showDropDown(scope, element, opts).then(function(response) {
                element.attr('aria-hidden', 'false');
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                opts.cleanupResizing = activateResizing();
                return response;
              }, opts.hideBackdrop);
              function showDropDown(scope, element, opts) {
                opts.parent.append(element);
                return $q(function(resolve, reject) {
                  try {
                    $animateCss(element, {
                      removeClass: 'md-leave',
                      duration: 0
                    }).start().then(positionAndFocusMenu).then(resolve);
                  } catch (e) {
                    reject(e);
                  }
                });
              }
              function positionAndFocusMenu() {
                return $q(function(resolve) {
                  if (opts.isRemoved)
                    return $q.reject(false);
                  var info = calculateMenuPositions(scope, element, opts);
                  info.container.element.css(animator.toCss(info.container.styles));
                  info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                  $$rAF(function() {
                    element.addClass('md-active');
                    info.dropDown.element.css(animator.toCss({transform: ''}));
                    autoFocus(opts.focusedNode);
                    resolve();
                  });
                });
              }
              function showBackdrop(scope, element, options) {
                if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                  options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
                } else {
                  options.disableParentScroll = false;
                }
                if (options.hasBackdrop) {
                  options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
                  $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
                }
                return function hideBackdrop() {
                  if (options.backdrop)
                    options.backdrop.remove();
                  if (options.disableParentScroll)
                    options.restoreScroll();
                  delete options.restoreScroll;
                };
              }
              function autoFocus(focusedNode) {
                if (focusedNode && !focusedNode.hasAttribute('disabled')) {
                  focusedNode.focus();
                }
              }
              function sanitizeAndConfigure(scope, options) {
                var selectEl = element.find('md-select-menu');
                if (!options.target) {
                  throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [options.target]));
                }
                angular.extend(options, {
                  isRemoved: false,
                  target: angular.element(options.target),
                  parent: angular.element(options.parent),
                  selectEl: selectEl,
                  contentEl: element.find('md-content'),
                  optionNodes: selectEl[0].getElementsByTagName('md-option')
                });
              }
              function activateResizing() {
                var debouncedOnResize = (function(scope, target, options) {
                  return function() {
                    if (options.isRemoved)
                      return;
                    var updates = calculateMenuPositions(scope, target, options);
                    var container = updates.container;
                    var dropDown = updates.dropDown;
                    container.element.css(animator.toCss(container.styles));
                    dropDown.element.css(animator.toCss(dropDown.styles));
                  };
                })(scope, element, opts);
                var window = angular.element($window);
                window.on('resize', debouncedOnResize);
                window.on('orientationchange', debouncedOnResize);
                return function deactivateResizing() {
                  window.off('resize', debouncedOnResize);
                  window.off('orientationchange', debouncedOnResize);
                };
              }
              function watchAsyncLoad() {
                if (opts.loadingAsync && !opts.isRemoved) {
                  scope.$$loadingAsyncDone = false;
                  scope.progressMode = 'indeterminate';
                  $q.when(opts.loadingAsync).then(function() {
                    scope.$$loadingAsyncDone = true;
                    scope.progressMode = '';
                    delete opts.loadingAsync;
                  }).then(function() {
                    $$rAF(positionAndFocusMenu);
                  });
                }
              }
              function activateInteraction() {
                if (opts.isRemoved)
                  return;
                var dropDown = opts.selectEl;
                var selectCtrl = dropDown.controller('mdSelectMenu') || {};
                element.addClass('md-clickable');
                opts.backdrop && opts.backdrop.on('click', onBackdropClick);
                dropDown.on('keydown', onMenuKeyDown);
                dropDown.on('click', checkCloseMenu);
                return function cleanupInteraction() {
                  opts.backdrop && opts.backdrop.off('click', onBackdropClick);
                  dropDown.off('keydown', onMenuKeyDown);
                  dropDown.off('click', checkCloseMenu);
                  element.removeClass('md-clickable');
                  opts.isRemoved = true;
                };
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  opts.restoreFocus = false;
                  $mdUtil.nextTick($mdSelect.hide, true);
                }
                function onMenuKeyDown(ev) {
                  var keyCodes = $mdConstant.KEY_CODE;
                  ev.preventDefault();
                  ev.stopPropagation();
                  switch (ev.keyCode) {
                    case keyCodes.UP_ARROW:
                      return focusPrevOption();
                    case keyCodes.DOWN_ARROW:
                      return focusNextOption();
                    case keyCodes.SPACE:
                    case keyCodes.ENTER:
                      var option = $mdUtil.getClosest(ev.target, 'md-option');
                      if (option) {
                        dropDown.triggerHandler({
                          type: 'click',
                          target: option
                        });
                        ev.preventDefault();
                      }
                      checkCloseMenu(ev);
                      break;
                    case keyCodes.TAB:
                    case keyCodes.ESCAPE:
                      ev.stopPropagation();
                      ev.preventDefault();
                      opts.restoreFocus = true;
                      $mdUtil.nextTick($mdSelect.hide, true);
                      break;
                    default:
                      if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                        var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);
                        opts.focusedNode = optNode || opts.focusedNode;
                        optNode && optNode.focus();
                      }
                  }
                }
                function focusOption(direction) {
                  var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
                  var index = optionsArray.indexOf(opts.focusedNode);
                  var newOption;
                  do {
                    if (index === -1) {
                      index = 0;
                    } else if (direction === 'next' && index < optionsArray.length - 1) {
                      index++;
                    } else if (direction === 'prev' && index > 0) {
                      index--;
                    }
                    newOption = optionsArray[index];
                    if (newOption.hasAttribute('disabled'))
                      newOption = undefined;
                  } while (!newOption && index < optionsArray.length - 1 && index > 0);
                  newOption && newOption.focus();
                  opts.focusedNode = newOption;
                }
                function focusNextOption() {
                  focusOption('next');
                }
                function focusPrevOption() {
                  focusOption('prev');
                }
                function checkCloseMenu(ev) {
                  if (ev && (ev.type == 'click') && (ev.currentTarget != dropDown[0]))
                    return;
                  if (mouseOnScrollbar())
                    return;
                  var option = $mdUtil.getClosest(ev.target, 'md-option');
                  if (option && option.hasAttribute && !option.hasAttribute('disabled')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (!selectCtrl.isMultiple) {
                      opts.restoreFocus = true;
                      $mdUtil.nextTick(function() {
                        $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                      }, true);
                    }
                  }
                  function mouseOnScrollbar() {
                    var clickOnScrollbar = false;
                    if (ev && (ev.currentTarget.children.length > 0)) {
                      var child = ev.currentTarget.children[0];
                      var hasScrollbar = child.scrollHeight > child.clientHeight;
                      if (hasScrollbar && child.children.length > 0) {
                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                        if (relPosX > child.querySelector('md-option').offsetWidth)
                          clickOnScrollbar = true;
                      }
                    }
                    return clickOnScrollbar;
                  }
                }
              }
            }
            function announceClosed(opts) {
              var mdSelect = opts.selectCtrl;
              if (mdSelect) {
                var menuController = opts.selectEl.controller('mdSelectMenu');
                mdSelect.setLabelText(menuController.selectedLabels());
                mdSelect.triggerClose();
              }
            }
            function calculateMenuPositions(scope, element, opts) {
              var containerNode = element[0],
                  targetNode = opts.target[0].children[0],
                  parentNode = $document[0].body,
                  selectNode = opts.selectEl[0],
                  contentNode = opts.contentEl[0],
                  parentRect = parentNode.getBoundingClientRect(),
                  targetRect = targetNode.getBoundingClientRect(),
                  shouldOpenAroundTarget = false,
                  bounds = {
                    left: parentRect.left + SELECT_EDGE_MARGIN,
                    top: SELECT_EDGE_MARGIN,
                    bottom: parentRect.height - SELECT_EDGE_MARGIN,
                    right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                  },
                  spaceAvailable = {
                    top: targetRect.top - bounds.top,
                    left: targetRect.left - bounds.left,
                    right: bounds.right - (targetRect.left + targetRect.width),
                    bottom: bounds.bottom - (targetRect.top + targetRect.height)
                  },
                  maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
                  selectedNode = selectNode.querySelector('md-option[selected]'),
                  optionNodes = selectNode.getElementsByTagName('md-option'),
                  optgroupNodes = selectNode.getElementsByTagName('md-optgroup'),
                  isScrollable = calculateScrollable(element, contentNode),
                  centeredNode;
              var loading = isPromiseLike(opts.loadingAsync);
              if (!loading) {
                if (selectedNode) {
                  centeredNode = selectedNode;
                } else if (optgroupNodes.length) {
                  centeredNode = optgroupNodes[0];
                } else if (optionNodes.length) {
                  centeredNode = optionNodes[0];
                } else {
                  centeredNode = contentNode.firstElementChild || contentNode;
                }
              } else {
                centeredNode = contentNode.firstElementChild || contentNode;
              }
              if (contentNode.offsetWidth > maxWidth) {
                contentNode.style['max-width'] = maxWidth + 'px';
              } else {
                contentNode.style.maxWidth = null;
              }
              if (shouldOpenAroundTarget) {
                contentNode.style['min-width'] = targetRect.width + 'px';
              }
              if (isScrollable) {
                selectNode.classList.add('md-overflow');
              }
              var focusedNode = centeredNode;
              if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {
                focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                centeredNode = focusedNode;
              }
              opts.focusedNode = focusedNode;
              containerNode.style.display = 'block';
              var selectMenuRect = selectNode.getBoundingClientRect();
              var centeredRect = getOffsetRect(centeredNode);
              if (centeredNode) {
                var centeredStyle = $window.getComputedStyle(centeredNode);
                centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
              }
              if (isScrollable) {
                var scrollBuffer = contentNode.offsetHeight / 2;
                contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                if (spaceAvailable.top < scrollBuffer) {
                  contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);
                } else if (spaceAvailable.bottom < scrollBuffer) {
                  contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom);
                }
              }
              var left,
                  top,
                  transformOrigin,
                  minWidth;
              if (shouldOpenAroundTarget) {
                left = targetRect.left;
                top = targetRect.top + targetRect.height;
                transformOrigin = '50% 0';
                if (top + selectMenuRect.height > bounds.bottom) {
                  top = targetRect.top - selectMenuRect.height;
                  transformOrigin = '50% 100%';
                }
              } else {
                left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
                top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';
                minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
              }
              var containerRect = containerNode.getBoundingClientRect();
              var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;
              return {
                container: {
                  element: angular.element(containerNode),
                  styles: {
                    left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                    top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                    'min-width': minWidth
                  }
                },
                dropDown: {
                  element: angular.element(selectNode),
                  styles: {
                    transformOrigin: transformOrigin,
                    transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : ""
                  }
                }
              };
            }
          }
          function isPromiseLike(obj) {
            return obj && angular.isFunction(obj.then);
          }
          function clamp(min, n, max) {
            return Math.max(min, Math.min(n, max));
          }
          function getOffsetRect(node) {
            return node ? {
              left: node.offsetLeft,
              top: node.offsetTop,
              width: node.offsetWidth,
              height: node.offsetHeight
            } : {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
          }
          function calculateScrollable(element, contentNode) {
            var isScrollable = false;
            try {
              var oldDisplay = element[0].style.display;
              element[0].style.display = 'block';
              isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
              element[0].style.display = oldDisplay;
            } finally {}
            return isScrollable;
          }
        }
        SelectProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.showHide', ['material.core']).directive('ngShow', createDirective('ngShow', true)).directive('ngHide', createDirective('ngHide', false));
        function createDirective(name, targetValue) {
          return ['$mdUtil', function($mdUtil) {
            return {
              restrict: 'A',
              multiElement: true,
              link: function($scope, $element, $attr) {
                var unregister = $scope.$on('$md-resize-enable', function() {
                  unregister();
                  $scope.$watch($attr[name], function(value) {
                    if (!!value === targetValue) {
                      $mdUtil.nextTick(function() {
                        $scope.$broadcast('$md-resize');
                      });
                      $mdUtil.dom.animator.waitTransitionEnd($element).then(function() {
                        $scope.$broadcast('$md-resize');
                      });
                    }
                  });
                });
              }
            };
          }];
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.sidenav', ['material.core', 'material.components.backdrop']).factory('$mdSidenav', SidenavService).directive('mdSidenav', SidenavDirective).directive('mdSidenavFocus', SidenavFocusDirective).controller('$mdSidenavController', SidenavController);
        function SidenavService($mdComponentRegistry, $q) {
          return function(handle) {
            var self;
            var errorMsg = "SideNav '" + handle + "' is not available!";
            var instance = $mdComponentRegistry.get(handle);
            if (!instance) {
              $mdComponentRegistry.notFoundError(handle);
            }
            return self = {
              isOpen: function() {
                return instance && instance.isOpen();
              },
              isLockedOpen: function() {
                return instance && instance.isLockedOpen();
              },
              toggle: function() {
                return instance ? instance.toggle() : $q.reject(errorMsg);
              },
              open: function() {
                return instance ? instance.open() : $q.reject(errorMsg);
              },
              close: function() {
                return instance ? instance.close() : $q.reject(errorMsg);
              },
              then: function(callbackFn) {
                var promise = instance ? $q.when(instance) : waitForInstance();
                return promise.then(callbackFn || angular.noop);
              }
            };
            function waitForInstance() {
              return $mdComponentRegistry.when(handle).then(function(it) {
                instance = it;
                return it;
              });
            }
          };
        }
        SidenavService.$inject = ["$mdComponentRegistry", "$q"];
        function SidenavFocusDirective() {
          return {
            restrict: 'A',
            require: '^mdSidenav',
            link: function(scope, element, attr, sidenavCtrl) {}
          };
        }
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
          return {
            restrict: 'E',
            scope: {isOpen: '=?mdIsOpen'},
            controller: '$mdSidenavController',
            compile: function(element) {
              element.addClass('md-closed');
              element.attr('tabIndex', '-1');
              return postLink;
            }
          };
          function postLink(scope, element, attr, sidenavCtrl) {
            var lastParentOverFlow;
            var triggeringElement = null;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
              return isLockedOpenParsed(scope.$parent, {
                $media: function(arg) {
                  $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                  return $mdMedia(arg);
                },
                $mdMedia: $mdMedia
              });
            };
            var backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
            $mdTheming.inherit(backdrop, element);
            element.on('$destroy', function() {
              backdrop.remove();
              sidenavCtrl.destroy();
            });
            scope.$on('$destroy', function() {
              backdrop.remove();
            });
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch('isOpen', updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
              scope.isLockedOpen = isLocked;
              if (isLocked === oldValue) {
                element.toggleClass('md-locked-open', !!isLocked);
              } else {
                $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');
              }
              backdrop.toggleClass('md-locked-open', !!isLocked);
            }
            function updateIsOpen(isOpen) {
              var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, '[md-sidenav-focus]') || element;
              var parent = element.parent();
              parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);
              backdrop[isOpen ? 'on' : 'off']('click', close);
              if (isOpen) {
                triggeringElement = $document[0].activeElement;
              }
              disableParentScroll(isOpen);
              return promise = $q.all([isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop), $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')]).then(function() {
                if (scope.isOpen) {
                  focusEl && focusEl.focus();
                }
              });
            }
            function disableParentScroll(disabled) {
              var parent = element.parent();
              if (disabled && !lastParentOverFlow) {
                lastParentOverFlow = parent.css('overflow');
                parent.css('overflow', 'hidden');
              } else if (angular.isDefined(lastParentOverFlow)) {
                parent.css('overflow', lastParentOverFlow);
                lastParentOverFlow = undefined;
              }
            }
            function toggleOpen(isOpen) {
              if (scope.isOpen == isOpen) {
                return $q.when(true);
              } else {
                return $q(function(resolve) {
                  scope.isOpen = isOpen;
                  $mdUtil.nextTick(function() {
                    promise.then(function(result) {
                      if (!scope.isOpen) {
                        triggeringElement && triggeringElement.focus();
                        triggeringElement = null;
                      }
                      resolve(result);
                    });
                  });
                });
              }
            }
            function onKeyDown(ev) {
              var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);
              return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
              ev.preventDefault();
              return sidenavCtrl.close();
            }
          }
        }
        SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document"];
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
          var self = this;
          self.isOpen = function() {
            return !!$scope.isOpen;
          };
          self.isLockedOpen = function() {
            return !!$scope.isLockedOpen;
          };
          self.open = function() {
            return self.$toggleOpen(true);
          };
          self.close = function() {
            return self.$toggleOpen(false);
          };
          self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
          };
          self.$toggleOpen = function(value) {
            return $q.when($scope.isOpen = value);
          };
          self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        SidenavController.$inject = ["$scope", "$element", "$attrs", "$mdComponentRegistry", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.slider', ['material.core']).directive('mdSlider', SliderDirective);
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log) {
          return {
            scope: {},
            require: '?ngModel',
            template: '<div class="md-slider-wrapper">' + '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + '</div>' + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + '</div>' + '<div class="md-disabled-thumb"></div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            if (!tAttrs.tabindex)
              tElement.attr('tabindex', 0);
            tElement.attr('role', 'slider');
            $mdAria.expect(tElement, 'aria-label');
            return postLink;
          }
          function postLink(scope, element, attr, ngModelCtrl) {
            $mdTheming(element);
            ngModelCtrl = ngModelCtrl || {
              $setViewValue: function(val) {
                this.$viewValue = val;
                this.$viewChangeListeners.forEach(function(cb) {
                  cb();
                });
              },
              $parsers: [],
              $formatters: [],
              $viewChangeListeners: []
            };
            var isDisabledGetter = angular.noop;
            if (attr.disabled != null) {
              isDisabledGetter = function() {
                return true;
              };
            } else if (attr.ngDisabled) {
              isDisabledGetter = angular.bind(null, $parse(attr.ngDisabled), scope.$parent);
            }
            var thumb = angular.element(element[0].querySelector('.md-thumb'));
            var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element(element[0].querySelector('.md-track-container'));
            var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));
            var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);
            angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);
            angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);
            angular.isDefined(attr.step) ? attr.$observe('step', updateStep) : updateStep(1);
            var stopDisabledWatch = angular.noop;
            if (attr.ngDisabled) {
              stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
            }
            $mdGesture.register(element, 'drag');
            element.on('keydown', keydownListener).on('$md.pressdown', onPressDown).on('$md.pressup', onPressUp).on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
            function updateAll() {
              refreshSliderDimensions();
              ngModelRender();
              redrawTicks();
            }
            setTimeout(updateAll, 0);
            var debouncedUpdateAll = $$rAF.throttle(updateAll);
            angular.element($window).on('resize', debouncedUpdateAll);
            scope.$on('$destroy', function() {
              angular.element($window).off('resize', debouncedUpdateAll);
              stopDisabledWatch();
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            function updateMin(value) {
              min = parseFloat(value);
              element.attr('aria-valuemin', value);
              updateAll();
            }
            function updateMax(value) {
              max = parseFloat(value);
              element.attr('aria-valuemax', value);
              updateAll();
            }
            function updateStep(value) {
              step = parseFloat(value);
              redrawTicks();
            }
            function updateAriaDisabled(isDisabled) {
              element.attr('aria-disabled', !!isDisabled);
            }
            var tickCanvas,
                tickCtx;
            function redrawTicks() {
              if (!angular.isDefined(attr.mdDiscrete))
                return;
              if (angular.isUndefined(step))
                return;
              if (step <= 0) {
                var msg = 'Slider step value must be greater than zero when in discrete mode';
                $log.error(msg);
                throw new Error(msg);
              }
              var numSteps = Math.floor((max - min) / step);
              if (!tickCanvas) {
                tickCanvas = angular.element('<canvas>').css('position', 'absolute');
                tickContainer.append(tickCanvas);
                var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                tickCtx = tickCanvas[0].getContext('2d');
                tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';
              }
              var dimensions = getSliderDimensions();
              tickCanvas[0].width = dimensions.width;
              tickCanvas[0].height = dimensions.height;
              var distance;
              for (var i = 0; i <= numSteps; i++) {
                distance = Math.floor(dimensions.width * (i / numSteps));
                tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
              }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
              sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
              throttledRefreshDimensions();
              return sliderDimensions;
            }
            function keydownListener(ev) {
              if (element[0].hasAttribute('disabled')) {
                return;
              }
              var changeAmount;
              if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                changeAmount = -step;
              } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                changeAmount = step;
              }
              if (changeAmount) {
                if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                  changeAmount *= 4;
                }
                ev.preventDefault();
                ev.stopPropagation();
                scope.$evalAsync(function() {
                  setModelValue(ngModelCtrl.$viewValue + changeAmount);
                });
              }
            }
            function setModelValue(value) {
              ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
              if (isNaN(ngModelCtrl.$viewValue)) {
                ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
              }
              var percent = (ngModelCtrl.$viewValue - min) / (max - min);
              scope.modelValue = ngModelCtrl.$viewValue;
              element.attr('aria-valuenow', ngModelCtrl.$viewValue);
              setSliderPercent(percent);
              thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value) {
              if (angular.isNumber(value)) {
                return Math.max(min, Math.min(max, value));
              }
            }
            function stepValidator(value) {
              if (angular.isNumber(value)) {
                var formattedValue = (Math.round((value - min) / step) * step + min);
                return (Math.round(formattedValue * 1000) / 1000);
              }
            }
            function setSliderPercent(percent) {
              percent = clamp(percent);
              var percentStr = (percent * 100) + '%';
              activeTrack.css('width', percentStr);
              thumbContainer.css('left', percentStr);
              element.toggleClass('md-min', percent === 0);
              element.toggleClass('md-max', percent === 1);
            }
            var isDragging = false;
            var isDiscrete = angular.isDefined(attr.mdDiscrete);
            function onPressDown(ev) {
              if (isDisabledGetter())
                return;
              element.addClass('md-active');
              element[0].focus();
              refreshSliderDimensions();
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                setSliderPercent(valueToPercent(closestVal));
              });
            }
            function onPressUp(ev) {
              if (isDisabledGetter())
                return;
              element.removeClass('md-dragging md-active');
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                ngModelRender();
              });
            }
            function onDragStart(ev) {
              if (isDisabledGetter())
                return;
              isDragging = true;
              ev.stopPropagation();
              element.addClass('md-dragging');
              setSliderFromEvent(ev);
            }
            function onDrag(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              setSliderFromEvent(ev);
            }
            function onDragEnd(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              isDragging = false;
            }
            function setSliderFromEvent(ev) {
              if (isDiscrete)
                adjustThumbPosition(ev.pointer.x);
              else
                doSlide(ev.pointer.x);
            }
            function doSlide(x) {
              scope.$evalAsync(function() {
                setModelValue(percentToValue(positionToPercent(x)));
              });
            }
            function adjustThumbPosition(x) {
              var exactVal = percentToValue(positionToPercent(x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              setSliderPercent(positionToPercent(x));
              thumbText.text(closestVal);
            }
            function clamp(value) {
              return Math.max(0, Math.min(value || 0, 1));
            }
            function positionToPercent(x) {
              return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));
            }
            function percentToValue(percent) {
              return (min + percent * (max - min));
            }
            function valueToPercent(val) {
              return (val - min) / (max - min);
            }
          }
        }
        SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.sticky', ['material.core', 'material.components.content']).factory('$mdSticky', MdSticky);
        function MdSticky($document, $mdConstant, $$rAF, $mdUtil, $compile) {
          var browserStickySupport = checkStickySupport();
          return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller('mdContent');
            if (!contentCtrl)
              return;
            if (browserStickySupport) {
              element.css({
                position: browserStickySupport,
                top: 0,
                'z-index': 2
              });
            } else {
              var $$sticky = contentCtrl.$element.data('$$sticky');
              if (!$$sticky) {
                $$sticky = setupSticky(contentCtrl);
                contentCtrl.$element.data('$$sticky', $$sticky);
              }
              var cloneElement = stickyClone || $compile(element.clone())(scope);
              var deregister = $$sticky.add(element, cloneElement);
              scope.$on('$destroy', deregister);
            }
          };
          function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.throttle(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on('$scrollstart', debouncedRefreshElements);
            contentEl.on('$scroll', onScroll);
            var self;
            return self = {
              prev: null,
              current: null,
              next: null,
              items: [],
              add: add,
              refreshElements: refreshElements
            };
            function add(element, stickyClone) {
              stickyClone.addClass('md-sticky-clone');
              var item = {
                element: element,
                clone: stickyClone
              };
              self.items.push(item);
              $mdUtil.nextTick(function() {
                contentEl.prepend(item.clone);
              });
              debouncedRefreshElements();
              return function remove() {
                self.items.forEach(function(item, index) {
                  if (item.element[0] === element[0]) {
                    self.items.splice(index, 1);
                    item.clone.remove();
                  }
                });
                debouncedRefreshElements();
              };
            }
            function refreshElements() {
              self.items.forEach(refreshPosition);
              self.items = self.items.sort(function(a, b) {
                return a.top < b.top ? -1 : 1;
              });
              var item;
              var currentScrollTop = contentEl.prop('scrollTop');
              for (var i = self.items.length - 1; i >= 0; i--) {
                if (currentScrollTop > self.items[i].top) {
                  item = self.items[i];
                  break;
                }
              }
              setCurrentItem(item);
            }
            function refreshPosition(item) {
              var current = item.element[0];
              item.top = 0;
              item.left = 0;
              while (current && current !== contentEl[0]) {
                item.top += current.offsetTop;
                item.left += current.offsetLeft;
                if (current.offsetParent) {
                  item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft;
                }
                current = current.offsetParent;
              }
              item.height = item.element.prop('offsetHeight');
              item.clone.css('margin-left', item.left + 'px');
              if ($mdUtil.floatingScrollbars()) {
                item.clone.css('margin-right', '0');
              }
            }
            function onScroll() {
              var scrollTop = contentEl.prop('scrollTop');
              var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
              onScroll.prevScrollTop = scrollTop;
              if (scrollTop === 0) {
                setCurrentItem(null);
                return;
              }
              if (isScrollingDown) {
                if (self.next && self.next.top <= scrollTop) {
                  setCurrentItem(self.next);
                  return;
                }
                if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                  translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                  return;
                }
              }
              if (!isScrollingDown) {
                if (self.current && self.prev && scrollTop < self.current.top) {
                  setCurrentItem(self.prev);
                  return;
                }
                if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {
                  translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                  return;
                }
              }
              if (self.current) {
                translate(self.current, scrollTop);
              }
            }
            function setCurrentItem(item) {
              if (self.current === item)
                return;
              if (self.current) {
                translate(self.current, null);
                setStickyState(self.current, null);
              }
              if (item) {
                setStickyState(item, 'active');
              }
              self.current = item;
              var index = self.items.indexOf(item);
              self.next = self.items[index + 1];
              self.prev = self.items[index - 1];
              setStickyState(self.next, 'next');
              setStickyState(self.prev, 'prev');
            }
            function setStickyState(item, state) {
              if (!item || item.state === state)
                return;
              if (item.state) {
                item.clone.attr('sticky-prev-state', item.state);
                item.element.attr('sticky-prev-state', item.state);
              }
              item.clone.attr('sticky-state', state);
              item.element.attr('sticky-state', state);
              item.state = state;
            }
            function translate(item, amount) {
              if (!item)
                return;
              if (amount === null || amount === undefined) {
                if (item.translateY) {
                  item.translateY = null;
                  item.clone.css($mdConstant.CSS.TRANSFORM, '');
                }
              } else {
                item.translateY = amount;
                item.clone.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)');
              }
            }
          }
          function checkStickySupport($el) {
            var stickyProp;
            var testEl = angular.element('<div>');
            $document[0].body.appendChild(testEl[0]);
            var stickyProps = ['sticky', '-webkit-sticky'];
            for (var i = 0; i < stickyProps.length; ++i) {
              testEl.css({
                position: stickyProps[i],
                top: 0,
                'z-index': 2
              });
              if (testEl.css('position') == stickyProps[i]) {
                stickyProp = stickyProps[i];
                break;
              }
            }
            testEl.remove();
            return stickyProp;
          }
          function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on('scroll touchmove', function() {
              if (!isScrolling) {
                isScrolling = true;
                $$rAF.throttle(loopScrollEvent);
                element.triggerHandler('$scrollstart');
              }
              element.triggerHandler('$scroll');
              lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
              if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                isScrolling = false;
                element.triggerHandler('$scrollend');
              } else {
                element.triggerHandler('$scroll');
                $$rAF.throttle(loopScrollEvent);
              }
            }
          }
        }
        MdSticky.$inject = ["$document", "$mdConstant", "$$rAF", "$mdUtil", "$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.subheader', ['material.core', 'material.components.sticky']).directive('mdSubheader', MdSubheaderDirective);
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
          return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: ('<div class="md-subheader">' + '  <div class="md-subheader-inner">' + '    <span class="md-subheader-content"></span>' + '  </div>' + '</div>'),
            link: function postLink(scope, element, attr, controllers, transclude) {
              $mdTheming(element);
              var outerHTML = element[0].outerHTML;
              function getContent(el) {
                return angular.element(el[0].querySelector('.md-subheader-content'));
              }
              transclude(scope, function(clone) {
                getContent(element).append(clone);
              });
              if (!element.hasClass('md-no-sticky')) {
                transclude(scope, function(clone) {
                  var wrapperHtml = '<div class="md-subheader-wrapper">' + outerHTML + '</div>';
                  var stickyClone = $compile(wrapperHtml)(scope);
                  $mdSticky(scope, element, stickyClone);
                  $mdUtil.nextTick(function() {
                    getContent(stickyClone).append(clone);
                  });
                });
              }
            }
          };
        }
        MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.swipe', ['material.core']).directive('mdSwipeLeft', getDirective('SwipeLeft')).directive('mdSwipeRight', getDirective('SwipeRight')).directive('mdSwipeUp', getDirective('SwipeUp')).directive('mdSwipeDown', getDirective('SwipeDown'));
        function getDirective(name) {
          var directiveName = 'md' + name;
          var eventName = '$md.' + name.toLowerCase();
          DirectiveFactory.$inject = ["$parse"];
          return DirectiveFactory;
          function DirectiveFactory($parse) {
            return {
              restrict: 'A',
              link: postLink
            };
            function postLink(scope, element, attr) {
              var fn = $parse(attr[directiveName]);
              element.on(eventName, function(ev) {
                scope.$apply(function() {
                  fn(scope, {$event: ev});
                });
              });
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.switch', ['material.core', 'material.components.checkbox']).directive('mdSwitch', MdSwitch);
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture) {
          var checkboxDirective = mdCheckboxDirective[0];
          return {
            restrict: 'E',
            priority: 210,
            transclude: true,
            template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + '</div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            require: '?ngModel',
            compile: mdSwitchCompile
          };
          function mdSwitchCompile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass('md-dragging');
            return function(scope, element, attr, ngModel) {
              ngModel = ngModel || $mdUtil.fakeNgModel();
              var disabledGetter = null;
              if (attr.disabled != null) {
                disabledGetter = function() {
                  return true;
                };
              } else if (attr.ngDisabled) {
                disabledGetter = $parse(attr.ngDisabled);
              }
              var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));
              var switchContainer = angular.element(element[0].querySelector('.md-container'));
              $$rAF(function() {
                element.removeClass('md-dragging');
              });
              checkboxLink(scope, element, attr, ngModel);
              if (disabledGetter) {
                scope.$watch(disabledGetter, function(isDisabled) {
                  element.attr('tabindex', isDisabled ? -1 : 0);
                });
              }
              $mdGesture.register(switchContainer, 'drag');
              switchContainer.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              var drag;
              function onDragStart(ev) {
                if (disabledGetter && disabledGetter(scope))
                  return;
                ev.stopPropagation();
                element.addClass('md-dragging');
                drag = {width: thumbContainer.prop('offsetWidth')};
                element.removeClass('transition');
              }
              function onDrag(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                ev.srcEvent && ev.srcEvent.preventDefault();
                var percent = ev.pointer.distanceX / drag.width;
                var translate = ngModel.$viewValue ? 1 + percent : percent;
                translate = Math.max(0, Math.min(1, translate));
                thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100 * translate) + '%,0,0)');
                drag.translate = translate;
              }
              function onDragEnd(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                element.removeClass('md-dragging');
                thumbContainer.css($mdConstant.CSS.TRANSFORM, '');
                var isChanged = ngModel.$viewValue ? drag.translate > 0.5 : drag.translate < 0.5;
                if (isChanged) {
                  applyModelValue(!ngModel.$viewValue);
                }
                drag = null;
              }
              function applyModelValue(newValue) {
                scope.$apply(function() {
                  ngModel.$setViewValue(newValue);
                  ngModel.$render();
                });
              }
            };
          }
        }
        MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.toast', ['material.core', 'material.components.button']).directive('mdToast', MdToastDirective).provider('$mdToast', MdToastProvider);
        function MdToastDirective($mdToast) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdToast.destroy();
              });
            }
          };
        }
        MdToastDirective.$inject = ["$mdToast"];
        function MdToastProvider($$interimElementProvider) {
          var ACTION_RESOLVE = 'ok';
          var activeToastContent;
          var $mdToast = $$interimElementProvider('$mdToast').setDefaults({
            methods: ['position', 'hideDelay', 'capsule', 'parent'],
            options: toastDefaultOptions
          }).addPreset('simple', {
            argOption: 'textContent',
            methods: ['textContent', 'content', 'action', 'highlightAction', 'theme', 'parent'],
            options: ["$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
              var opts = {
                template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' + '  <div class="md-toast-content">' + '    <span flex role="alert" aria-relevant="all" aria-atomic="true">' + '      {{ toast.content }}' + '    </span>' + '    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">' + '      {{ toast.action }}' + '    </md-button>' + '  </div>' + '</md-toast>',
                controller: ["$scope", function mdToastCtrl($scope) {
                  var self = this;
                  $scope.$watch(function() {
                    return activeToastContent;
                  }, function() {
                    self.content = activeToastContent;
                  });
                  this.resolve = function() {
                    $mdToast.hide(ACTION_RESOLVE);
                  };
                }],
                theme: $mdTheming.defaultTheme(),
                controllerAs: 'toast',
                bindToController: true
              };
              return opts;
            }]
          }).addMethod('updateTextContent', updateTextContent).addMethod('updateContent', updateTextContent);
          function updateTextContent(newContent) {
            activeToastContent = newContent;
          }
          toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"];
          return $mdToast;
          function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
            var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown';
            return {
              onShow: onShow,
              onRemove: onRemove,
              position: 'bottom left',
              themable: true,
              hideDelay: 3000,
              autoWrap: true,
              transformTemplate: function(template, options) {
                var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                if (shouldAddWrapper) {
                  var parsedTemplate = angular.element(template);
                  var wrappedContent = '<div class="md-toast-content">' + parsedTemplate.html() + '</div>';
                  parsedTemplate.empty().append(wrappedContent);
                  return parsedTemplate[0].outerHTML;
                }
                return shouldAddWrapper ? '<div class="md-toast-content">' + template + '</div>' : template || '';
              }
            };
            function onShow(scope, element, options) {
              activeToastContent = options.textContent || options.content;
              var isSmScreen = !$mdMedia('gt-sm');
              element = $mdUtil.extractElementByName(element, 'md-toast', true);
              options.onSwipe = function(ev, gesture) {
                var swipe = ev.type.replace('$md.', '');
                var direction = swipe.replace('swipe', '');
                if ((direction === 'down' && options.position.indexOf('top') != -1 && !isSmScreen) || (direction === 'up' && (options.position.indexOf('bottom') != -1 || isSmScreen))) {
                  return;
                }
                if ((direction === 'left' || direction === 'right') && isSmScreen) {
                  return;
                }
                element.addClass('md-' + swipe);
                $mdUtil.nextTick($mdToast.cancel);
              };
              options.openClass = toastOpenClass(options.position);
              options.parent.addClass(options.openClass);
              if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                options.parent.css('position', 'relative');
              }
              element.on(SWIPE_EVENTS, options.onSwipe);
              element.addClass(isSmScreen ? 'md-bottom' : options.position.split(' ').map(function(pos) {
                return 'md-' + pos;
              }).join(' '));
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              return $animate.enter(element, options.parent).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
              });
            }
            function onRemove(scope, element, options) {
              element.off(SWIPE_EVENTS, options.onSwipe);
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              if (options.openClass)
                options.parent.removeClass(options.openClass);
              return ((options.$destroy == true) ? element.remove() : $animate.leave(element)).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
                if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                  options.parent.css('position', '');
                }
              });
            }
            function toastOpenClass(position) {
              if (!$mdMedia('gt-sm')) {
                return 'md-toast-open-bottom';
              }
              return 'md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');
            }
          }
        }
        MdToastProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs', ['material.core', 'material.components.icon']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.toolbar', ['material.core', 'material.components.content']).directive('mdToolbar', mdToolbarDirective);
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
          var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)');
          return {
            template: '',
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              if (angular.isDefined(attr.mdScrollShrink)) {
                setupScrollShrink();
              }
              function setupScrollShrink() {
                var toolbarHeight;
                var contentElement;
                var disableScrollShrink = angular.noop;
                var y = 0;
                var prevScrollTop = 0;
                var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;
                var debouncedContentScroll = $$rAF.throttle(onContentScroll);
                var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);
                scope.$on('$mdContentLoaded', onMdContentLoad);
                attr.$observe('mdScrollShrink', onChangeScrollShrink);
                if (attr.ngShow) {
                  scope.$watch(attr.ngShow, updateToolbarHeight);
                }
                if (attr.ngHide) {
                  scope.$watch(attr.ngHide, updateToolbarHeight);
                }
                scope.$on('$destroy', disableScrollShrink);
                function onChangeScrollShrink(shrinkWithScroll) {
                  var closestContent = element.parent().find('md-content');
                  if (!contentElement && closestContent.length) {
                    onMdContentLoad(null, closestContent);
                  }
                  shrinkWithScroll = scope.$eval(shrinkWithScroll);
                  if (shrinkWithScroll === false) {
                    disableScrollShrink();
                  } else {
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onMdContentLoad($event, newContentEl) {
                  if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                    if (contentElement) {
                      contentElement.off('scroll', debouncedContentScroll);
                    }
                    contentElement = newContentEl;
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onContentScroll(e) {
                  var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                  debouncedUpdateHeight();
                  y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                  element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
                  contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));
                  prevScrollTop = scrollTop;
                  $mdUtil.nextTick(function() {
                    var hasWhiteFrame = element.hasClass('md-whiteframe-z1');
                    if (hasWhiteFrame && !y) {
                      $animate.removeClass(element, 'md-whiteframe-z1');
                    } else if (!hasWhiteFrame && y) {
                      $animate.addClass(element, 'md-whiteframe-z1');
                    }
                  });
                }
                function enableScrollShrink() {
                  if (!contentElement)
                    return angular.noop;
                  contentElement.on('scroll', debouncedContentScroll);
                  contentElement.attr('scroll-shrink', 'true');
                  $$rAF(updateToolbarHeight);
                  return function disableScrollShrink() {
                    contentElement.off('scroll', debouncedContentScroll);
                    contentElement.attr('scroll-shrink', 'false');
                    $$rAF(updateToolbarHeight);
                  };
                }
                function updateToolbarHeight() {
                  toolbarHeight = element.prop('offsetHeight');
                  var margin = (-toolbarHeight * shrinkSpeedFactor) + 'px';
                  contentElement.css({
                    "margin-top": margin,
                    "margin-bottom": margin
                  });
                  onContentScroll();
                }
              }
            }
          };
        }
        mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tooltip', ['material.core']).directive('mdTooltip', MdTooltipDirective);
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
          var TOOLTIP_SHOW_DELAY = 0;
          var TOOLTIP_WINDOW_EDGE_SPACE = 8;
          return {
            restrict: 'E',
            transclude: true,
            priority: 210,
            template: '<div class="md-content" ng-transclude></div>',
            scope: {
              delay: '=?mdDelay',
              visible: '=?mdVisible',
              autohide: '=?mdAutohide',
              direction: '@?mdDirection'
            },
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var parent = $mdUtil.getParentWithPointerEvents(element),
                content = angular.element(element[0].getElementsByClassName('md-content')[0]),
                tooltipParent = angular.element(document.body),
                debouncedOnResize = $$rAF.throttle(function() {
                  updatePosition();
                });
            if ($animate.pin)
              $animate.pin(element, parent);
            setDefaults();
            manipulateElement();
            bindEvents();
            updateContentOrigin();
            configureWatchers();
            addAriaLabel();
            function setDefaults() {
              if (!angular.isDefined(attr.mdDelay))
                scope.delay = TOOLTIP_SHOW_DELAY;
            }
            function updateContentOrigin() {
              var origin = 'center top';
              switch (scope.direction) {
                case 'left':
                  origin = 'right center';
                  break;
                case 'right':
                  origin = 'left center';
                  break;
                case 'top':
                  origin = 'center bottom';
                  break;
                case 'bottom':
                  origin = 'center top';
                  break;
              }
              content.css('transform-origin', origin);
            }
            function configureWatchers() {
              scope.$on('$destroy', function() {
                scope.visible = false;
                element.remove();
                angular.element($window).off('resize', debouncedOnResize);
              });
              scope.$watch('visible', function(isVisible) {
                if (isVisible)
                  showTooltip();
                else
                  hideTooltip();
              });
              scope.$watch('direction', updatePosition);
            }
            function addAriaLabel() {
              if (!parent.attr('aria-label') && !parent.text().trim()) {
                parent.attr('aria-label', element.text().trim());
              }
            }
            function manipulateElement() {
              element.detach();
              element.attr('role', 'tooltip');
            }
            function bindEvents() {
              var mouseActive = false;
              var ngWindow = angular.element($window);
              if (parent[0] && 'MutationObserver' in $window) {
                var attributeObserver = new MutationObserver(function(mutations) {
                  mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'disabled' && parent[0].disabled) {
                      setVisible(false);
                      scope.$digest();
                    }
                  });
                });
                attributeObserver.observe(parent[0], {attributes: true});
              }
              var windowBlurHandler = function() {
                elementFocusedOnWindowBlur = document.activeElement === parent[0];
              };
              var elementFocusedOnWindowBlur = false;
              function windowScrollHandler() {
                setVisible(false);
              }
              ngWindow.on('blur', windowBlurHandler);
              ngWindow.on('resize', debouncedOnResize);
              document.addEventListener('scroll', windowScrollHandler, true);
              scope.$on('$destroy', function() {
                ngWindow.off('blur', windowBlurHandler);
                ngWindow.off('resize', debouncedOnResize);
                document.removeEventListener('scroll', windowScrollHandler, true);
                attributeObserver && attributeObserver.disconnect();
              });
              var enterHandler = function(e) {
                if (e.type === 'focus' && elementFocusedOnWindowBlur) {
                  elementFocusedOnWindowBlur = false;
                  return;
                }
                parent.on('blur mouseleave touchend touchcancel', leaveHandler);
                setVisible(true);
              };
              var leaveHandler = function() {
                var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');
                if (autohide || mouseActive || ($document[0].activeElement !== parent[0])) {
                  parent.off('blur mouseleave touchend touchcancel', leaveHandler);
                  parent.triggerHandler("blur");
                  setVisible(false);
                }
                mouseActive = false;
              };
              parent.on('mousedown', function() {
                mouseActive = true;
              });
              parent.on('focus mouseenter touchstart', enterHandler);
            }
            function setVisible(value) {
              setVisible.value = !!value;
              if (!setVisible.queued) {
                if (value) {
                  setVisible.queued = true;
                  $timeout(function() {
                    scope.visible = setVisible.value;
                    setVisible.queued = false;
                  }, scope.delay);
                } else {
                  $mdUtil.nextTick(function() {
                    scope.visible = false;
                  });
                }
              }
            }
            function showTooltip() {
              tooltipParent.append(element);
              if ($mdUtil.hasComputedStyle(element, 'display', 'none')) {
                scope.visible = false;
                element.detach();
                return;
              }
              updatePosition();
              angular.forEach([element, content], function(element) {
                $animate.addClass(element, 'md-show');
              });
            }
            function hideTooltip() {
              var promises = [];
              angular.forEach([element, content], function(it) {
                if (it.parent() && it.hasClass('md-show')) {
                  promises.push($animate.removeClass(it, 'md-show'));
                }
              });
              $q.all(promises).then(function() {
                if (!scope.visible)
                  element.detach();
              });
            }
            function updatePosition() {
              if (!scope.visible)
                return;
              updateContentOrigin();
              positionTooltip();
            }
            function positionTooltip() {
              var tipRect = $mdUtil.offsetRect(element, tooltipParent);
              var parentRect = $mdUtil.offsetRect(parent, tooltipParent);
              var newPosition = getPosition(scope.direction);
              var offsetParent = element.prop('offsetParent');
              if (scope.direction) {
                newPosition = fitInParent(newPosition);
              } else if (offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {
                newPosition = fitInParent(getPosition('top'));
              }
              element.css({
                left: newPosition.left + 'px',
                top: newPosition.top + 'px'
              });
              function fitInParent(pos) {
                var newPosition = {
                  left: pos.left,
                  top: pos.top
                };
                newPosition.left = Math.min(newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.min(newPosition.top, tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                return newPosition;
              }
              function getPosition(dir) {
                return dir === 'left' ? {
                  left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'right' ? {
                  left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'top' ? {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                } : {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                };
              }
            }
          }
        }
        MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.virtualRepeat', ['material.core', 'material.components.showHide']).directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective).directive('mdVirtualRepeat', VirtualRepeatDirective);
        function VirtualRepeatContainerDirective() {
          return {
            controller: VirtualRepeatContainerController,
            template: virtualRepeatContainerTemplate,
            compile: function virtualRepeatContainerCompile($element, $attrs) {
              $element.addClass('md-virtual-repeat-container').addClass($attrs.hasOwnProperty('mdOrientHorizontal') ? 'md-orient-horizontal' : 'md-orient-vertical');
            }
          };
        }
        function virtualRepeatContainerTemplate($element) {
          return '<div class="md-virtual-repeat-scroller">' + '<div class="md-virtual-repeat-sizer"></div>' + '<div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + '</div></div>';
        }
        var MAX_ELEMENT_SIZE = 1533917;
        var NUM_EXTRA = 3;
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
          this.$rootScope = $rootScope;
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.size = 0;
          this.scrollSize = 0;
          this.scrollOffset = 0;
          this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
          this.repeater = null;
          this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
          this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
          this.originalSize = null;
          this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
          this.oldElementSize = null;
          if (this.$attrs.mdTopIndex) {
            this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
            this.topIndex = this.bindTopIndex(this.$scope);
            if (!angular.isDefined(this.topIndex)) {
              this.topIndex = 0;
              this.bindTopIndex.assign(this.$scope, 0);
            }
            this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
              if (newIndex !== this.topIndex) {
                this.scrollToIndex(newIndex);
              }
            }));
          } else {
            this.topIndex = 0;
          }
          this.scroller = $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0];
          this.sizer = this.scroller.getElementsByClassName('md-virtual-repeat-sizer')[0];
          this.offsetter = this.scroller.getElementsByClassName('md-virtual-repeat-offsetter')[0];
          var boundUpdateSize = angular.bind(this, this.updateSize);
          $$rAF(angular.bind(this, function() {
            boundUpdateSize();
            var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
            var jWindow = angular.element($window);
            if (!this.size) {
              debouncedUpdateSize();
            }
            jWindow.on('resize', debouncedUpdateSize);
            $scope.$on('$destroy', function() {
              jWindow.off('resize', debouncedUpdateSize);
            });
            $scope.$emit('$md-resize-enable');
            $scope.$on('$md-resize', boundUpdateSize);
          }));
        }
        VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
          this.repeater = repeaterCtrl;
          angular.element(this.scroller).on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
        };
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        VirtualRepeatContainerController.prototype.getSize = function() {
          return this.size;
        };
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
          var dimension = this.getDimensionName_();
          this.size = size;
          this.$element[0].style[dimension] = size + 'px';
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
          this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
          this.oldElementSize = null;
        };
        VirtualRepeatContainerController.prototype.updateSize = function() {
          if (this.originalSize)
            return;
          this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
          this.handleScroll_();
          this.repeater && this.repeater.containerUpdated();
        };
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
          return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
          return this.isHorizontal() ? 'width' : 'height';
        };
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
          var dimension = this.getDimensionName_();
          var crossDimension = this.isHorizontal() ? 'height' : 'width';
          this.sizer.innerHTML = '';
          if (size < MAX_ELEMENT_SIZE) {
            this.sizer.style[dimension] = size + 'px';
          } else {
            this.sizer.style[dimension] = 'auto';
            this.sizer.style[crossDimension] = 'auto';
            var numChildren = Math.floor(size / MAX_ELEMENT_SIZE);
            var sizerChild = document.createElement('div');
            sizerChild.style[dimension] = MAX_ELEMENT_SIZE + 'px';
            sizerChild.style[crossDimension] = '1px';
            for (var i = 0; i < numChildren; i++) {
              this.sizer.appendChild(sizerChild.cloneNode(false));
            }
            sizerChild.style[dimension] = (size - (numChildren * MAX_ELEMENT_SIZE)) + 'px';
            this.sizer.appendChild(sizerChild);
          }
        };
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
          var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
          if (this.autoShrink && shrinkSize !== this.size) {
            if (this.oldElementSize === null) {
              this.oldElementSize = this.$element[0].style[this.getDimensionName_()];
            }
            var currentSize = this.originalSize || this.size;
            if (!currentSize || shrinkSize < currentSize) {
              if (!this.originalSize) {
                this.originalSize = this.size;
              }
              this.setSize_(shrinkSize);
            } else if (this.originalSize !== null) {
              this.unsetSize_();
              this.originalSize = null;
              this.updateSize();
            }
            this.repeater.containerUpdated();
          }
        };
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
          var size = itemsSize + this.offsetSize;
          if (this.scrollSize === size)
            return;
          this.sizeScroller_(size);
          this.autoShrink_(size);
          this.scrollSize = size;
        };
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
          return this.scrollOffset;
        };
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
          this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
          this.handleScroll_();
        };
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
          var itemSize = this.repeater.getItemSize();
          var itemsLength = this.repeater.itemsLength;
          if (index > itemsLength) {
            index = itemsLength - 1;
          }
          this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
          this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
          var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
          if (offset === this.scrollOffset || offset > this.scrollSize - this.size)
            return;
          var itemSize = this.repeater.getItemSize();
          if (!itemSize)
            return;
          var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);
          var transform = (this.isHorizontal() ? 'translateX(' : 'translateY(') + (numItems * itemSize) + 'px)';
          this.scrollOffset = offset;
          this.offsetter.style.webkitTransform = transform;
          this.offsetter.style.transform = transform;
          if (this.bindTopIndex) {
            var topIndex = Math.floor(offset / itemSize);
            if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
              this.topIndex = topIndex;
              this.bindTopIndex.assign(this.$scope, topIndex);
              if (!this.$rootScope.$$phase)
                this.$scope.$digest();
            }
          }
          this.repeater.containerUpdated();
        };
        function VirtualRepeatDirective($parse) {
          return {
            controller: VirtualRepeatController,
            priority: 1000,
            require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
            restrict: 'A',
            terminal: true,
            transclude: 'element',
            compile: function VirtualRepeatCompile($element, $attrs) {
              var expression = $attrs.mdVirtualRepeat;
              var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
              var repeatName = match[1];
              var repeatListExpression = $parse(match[2]);
              var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
              return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
                ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
              };
            }
          };
        }
        VirtualRepeatDirective.$inject = ["$parse"];
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF) {
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.$browser = $browser;
          this.$document = $document;
          this.$rootScope = $rootScope;
          this.$$rAF = $$rAF;
          this.onDemand = $attrs.hasOwnProperty('mdOnDemand');
          this.browserCheckUrlChange = $browser.$$checkUrlChange;
          this.newStartIndex = 0;
          this.newEndIndex = 0;
          this.newVisibleEnd = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
          this.isFirstRender = true;
          this.isVirtualRepeatUpdating_ = false;
          this.itemsLength = 0;
          this.unwatchItemSize_ = angular.noop;
          this.blocks = {};
          this.pooledBlocks = [];
        }
        VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF"];
        VirtualRepeatController.Block;
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
          this.container = container;
          this.transclude = transclude;
          this.repeatName = repeatName;
          this.rawRepeatListExpression = repeatListExpression;
          this.extraName = extraName;
          this.sized = false;
          this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
          this.container.register(this);
        };
        VirtualRepeatController.prototype.readItemSize_ = function() {
          if (this.itemSize) {
            return;
          }
          this.items = this.repeatListExpression(this.$scope);
          this.parentNode = this.$element[0].parentNode;
          var block = this.getBlock_(0);
          if (!block.element[0].parentNode) {
            this.parentNode.appendChild(block.element[0]);
          }
          this.itemSize = block.element[0][this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;
          this.blocks[0] = block;
          this.poolBlock_(0);
          if (this.itemSize) {
            this.containerUpdated();
          }
        };
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
          var repeatList = this.rawRepeatListExpression(scope);
          if (this.onDemand && repeatList) {
            var virtualList = new VirtualRepeatModelArrayLike(repeatList);
            virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
            return virtualList;
          } else {
            return repeatList;
          }
        };
        VirtualRepeatController.prototype.containerUpdated = function() {
          if (!this.itemSize) {
            this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
              if (items && items.length) {
                this.$$rAF(angular.bind(this, this.readItemSize_));
              }
            }));
            if (!this.$rootScope.$$phase)
              this.$scope.$digest();
            return;
          } else if (!this.sized) {
            this.items = this.repeatListExpression(this.$scope);
          }
          if (!this.sized) {
            this.unwatchItemSize_();
            this.sized = true;
            this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
              if (!this.isVirtualRepeatUpdating_) {
                this.virtualRepeatUpdate_(items, oldItems);
              }
            }));
          }
          this.updateIndexes_();
          if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
            if (this.items instanceof VirtualRepeatModelArrayLike) {
              this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
            }
            this.virtualRepeatUpdate_(this.items, this.items);
          }
        };
        VirtualRepeatController.prototype.getItemSize = function() {
          return this.itemSize;
        };
        VirtualRepeatController.prototype.getItemCount = function() {
          return this.itemsLength;
        };
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
          this.isVirtualRepeatUpdating_ = true;
          var itemsLength = items && items.length || 0;
          var lengthChanged = false;
          if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
            this.items = items;
            this.container.resetScroll();
            return;
          }
          if (itemsLength !== this.itemsLength) {
            lengthChanged = true;
            this.itemsLength = itemsLength;
          }
          this.items = items;
          if (items !== oldItems || lengthChanged) {
            this.updateIndexes_();
          }
          this.parentNode = this.$element[0].parentNode;
          if (lengthChanged) {
            this.container.setScrollSize(itemsLength * this.itemSize);
          }
          if (this.isFirstRender) {
            this.isFirstRender = false;
            var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
            this.container.scrollToIndex(startIndex);
          }
          Object.keys(this.blocks).forEach(function(blockIndex) {
            var index = parseInt(blockIndex, 10);
            if (index < this.newStartIndex || index >= this.newEndIndex) {
              this.poolBlock_(index);
            }
          }, this);
          this.$browser.$$checkUrlChange = angular.noop;
          var i,
              block,
              newStartBlocks = [],
              newEndBlocks = [];
          for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newStartBlocks.push(block);
          }
          for (; this.blocks[i] != null; i++) {
            this.updateBlock_(this.blocks[i], i);
          }
          var maxIndex = i - 1;
          for (; i < this.newEndIndex; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newEndBlocks.push(block);
          }
          if (newStartBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
          }
          if (newEndBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
          }
          this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
          this.startIndex = this.newStartIndex;
          this.endIndex = this.newEndIndex;
          this.isVirtualRepeatUpdating_ = false;
        };
        VirtualRepeatController.prototype.getBlock_ = function(index) {
          if (this.pooledBlocks.length) {
            return this.pooledBlocks.pop();
          }
          var block;
          this.transclude(angular.bind(this, function(clone, scope) {
            block = {
              element: clone,
              new: true,
              scope: scope
            };
            this.updateScope_(scope, index);
            this.parentNode.appendChild(clone[0]);
          }));
          return block;
        };
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
          this.blocks[index] = block;
          if (!block.new && (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
            return;
          }
          block.new = false;
          this.updateScope_(block.scope, index);
          if (!this.$rootScope.$$phase) {
            block.scope.$digest();
          }
        };
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
          scope.$index = index;
          scope[this.repeatName] = this.items && this.items[index];
          if (this.extraName)
            scope[this.extraName(this.$scope)] = this.items[index];
        };
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
          this.pooledBlocks.push(this.blocks[index]);
          this.parentNode.removeChild(this.blocks[index].element[0]);
          delete this.blocks[index];
        };
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
          var fragment = this.$document[0].createDocumentFragment();
          blocks.forEach(function(block) {
            fragment.appendChild(block.element[0]);
          });
          return fragment;
        };
        VirtualRepeatController.prototype.updateIndexes_ = function() {
          var itemsLength = this.items ? this.items.length : 0;
          var containerLength = Math.ceil(this.container.getSize() / this.itemSize);
          this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
          this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
          this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
          this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        function VirtualRepeatModelArrayLike(model) {
          if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) {
            throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ');
          }
          this.model = model;
        }
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
          for (var i = start; i < end; i++) {
            if (!this.hasOwnProperty(i)) {
              this[i] = this.model.getItemAtIndex(i);
            }
          }
          this.length = this.model.getLength();
        };
        function abstractMethod() {
          throw Error('Non-overridden abstract method called.');
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.whiteframe', ['material.core']).directive('mdWhiteframe', MdWhiteframeDirective);
        function MdWhiteframeDirective($log) {
          var MIN_DP = 1;
          var MAX_DP = 24;
          var DEFAULT_DP = 4;
          return {
            restrict: 'A',
            link: postLink
          };
          function postLink(scope, element, attr) {
            var elevation = parseInt(attr.mdWhiteframe, 10) || DEFAULT_DP;
            if (elevation > MAX_DP || elevation < MIN_DP) {
              $log.warn('md-whiteframe attribute value is invalid. It should be a number between ' + MIN_DP + ' and ' + MAX_DP, element[0]);
              elevation = DEFAULT_DP;
            }
            element.addClass('md-whiteframe-' + elevation + 'dp');
          }
        }
        MdWhiteframeDirective.$inject = ["$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdAutocompleteCtrl', MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41,
            MAX_HEIGHT = 5.5 * ITEM_HEIGHT,
            MENU_PADDING = 8,
            INPUT_PADDING = 2;
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
          var ctrl = this,
              itemParts = $scope.itemsExpr.split(/ in /i),
              itemExpr = itemParts[1],
              elements = null,
              cache = {},
              noBlur = false,
              selectedItemWatchers = [],
              hasFocus = false,
              lastCount = 0,
              promiseFetch = false;
          defineProperty('hidden', handleHiddenChange, true);
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.itemName = itemParts[0];
          ctrl.matches = [];
          ctrl.loading = false;
          ctrl.hidden = true;
          ctrl.index = null;
          ctrl.messages = [];
          ctrl.id = $mdUtil.nextUid();
          ctrl.isDisabled = null;
          ctrl.isRequired = null;
          ctrl.hasNotFound = false;
          ctrl.keydown = keydown;
          ctrl.blur = blur;
          ctrl.focus = focus;
          ctrl.clear = clearValue;
          ctrl.select = select;
          ctrl.listEnter = onListEnter;
          ctrl.listLeave = onListLeave;
          ctrl.mouseUp = onMouseup;
          ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
          ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
          ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
          ctrl.notFoundVisible = notFoundVisible;
          ctrl.loadingIsVisible = loadingIsVisible;
          return init();
          function init() {
            $mdUtil.initOptionalProperties($scope, $attrs, {
              searchText: null,
              selectedItem: null
            });
            $mdTheming($element);
            configureWatchers();
            $mdUtil.nextTick(function() {
              gatherElements();
              moveDropdown();
              focusElement();
              $element.on('focus', focusElement);
            });
          }
          function positionDropdown() {
            if (!elements)
              return $mdUtil.nextTick(positionDropdown, false, $scope);
            var hrect = elements.wrap.getBoundingClientRect(),
                vrect = elements.snap.getBoundingClientRect(),
                root = elements.root.getBoundingClientRect(),
                top = vrect.bottom - root.top,
                bot = root.bottom - vrect.top,
                left = hrect.left - root.left,
                width = hrect.width,
                offset = getVerticalOffset(),
                styles;
            if ($attrs.mdFloatingLabel) {
              left += INPUT_PADDING;
              width -= INPUT_PADDING * 2;
            }
            styles = {
              left: left + 'px',
              minWidth: width + 'px',
              maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'
            };
            if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
              styles.top = 'auto';
              styles.bottom = bot + 'px';
              styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';
            } else {
              styles.top = (top - offset) + 'px';
              styles.bottom = 'auto';
              styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + 'px';
            }
            elements.$.scrollContainer.css(styles);
            $mdUtil.nextTick(correctHorizontalAlignment, false);
            function getVerticalOffset() {
              var offset = 0;
              var inputContainer = $element.find('md-input-container');
              if (inputContainer.length) {
                var input = inputContainer.find('input');
                offset = inputContainer.prop('offsetHeight');
                offset -= input.prop('offsetTop');
                offset -= input.prop('offsetHeight');
                offset += inputContainer.prop('offsetTop');
              }
              return offset;
            }
            function correctHorizontalAlignment() {
              var dropdown = elements.scrollContainer.getBoundingClientRect(),
                  styles = {};
              if (dropdown.right > root.right - MENU_PADDING) {
                styles.left = (hrect.right - dropdown.width) + 'px';
              }
              elements.$.scrollContainer.css(styles);
            }
          }
          function moveDropdown() {
            if (!elements.$.root.length)
              return;
            $mdTheming(elements.$.scrollContainer);
            elements.$.scrollContainer.detach();
            elements.$.root.append(elements.$.scrollContainer);
            if ($animate.pin)
              $animate.pin(elements.$.scrollContainer, $rootElement);
          }
          function focusElement() {
            if ($scope.autofocus)
              elements.input.focus();
          }
          function configureWatchers() {
            var wait = parseInt($scope.delay, 10) || 0;
            $attrs.$observe('disabled', function(value) {
              ctrl.isDisabled = !!value;
            });
            $attrs.$observe('required', function(value) {
              ctrl.isRequired = !!value;
            });
            $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
            $scope.$watch('selectedItem', selectedItemChange);
            angular.element($window).on('resize', positionDropdown);
            $scope.$on('$destroy', cleanup);
          }
          function cleanup() {
            if (!ctrl.hidden) {
              $mdUtil.enableScrolling();
            }
            angular.element($window).off('resize', positionDropdown);
            if (elements) {
              var items = 'ul scroller scrollContainer input'.split(' ');
              angular.forEach(items, function(key) {
                elements.$[key].remove();
              });
            }
          }
          function gatherElements() {
            elements = {
              main: $element[0],
              scrollContainer: $element[0].getElementsByClassName('md-virtual-repeat-container')[0],
              scroller: $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0],
              ul: $element.find('ul')[0],
              input: $element.find('input')[0],
              wrap: $element.find('md-autocomplete-wrap')[0],
              root: document.body
            };
            elements.li = elements.ul.getElementsByTagName('li');
            elements.snap = getSnapTarget();
            elements.$ = getAngularElements(elements);
          }
          function getSnapTarget() {
            for (var element = $element; element.length; element = element.parent()) {
              if (angular.isDefined(element.attr('md-autocomplete-snap')))
                return element[0];
            }
            return elements.wrap;
          }
          function getAngularElements(elements) {
            var obj = {};
            for (var key in elements) {
              if (elements.hasOwnProperty(key))
                obj[key] = angular.element(elements[key]);
            }
            return obj;
          }
          function handleHiddenChange(hidden, oldHidden) {
            if (!hidden && oldHidden) {
              positionDropdown();
              if (elements) {
                $mdUtil.nextTick(function() {
                  $mdUtil.disableScrollAround(elements.ul);
                }, false, $scope);
              }
            } else if (hidden && !oldHidden) {
              $mdUtil.nextTick(function() {
                $mdUtil.enableScrolling();
              }, false, $scope);
            }
          }
          function onListEnter() {
            noBlur = true;
          }
          function onListLeave() {
            if (!hasFocus)
              elements.input.focus();
            noBlur = false;
            ctrl.hidden = shouldHide();
          }
          function onMouseup() {
            elements.input.focus();
          }
          function selectedItemChange(selectedItem, previousSelectedItem) {
            if (selectedItem) {
              getDisplayValue(selectedItem).then(function(val) {
                $scope.searchText = val;
                handleSelectedItemChange(selectedItem, previousSelectedItem);
              });
            }
            if (selectedItem !== previousSelectedItem)
              announceItemChange();
          }
          function announceItemChange() {
            angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
          }
          function announceTextChange() {
            angular.isFunction($scope.textChange) && $scope.textChange();
          }
          function handleSelectedItemChange(selectedItem, previousSelectedItem) {
            selectedItemWatchers.forEach(function(watcher) {
              watcher(selectedItem, previousSelectedItem);
            });
          }
          function registerSelectedItemWatcher(cb) {
            if (selectedItemWatchers.indexOf(cb) == -1) {
              selectedItemWatchers.push(cb);
            }
          }
          function unregisterSelectedItemWatcher(cb) {
            var i = selectedItemWatchers.indexOf(cb);
            if (i != -1) {
              selectedItemWatchers.splice(i, 1);
            }
          }
          function handleSearchText(searchText, previousSearchText) {
            ctrl.index = getDefaultIndex();
            if (searchText === previousSearchText)
              return;
            getDisplayValue($scope.selectedItem).then(function(val) {
              if (searchText !== val) {
                $scope.selectedItem = null;
                if (searchText !== previousSearchText)
                  announceTextChange();
                if (!isMinLengthMet()) {
                  ctrl.matches = [];
                  setLoading(false);
                  updateMessages();
                } else {
                  handleQuery();
                }
              }
            });
          }
          function blur() {
            hasFocus = false;
            if (!noBlur) {
              ctrl.hidden = shouldHide();
            }
          }
          function doBlur(forceBlur) {
            if (forceBlur) {
              noBlur = false;
              hasFocus = false;
            }
            elements.input.blur();
          }
          function focus() {
            hasFocus = true;
            if (!angular.isString($scope.searchText))
              $scope.searchText = '';
            ctrl.hidden = shouldHide();
            if (!ctrl.hidden)
              handleQuery();
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.DOWN_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.UP_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.TAB:
                onListLeave();
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ENTER:
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                if (hasSelection())
                  return;
                event.stopPropagation();
                event.preventDefault();
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ESCAPE:
                event.stopPropagation();
                event.preventDefault();
                clearValue();
                doBlur(true);
                break;
              default:
            }
          }
          function getMinLength() {
            return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
          }
          function getDisplayValue(item) {
            return $q.when(getItemText(item) || item);
            function getItemText(item) {
              return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
            }
          }
          function getItemAsNameVal(item) {
            if (!item)
              return undefined;
            var locals = {};
            if (ctrl.itemName)
              locals[ctrl.itemName] = item;
            return locals;
          }
          function getDefaultIndex() {
            return $scope.autoselect ? 0 : -1;
          }
          function setLoading(value) {
            if (ctrl.loading != value) {
              ctrl.loading = value;
            }
            ctrl.hidden = shouldHide();
          }
          function shouldHide() {
            if (ctrl.loading && !hasMatches())
              return true;
            else if (hasSelection())
              return true;
            else if (!hasFocus)
              return true;
            else
              return !shouldShow();
          }
          function shouldShow() {
            return (isMinLengthMet() && hasMatches()) || notFoundVisible();
          }
          function hasMatches() {
            return ctrl.matches.length ? true : false;
          }
          function hasSelection() {
            return ctrl.scope.selectedItem ? true : false;
          }
          function loadingIsVisible() {
            return ctrl.loading && !hasSelection();
          }
          function getCurrentDisplayValue() {
            return getDisplayValue(ctrl.matches[ctrl.index]);
          }
          function isMinLengthMet() {
            return ($scope.searchText || '').length >= getMinLength();
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler(newValue, oldValue);
              }
            });
          }
          function select(index) {
            $mdUtil.nextTick(function() {
              getDisplayValue(ctrl.matches[index]).then(function(val) {
                var ngModel = elements.$.input.controller('ngModel');
                ngModel.$setViewValue(val);
                ngModel.$render();
              }).finally(function() {
                $scope.selectedItem = ctrl.matches[index];
                setLoading(false);
              });
            }, false);
          }
          function clearValue() {
            setLoading(true);
            ctrl.index = 0;
            ctrl.matches = [];
            $scope.searchText = '';
            select(-1);
            var eventObj = document.createEvent('CustomEvent');
            eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});
            elements.input.dispatchEvent(eventObj);
            elements.input.focus();
          }
          function fetchResults(searchText) {
            var items = $scope.$parent.$eval(itemExpr),
                term = searchText.toLowerCase();
            if (angular.isArray(items)) {
              handleResults(items);
            } else if (items) {
              setLoading(true);
              promiseFetch = true;
              $mdUtil.nextTick(function() {
                if (items.success)
                  items.success(handleResults);
                if (items.then)
                  items.then(handleResults);
                if (items.finally)
                  items.finally(function() {
                    setLoading(false);
                    promiseFetch = false;
                  });
              }, true, $scope);
            }
            function handleResults(matches) {
              cache[term] = matches;
              if ((searchText || '') !== ($scope.searchText || ''))
                return;
              ctrl.matches = matches;
              ctrl.hidden = shouldHide();
              if ($scope.selectOnMatch)
                selectItemOnMatch();
              updateMessages();
              positionDropdown();
            }
          }
          function updateMessages() {
            getCurrentDisplayValue().then(function(msg) {
              ctrl.messages = [getCountMessage(), msg];
            });
          }
          function getCountMessage() {
            if (lastCount === ctrl.matches.length)
              return '';
            lastCount = ctrl.matches.length;
            switch (ctrl.matches.length) {
              case 0:
                return 'There are no matches available.';
              case 1:
                return 'There is 1 match available.';
              default:
                return 'There are ' + ctrl.matches.length + ' matches available.';
            }
          }
          function updateScroll() {
            if (!elements.li[0])
              return;
            var height = elements.li[0].offsetHeight,
                top = height * ctrl.index,
                bot = top + height,
                hgt = elements.scroller.clientHeight,
                scrollTop = elements.scroller.scrollTop;
            if (top < scrollTop) {
              scrollTo(top);
            } else if (bot > scrollTop + hgt) {
              scrollTo(bot - hgt);
            }
          }
          function scrollTo(offset) {
            elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);
          }
          function notFoundVisible() {
            var textLength = (ctrl.scope.searchText || '').length;
            return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || promiseFetch) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
          }
          function handleQuery() {
            var searchText = $scope.searchText || '',
                term = searchText.toLowerCase();
            if (!$scope.noCache && cache[term]) {
              ctrl.matches = cache[term];
              updateMessages();
            } else {
              fetchResults(searchText);
            }
            ctrl.hidden = shouldHide();
          }
          function selectItemOnMatch() {
            var searchText = $scope.searchText,
                matches = ctrl.matches,
                item = matches[0];
            if (matches.length === 1)
              getDisplayValue(item).then(function(displayValue) {
                if (searchText == displayValue)
                  select(0);
              });
          }
        }
        MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocomplete', MdAutocomplete);
        function MdAutocomplete() {
          return {
            controller: 'MdAutocompleteCtrl',
            controllerAs: '$mdAutocompleteCtrl',
            scope: {
              inputName: '@mdInputName',
              inputMinlength: '@mdInputMinlength',
              inputMaxlength: '@mdInputMaxlength',
              searchText: '=?mdSearchText',
              selectedItem: '=?mdSelectedItem',
              itemsExpr: '@mdItems',
              itemText: '&mdItemText',
              placeholder: '@placeholder',
              noCache: '=?mdNoCache',
              selectOnMatch: '=?mdSelectOnMatch',
              itemChange: '&?mdSelectedItemChange',
              textChange: '&?mdSearchTextChange',
              minLength: '=?mdMinLength',
              delay: '=?mdDelay',
              autofocus: '=?mdAutofocus',
              floatingLabel: '@?mdFloatingLabel',
              autoselect: '=?mdAutoselect',
              menuClass: '@?mdMenuClass',
              inputId: '@?mdInputId'
            },
            link: function(scope, element, attrs, controller) {
              controller.hasNotFound = !!element.attr('md-has-not-found');
            },
            template: function(element, attr) {
              var noItemsTemplate = getNoItemsTemplate(),
                  itemTemplate = getItemTemplate(),
                  leftover = element.html(),
                  tabindex = attr.tabindex;
              if (noItemsTemplate)
                element.attr('md-has-not-found', true);
              if (!attr.hasOwnProperty('tabindex'))
                element.attr('tabindex', '-1');
              return '\
        <md-autocomplete-wrap\
            layout="row"\
            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"\
            role="listbox">\
          ' + getInputElement() + '\
          <md-progress-linear\
              class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\
              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\
              md-mode="indeterminate"></md-progress-linear>\
          <md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min="1"\
              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\
              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\
              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\
              ng-hide="$mdAutocompleteCtrl.hidden"\
              class="md-autocomplete-suggestions-container md-whiteframe-z1"\
              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
              role="presentation">\
            <ul class="md-autocomplete-suggestions"\
                ng-class="::menuClass"\
                id="ul-{{$mdAutocompleteCtrl.id}}">\
              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"\
                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"\
                  ng-click="$mdAutocompleteCtrl.select($index)"\
                  md-extra-name="$mdAutocompleteCtrl.itemName">\
                  ' + itemTemplate + '\
                  </li>' + noItemsTemplate + '\
            </ul>\
          </md-virtual-repeat-container>\
        </md-autocomplete-wrap>\
        <aria-status\
            class="md-visually-hidden"\
            role="status"\
            aria-live="assertive">\
          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>\
        </aria-status>';
              function getItemTemplate() {
                var templateTag = element.find('md-item-template').detach(),
                    html = templateTag.length ? templateTag.html() : element.html();
                if (!templateTag.length)
                  element.empty();
                return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html + '</md-autocomplete-parent-scope>';
              }
              function getNoItemsTemplate() {
                var templateTag = element.find('md-not-found').detach(),
                    template = templateTag.length ? templateTag.html() : '';
                return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\
                         md-autocomplete-parent-scope>' + template + '</li>' : '';
              }
              function getInputElement() {
                if (attr.mdFloatingLabel) {
                  return '\
            <md-input-container flex ng-if="floatingLabel">\
              <label>{{floatingLabel}}</label>\
              <input type="search"\
                  ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\
                  name="{{inputName}}"\
                  autocomplete="off"\
                  ng-required="$mdAutocompleteCtrl.isRequired"\
                  ng-minlength="inputMinlength"\
                  ng-maxlength="inputMaxlength"\
                  ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                  ng-model="$mdAutocompleteCtrl.scope.searchText"\
                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                  ng-blur="$mdAutocompleteCtrl.blur()"\
                  ng-focus="$mdAutocompleteCtrl.focus()"\
                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                  aria-label="{{floatingLabel}}"\
                  aria-autocomplete="list"\
                  aria-haspopup="true"\
                  aria-activedescendant=""\
                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\
            </md-input-container>';
                } else {
                  return '\
            <input flex type="search"\
                ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\
                name="{{inputName}}"\
                ng-if="!floatingLabel"\
                autocomplete="off"\
                ng-required="$mdAutocompleteCtrl.isRequired"\
                ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                ng-model="$mdAutocompleteCtrl.scope.searchText"\
                ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                ng-blur="$mdAutocompleteCtrl.blur()"\
                ng-focus="$mdAutocompleteCtrl.focus()"\
                placeholder="{{placeholder}}"\
                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                aria-label="{{placeholder}}"\
                aria-autocomplete="list"\
                aria-haspopup="true"\
                aria-activedescendant=""\
                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
            <button\
                type="button"\
                tabindex="-1"\
                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"\
                ng-click="$mdAutocompleteCtrl.clear()">\
              <md-icon md-svg-icon="md-close"></md-icon>\
              <span class="md-visually-hidden">Clear</span>\
            </button>\
                ';
                }
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective);
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
          return {
            restrict: 'AE',
            compile: compile,
            terminal: true,
            transclude: 'element'
          };
          function compile(tElement, tAttr, transclude) {
            return function postLink(scope, element, attr) {
              var ctrl = scope.$mdAutocompleteCtrl;
              var newScope = ctrl.parent.$new();
              var itemName = ctrl.itemName;
              watchVariable('$index', '$index');
              watchVariable('item', itemName);
              connectScopes();
              transclude(newScope, function(clone) {
                element.after(clone);
              });
              function watchVariable(variable, alias) {
                newScope[alias] = scope[variable];
                scope.$watch(variable, function(value) {
                  $mdUtil.nextTick(function() {
                    newScope[alias] = value;
                  });
                });
              }
              function connectScopes() {
                var scopeDigesting = false;
                var newScopeDigesting = false;
                scope.$watch(function() {
                  if (newScopeDigesting || scopeDigesting) {
                    return;
                  }
                  scopeDigesting = true;
                  scope.$$postDigest(function() {
                    if (!newScopeDigesting) {
                      newScope.$digest();
                    }
                    scopeDigesting = newScopeDigesting = false;
                  });
                });
                newScope.$watch(function() {
                  newScopeDigesting = true;
                });
              }
            };
          }
        }
        MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdHighlightCtrl', MdHighlightCtrl);
        function MdHighlightCtrl($scope, $element, $attrs) {
          this.init = init;
          function init(termExpr, unsafeTextExpr) {
            var text = null,
                regex = null,
                flags = $attrs.mdHighlightFlags || '',
                watcher = $scope.$watch(function($scope) {
                  return {
                    term: termExpr($scope),
                    unsafeText: unsafeTextExpr($scope)
                  };
                }, function(state, prevState) {
                  if (text === null || state.unsafeText !== prevState.unsafeText) {
                    text = angular.element('<div>').text(state.unsafeText).html();
                  }
                  if (regex === null || state.term !== prevState.term) {
                    regex = getRegExp(state.term, flags);
                  }
                  $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, true);
            $element.on('$destroy', watcher);
          }
          function sanitize(term) {
            return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, '\\$&');
          }
          function getRegExp(text, flags) {
            var str = '';
            if (flags.indexOf('^') >= 1)
              str += '^';
            str += text;
            if (flags.indexOf('$') >= 1)
              str += '$';
            return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, ''));
          }
        }
        MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdHighlightText', MdHighlight);
        function MdHighlight($interpolate, $parse) {
          return {
            terminal: true,
            controller: 'MdHighlightCtrl',
            compile: function mdHighlightCompile(tElement, tAttr) {
              var termExpr = $parse(tAttr.mdHighlightText);
              var unsafeTextExpr = $interpolate(tElement.html());
              return function mdHighlightLink(scope, element, attr, ctrl) {
                ctrl.init(termExpr, unsafeTextExpr);
              };
            }
          };
        }
        MdHighlight.$inject = ["$interpolate", "$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChip', MdChip);
        var DELETE_HINT_TEMPLATE = '\
    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">\
      {{$mdChipsCtrl.deleteHint}}\
    </span>';
        function MdChip($mdTheming, $mdUtil) {
          var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
          return {
            restrict: 'E',
            require: '^?mdChips',
            compile: compile
          };
          function compile(element, attr) {
            element.append($mdUtil.processTemplate(hintTemplate));
            return function postLink(scope, element, attr, ctrl) {
              element.addClass('md-chip');
              $mdTheming(element);
              if (ctrl)
                angular.element(element[0].querySelector('.md-chip-content')).on('blur', function() {
                  ctrl.selectedChip = -1;
                });
            };
          }
        }
        MdChip.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipRemove', MdChipRemove);
        function MdChipRemove($timeout) {
          return {
            restrict: 'A',
            require: '^mdChips',
            scope: false,
            link: postLink
          };
          function postLink(scope, element, attr, ctrl) {
            element.on('click', function(event) {
              scope.$apply(function() {
                ctrl.removeChip(scope.$$replacedScope.$index);
              });
            });
            $timeout(function() {
              element.attr({
                tabindex: -1,
                'aria-hidden': true
              });
              element.find('button').attr('tabindex', '-1');
            });
          }
        }
        MdChipRemove.$inject = ["$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipTransclude', MdChipTransclude);
        function MdChipTransclude($compile) {
          return {
            restrict: 'EA',
            terminal: true,
            link: link,
            scope: false
          };
          function link(scope, element, attr) {
            var ctrl = scope.$parent.$mdChipsCtrl,
                newScope = ctrl.parent.$new(false, ctrl.parent);
            newScope.$$replacedScope = scope;
            newScope.$chip = scope.$chip;
            newScope.$index = scope.$index;
            newScope.$mdChipsCtrl = ctrl;
            var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
            element.html(newHtml);
            $compile(element.contents())(newScope);
          }
        }
        MdChipTransclude.$inject = ["$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdChipsCtrl', MdChipsCtrl);
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout) {
          this.$timeout = $timeout;
          this.$mdConstant = $mdConstant;
          this.$scope = $scope;
          this.parent = $scope.$parent;
          this.$log = $log;
          this.$element = $element;
          this.ngModelCtrl = null;
          this.userInputNgModelCtrl = null;
          this.userInputElement = null;
          this.items = [];
          this.selectedChip = -1;
          this.hasAutocomplete = false;
          this.deleteHint = 'Press delete to remove this chip.';
          this.deleteButtonLabel = 'Remove';
          this.chipBuffer = '';
          this.useOnAppend = false;
          this.useTransformChip = false;
          this.useOnAdd = false;
          this.useOnRemove = false;
          this.useOnSelect = false;
        }
        MdChipsCtrl.$inject = ["$scope", "$mdConstant", "$log", "$element", "$timeout"];
        MdChipsCtrl.prototype.inputKeydown = function(event) {
          var chipBuffer = this.getChipBuffer();
          if (this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented()) {
            return;
          }
          if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
            if (chipBuffer)
              return;
            event.preventDefault();
            event.stopPropagation();
            if (this.items.length)
              this.selectAndFocusChipSafe(this.items.length - 1);
            return;
          }
          if (!this.separatorKeys || this.separatorKeys.length < 1) {
            this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
          }
          if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
            if ((this.hasAutocomplete && this.requireMatch) || !chipBuffer)
              return;
            event.preventDefault();
            this.appendChip(chipBuffer);
            this.resetChipBuffer();
          }
        };
        MdChipsCtrl.prototype.chipKeydown = function(event) {
          if (this.getChipBuffer())
            return;
          switch (event.keyCode) {
            case this.$mdConstant.KEY_CODE.BACKSPACE:
            case this.$mdConstant.KEY_CODE.DELETE:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.removeAndSelectAdjacentChip(this.selectedChip);
              break;
            case this.$mdConstant.KEY_CODE.LEFT_ARROW:
              event.preventDefault();
              if (this.selectedChip < 0)
                this.selectedChip = this.items.length;
              if (this.items.length)
                this.selectAndFocusChipSafe(this.selectedChip - 1);
              break;
            case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
              event.preventDefault();
              this.selectAndFocusChipSafe(this.selectedChip + 1);
              break;
            case this.$mdConstant.KEY_CODE.ESCAPE:
            case this.$mdConstant.KEY_CODE.TAB:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.onFocus();
              break;
          }
        };
        MdChipsCtrl.prototype.getPlaceholder = function() {
          var useSecondary = (this.items.length && (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));
          return useSecondary ? this.secondaryPlaceholder : this.placeholder;
        };
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
          var selIndex = this.getAdjacentChipIndex(index);
          this.removeChip(index);
          this.$timeout(angular.bind(this, function() {
            this.selectAndFocusChipSafe(selIndex);
          }));
        };
        MdChipsCtrl.prototype.resetSelectedChip = function() {
          this.selectedChip = -1;
        };
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
          var len = this.items.length - 1;
          return (len == 0) ? -1 : (index == len) ? index - 1 : index;
        };
        MdChipsCtrl.prototype.appendChip = function(newChip) {
          if (this.useTransformChip && this.transformChip) {
            var transformedChip = this.transformChip({'$chip': newChip});
            if (angular.isDefined(transformedChip)) {
              newChip = transformedChip;
            }
          }
          if (angular.isObject(newChip)) {
            var identical = this.items.some(function(item) {
              return angular.equals(newChip, item);
            });
            if (identical)
              return;
          }
          if (newChip == null || this.items.indexOf(newChip) + 1)
            return;
          var index = this.items.push(newChip);
          if (this.useOnAdd && this.onAdd) {
            this.onAdd({
              '$chip': newChip,
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.useOnAppendExpression = function() {
          this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");
          if (!this.useTransformChip || !this.transformChip) {
            this.useTransformChip = true;
            this.transformChip = this.onAppend;
          }
        };
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
          this.useTransformChip = true;
        };
        MdChipsCtrl.prototype.useOnAddExpression = function() {
          this.useOnAdd = true;
        };
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
          this.useOnRemove = true;
        };
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
          this.useOnSelect = true;
        };
        MdChipsCtrl.prototype.getChipBuffer = function() {
          return !this.userInputElement ? this.chipBuffer : this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value;
        };
        MdChipsCtrl.prototype.resetChipBuffer = function() {
          if (this.userInputElement) {
            if (this.userInputNgModelCtrl) {
              this.userInputNgModelCtrl.$setViewValue('');
              this.userInputNgModelCtrl.$render();
            } else {
              this.userInputElement[0].value = '';
            }
          } else {
            this.chipBuffer = '';
          }
        };
        MdChipsCtrl.prototype.removeChip = function(index) {
          var removed = this.items.splice(index, 1);
          if (removed && removed.length && this.useOnRemove && this.onRemove) {
            this.onRemove({
              '$chip': removed[0],
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
          this.removeChip(index);
          this.onFocus();
        };
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
          if (!this.items.length) {
            this.selectChip(-1);
            this.onFocus();
            return;
          }
          if (index === this.items.length)
            return this.onFocus();
          index = Math.max(index, 0);
          index = Math.min(index, this.items.length - 1);
          this.selectChip(index);
          this.focusChip(index);
        };
        MdChipsCtrl.prototype.selectChip = function(index) {
          if (index >= -1 && index <= this.items.length) {
            this.selectedChip = index;
            if (this.useOnSelect && this.onSelect) {
              this.onSelect({'$chip': this.items[this.selectedChip]});
            }
          } else {
            this.$log.warn('Selected Chip index out of bounds; ignoring.');
          }
        };
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
          this.selectChip(index);
          if (index != -1) {
            this.focusChip(index);
          }
        };
        MdChipsCtrl.prototype.focusChip = function(index) {
          this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content').focus();
        };
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
          this.ngModelCtrl = ngModelCtrl;
          var self = this;
          ngModelCtrl.$render = function() {
            self.items = self.ngModelCtrl.$viewValue;
          };
        };
        MdChipsCtrl.prototype.onFocus = function() {
          var input = this.$element[0].querySelector('input');
          input && input.focus();
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
          this.inputHasFocus = true;
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
          this.inputHasFocus = false;
        };
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
          this.userInputElement = inputElement;
          var ngModelCtrl = inputElement.controller('ngModel');
          if (ngModelCtrl != this.ngModelCtrl) {
            this.userInputNgModelCtrl = ngModelCtrl;
          }
          var scope = this.$scope;
          var ctrl = this;
          var scopeApplyFn = function(event, fn) {
            scope.$evalAsync(angular.bind(ctrl, fn, event));
          };
          inputElement.attr({tabindex: 0}).on('keydown', function(event) {
            scopeApplyFn(event, ctrl.inputKeydown);
          }).on('focus', function(event) {
            scopeApplyFn(event, ctrl.onInputFocus);
          }).on('blur', function(event) {
            scopeApplyFn(event, ctrl.onInputBlur);
          });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
          if (ctrl) {
            this.hasAutocomplete = true;
            ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
              if (item) {
                this.appendChip(item);
                this.resetChipBuffer();
              }
            }));
            this.$element.find('input').on('focus', angular.bind(this, this.onInputFocus)).on('blur', angular.bind(this, this.onInputBlur));
          }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
          return this.inputHasFocus || this.selectedChip >= 0;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChips', MdChips);
        var MD_CHIPS_TEMPLATE = '\
      <md-chips-wrap\
          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"\
          ng-keydown="$mdChipsCtrl.chipKeydown($event)"\
          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"\
          class="md-chips">\
        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\
            index="{{$index}}"\
            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">\
          <div class="md-chip-content"\
              tabindex="-1"\
              aria-hidden="true"\
              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\
              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\
          <div ng-if="!$mdChipsCtrl.readonly"\
               class="md-chip-remove-container"\
               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\
        </md-chip>\
        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"\
            class="md-chip-input-container"\
            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\
        </div>\
      </md-chips-wrap>';
        var CHIP_INPUT_TEMPLATE = '\
        <input\
            class="md-input"\
            tabindex="0"\
            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\
            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"\
            ng-model="$mdChipsCtrl.chipBuffer"\
            ng-focus="$mdChipsCtrl.onInputFocus()"\
            ng-blur="$mdChipsCtrl.onInputBlur()"\
            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';
        var CHIP_DEFAULT_TEMPLATE = '\
      <span>{{$chip}}</span>';
        var CHIP_REMOVE_TEMPLATE = '\
      <button\
          class="md-chip-remove"\
          ng-if="!$mdChipsCtrl.readonly"\
          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"\
          type="button"\
          aria-hidden="true"\
          tabindex="-1">\
        <md-icon md-svg-icon="md-close"></md-icon>\
        <span class="md-visually-hidden">\
          {{$mdChipsCtrl.deleteButtonLabel}}\
        </span>\
      </button>';
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout) {
          var templates = getTemplates();
          return {
            template: function(element, attrs) {
              attrs['$mdUserTemplate'] = element.clone();
              return templates.chips;
            },
            require: ['mdChips'],
            restrict: 'E',
            controller: 'MdChipsCtrl',
            controllerAs: '$mdChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              readonly: '=readonly',
              placeholder: '@',
              secondaryPlaceholder: '@',
              transformChip: '&mdTransformChip',
              onAppend: '&mdOnAppend',
              onAdd: '&mdOnAdd',
              onRemove: '&mdOnRemove',
              onSelect: '&mdOnSelect',
              deleteHint: '@',
              deleteButtonLabel: '@',
              separatorKeys: '=?mdSeparatorKeys',
              requireMatch: '=?mdRequireMatch'
            }
          };
          function compile(element, attr) {
            var userTemplate = attr['$mdUserTemplate'];
            attr['$mdUserTemplate'] = null;
            var chipRemoveTemplate = getTemplateByQuery('md-chips>*[md-chip-remove]') || templates.remove,
                chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || templates.default,
                chipInputTemplate = getTemplateByQuery('md-chips>md-autocomplete') || getTemplateByQuery('md-chips>input') || templates.input,
                staticChips = userTemplate.find('md-chip');
            if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {
              $log.warn('invalid placement of md-chip-remove within md-chip-template.');
            }
            function getTemplateByQuery(query) {
              if (!attr.ngModel)
                return;
              var element = userTemplate[0].querySelector(query);
              return element && element.outerHTML;
            }
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              var mdChipsCtrl = controllers[0];
              mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
              mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
              mdChipsCtrl.chipInputTemplate = chipInputTemplate;
              element.attr({
                'aria-hidden': true,
                tabindex: -1
              }).on('focus', function() {
                mdChipsCtrl.onFocus();
              });
              if (attr.ngModel) {
                mdChipsCtrl.configureNgModel(element.controller('ngModel'));
                if (attrs.mdTransformChip)
                  mdChipsCtrl.useTransformChipExpression();
                if (attrs.mdOnAppend)
                  mdChipsCtrl.useOnAppendExpression();
                if (attrs.mdOnAdd)
                  mdChipsCtrl.useOnAddExpression();
                if (attrs.mdOnRemove)
                  mdChipsCtrl.useOnRemoveExpression();
                if (attrs.mdOnSelect)
                  mdChipsCtrl.useOnSelectExpression();
                if (chipInputTemplate != templates.input) {
                  scope.$watch('$mdChipsCtrl.readonly', function(readonly) {
                    if (!readonly) {
                      $mdUtil.nextTick(function() {
                        if (chipInputTemplate.indexOf('<md-autocomplete') === 0)
                          mdChipsCtrl.configureAutocomplete(element.find('md-autocomplete').controller('mdAutocomplete'));
                        mdChipsCtrl.configureUserInput(element.find('input'));
                      });
                    }
                  });
                }
                $mdUtil.nextTick(function() {
                  var input = element.find('input');
                  input && input.toggleClass('md-input', true);
                });
              }
              if (staticChips.length > 0) {
                var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                $timeout(function() {
                  element.find('md-chips-wrap').prepend(compiledStaticChips);
                });
              }
            };
          }
          function getTemplates() {
            return {
              chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
              input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
              default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
              remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
            };
          }
        }
        MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdContactChipsCtrl', MdContactChipsCtrl);
        function MdContactChipsCtrl() {
          this.selectedItem = null;
          this.searchText = '';
        }
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
          var results = this.contactQuery({'$query': searchText});
          return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
          return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
          return this.contacts.indexOf(contact) == -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdContactChips', MdContactChips);
        var MD_CONTACT_CHIPS_TEMPLATE = '\
      <md-chips class="md-contact-chips"\
          ng-model="$mdContactChipsCtrl.contacts"\
          md-require-match="$mdContactChipsCtrl.requireMatch"\
          md-autocomplete-snap>\
          <md-autocomplete\
              md-menu-class="md-contact-chips-suggestions"\
              md-selected-item="$mdContactChipsCtrl.selectedItem"\
              md-search-text="$mdContactChipsCtrl.searchText"\
              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\
              md-item-text="$mdContactChipsCtrl.itemName(item)"\
              md-no-cache="true"\
              md-autoselect\
              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?\
                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\
            <div class="md-contact-suggestion">\
              <img \
                  ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{item[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="item[$mdContactChipsCtrl.contactImage]" />\
              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\
                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\
                {{item[$mdContactChipsCtrl.contactName]}}\
              </span>\
              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\
            </div>\
          </md-autocomplete>\
          <md-chip-template>\
            <div class="md-contact-avatar">\
              <img \
                  ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\
            </div>\
            <div class="md-contact-name">\
              {{$chip[$mdContactChipsCtrl.contactName]}}\
            </div>\
          </md-chip-template>\
      </md-chips>';
        function MdContactChips($mdTheming, $mdUtil) {
          return {
            template: function(element, attrs) {
              return MD_CONTACT_CHIPS_TEMPLATE;
            },
            restrict: 'E',
            controller: 'MdContactChipsCtrl',
            controllerAs: '$mdContactChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              contactQuery: '&mdContacts',
              placeholder: '@',
              secondaryPlaceholder: '@',
              contactName: '@mdContactName',
              contactImage: '@mdContactImage',
              contactEmail: '@mdContactEmail',
              contacts: '=ngModel',
              requireMatch: '=?mdRequireMatch',
              highlightFlags: '@?mdHighlightFlags'
            }
          };
          function compile(element, attr) {
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              element.attr('tabindex', '-1');
            };
          }
        }
        MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', mdIconDirective]);
        function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
          return {
            scope: {
              fontSet: '@mdFontSet',
              fontIcon: '@mdFontIcon',
              svgIcon: '@mdSvgIcon',
              svgSrc: '@mdSvgSrc'
            },
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            prepareForFontIcon();
            var label = attr.alt || scope.fontIcon || scope.svgIcon || element.text();
            var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');
            if (!attr['aria-label']) {
              if (label != '' && !parentsHaveText()) {
                $mdAria.expect(element, 'aria-label', label);
                $mdAria.expect(element, 'role', 'img');
              } else if (!element.text()) {
                $mdAria.expect(element, 'aria-hidden', 'true');
              }
            }
            if (attrName) {
              attr.$observe(attrName, function(attrVal) {
                element.empty();
                if (attrVal) {
                  $mdIcon(attrVal).then(function(svg) {
                    element.empty();
                    element.append(svg);
                  });
                }
              });
            }
            function parentsHaveText() {
              var parent = element.parent();
              if (parent.attr('aria-label') || parent.text()) {
                return true;
              } else if (parent.parent().attr('aria-label') || parent.parent().text()) {
                return true;
              }
              return false;
            }
            function prepareForFontIcon() {
              if (!scope.svgIcon && !scope.svgSrc) {
                if (scope.fontIcon) {
                  element.addClass('md-font ' + scope.fontIcon);
                }
                element.addClass($mdIcon.fontSet(scope.fontSet));
              }
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').provider('$mdIcon', MdIconProvider);
        var config = {
          defaultViewBoxSize: 24,
          defaultFontSet: 'material-icons',
          fontSets: []
        };
        function MdIconProvider() {}
        MdIconProvider.prototype = {
          icon: function(id, url, viewBoxSize) {
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          iconSet: function(id, url, viewBoxSize) {
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          defaultIconSet: function(url, viewBoxSize) {
            var setName = '$default';
            if (!config[setName]) {
              config[setName] = new ConfigurationItem(url, viewBoxSize);
            }
            config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
            return this;
          },
          defaultViewBoxSize: function(viewBoxSize) {
            config.defaultViewBoxSize = viewBoxSize;
            return this;
          },
          fontSet: function fontSet(alias, className) {
            config.fontSets.push({
              alias: alias,
              fontSet: className || alias
            });
            return this;
          },
          defaultFontSet: function defaultFontSet(className) {
            config.defaultFontSet = !className ? '' : className;
            return this;
          },
          defaultIconSize: function defaultIconSize(iconSize) {
            config.defaultIconSize = iconSize;
            return this;
          },
          preloadIcons: function($templateCache) {
            var iconProvider = this;
            var svgRegistry = [{
              id: 'md-tabs-arrow',
              url: 'md-tabs-arrow.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
            }, {
              id: 'md-close',
              url: 'md-close.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
            }, {
              id: 'md-cancel',
              url: 'md-cancel.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
            }, {
              id: 'md-menu',
              url: 'md-menu.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>'
            }, {
              id: 'md-toggle-arrow',
              url: 'md-toggle-arrow-svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>'
            }, {
              id: 'md-calendar',
              url: 'md-calendar.svg',
              svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>'
            }];
            svgRegistry.forEach(function(asset) {
              iconProvider.icon(asset.id, asset.url);
              $templateCache.put(asset.url, asset.svg);
            });
          },
          $get: ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {
            this.preloadIcons($templateCache);
            return MdIconService(config, $http, $q, $log, $templateCache);
          }]
        };
        function ConfigurationItem(url, viewBoxSize) {
          this.url = url;
          this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        function MdIconService(config, $http, $q, $log, $templateCache) {
          var iconCache = {};
          var urlRegex = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i;
          Icon.prototype = {
            clone: cloneSVG,
            prepare: prepareAndStyle
          };
          getIcon.fontSet = findRegisteredFontSet;
          return getIcon;
          function getIcon(id) {
            id = id || '';
            if (iconCache[id])
              return $q.when(iconCache[id].clone());
            if (urlRegex.test(id))
              return loadByURL(id).then(cacheIcon(id));
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            var load = config[id] ? loadByID : loadFromIconSet;
            return load(id).then(cacheIcon(id));
          }
          function findRegisteredFontSet(alias) {
            var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
            if (useDefault)
              return config.defaultFontSet;
            var result = alias;
            angular.forEach(config.fontSets, function(it) {
              if (it.alias == alias)
                result = it.fontSet || result;
            });
            return result;
          }
          function cacheIcon(id) {
            return function updateCache(icon) {
              iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
              return iconCache[id].clone();
            };
          }
          function loadByID(id) {
            var iconConfig = config[id];
            return loadByURL(iconConfig.url).then(function(icon) {
              return new Icon(icon, iconConfig);
            });
          }
          function loadFromIconSet(id) {
            var setName = id.substring(0, id.lastIndexOf(':')) || '$default';
            var iconSetConfig = config[setName];
            return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);
            function extractFromSet(set) {
              var iconName = id.slice(id.lastIndexOf(':') + 1);
              var icon = set.querySelector('#' + iconName);
              return !icon ? announceIdNotFound(id) : new Icon(icon, iconSetConfig);
            }
            function announceIdNotFound(id) {
              var msg = 'icon ' + id + ' not found';
              $log.warn(msg);
              return $q.reject(msg || id);
            }
          }
          function loadByURL(url) {
            return $http.get(url, {cache: $templateCache}).then(function(response) {
              return angular.element('<div>').append(response.data).find('svg')[0];
            }).catch(announceNotFound);
          }
          function announceNotFound(err) {
            var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);
            $log.warn(msg);
            return $q.reject(msg);
          }
          function isIcon(target) {
            return angular.isDefined(target.element) && angular.isDefined(target.config);
          }
          function Icon(el, config) {
            if (el && el.tagName != 'svg') {
              el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0];
            }
            if (!el.getAttribute('xmlns')) {
              el.setAttribute('xmlns', "http://www.w3.org/2000/svg");
            }
            this.element = el;
            this.config = config;
            this.prepare();
          }
          function prepareAndStyle() {
            var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
            angular.forEach({
              'fit': '',
              'height': '100%',
              'width': '100%',
              'preserveAspectRatio': 'xMidYMid meet',
              'viewBox': this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize)
            }, function(val, attr) {
              this.element.setAttribute(attr, val);
            }, this);
          }
          function cloneSVG() {
            return this.element.cloneNode(true);
          }
        }
        MdIconService.$inject = ["config", "$http", "$q", "$log", "$templateCache"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuBarController', MenuBarController);
        var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen'];
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$mdConstant = $mdConstant;
          this.$mdUtil = $mdUtil;
          this.$document = $document;
          this.$scope = $scope;
          this.$rootScope = $rootScope;
          this.$timeout = $timeout;
          var self = this;
          angular.forEach(BOUND_MENU_METHODS, function(methodName) {
            self[methodName] = angular.bind(self, self[methodName]);
          });
        }
        MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
        MenuBarController.prototype.init = function() {
          var $element = this.$element;
          var $mdUtil = this.$mdUtil;
          var $scope = this.$scope;
          var self = this;
          var deregisterFns = [];
          $element.on('keydown', this.handleKeyDown);
          this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR');
          deregisterFns.push(this.$rootScope.$on('$mdMenuOpen', function(event, el) {
            if (self.getMenus().indexOf(el[0]) != -1) {
              $element[0].classList.add('md-open');
              el[0].classList.add('md-open');
              self.currentlyOpenMenu = el.controller('mdMenu');
              self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
              self.enableOpenOnHover();
            }
          }));
          deregisterFns.push(this.$rootScope.$on('$mdMenuClose', function(event, el, opts) {
            var rootMenus = self.getMenus();
            if (rootMenus.indexOf(el[0]) != -1) {
              $element[0].classList.remove('md-open');
              el[0].classList.remove('md-open');
            }
            if ($element[0].contains(el[0])) {
              var parentMenu = el[0];
              while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {
                parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);
              }
              if (parentMenu) {
                if (!opts.skipFocus)
                  parentMenu.querySelector('button:not([disabled])').focus();
                self.currentlyOpenMenu = undefined;
                self.disableOpenOnHover();
                self.setKeyboardMode(true);
              }
            }
          }));
          $scope.$on('$destroy', function() {
            while (deregisterFns.length) {
              deregisterFns.shift()();
            }
          });
          this.setKeyboardMode(true);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
          if (enabled)
            this.$element[0].classList.add('md-keyboard-mode');
          else
            this.$element[0].classList.remove('md-keyboard-mode');
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
          if (this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = true;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute('style');
            parentToolbar.style.position = 'relative';
            parentToolbar.style.zIndex = 100;
          }
          angular.element(this.getMenus()).on('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
          this.setKeyboardMode(false);
          if (this.openOnHoverEnabled) {
            this.scheduleOpenHoveredMenu(e);
          }
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
          if (!this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = false;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.style.cssText = parentToolbar.dataset.mdRestoreStyle || '';
          }
          angular.element(this.getMenus()).off('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
          var menuEl = angular.element(e.currentTarget);
          var menuCtrl = menuEl.controller('mdMenu');
          this.setKeyboardMode(false);
          this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
          var self = this;
          var $timeout = this.$timeout;
          if (menuCtrl != self.currentlyOpenMenu) {
            $timeout.cancel(self.pendingMenuOpen);
            self.pendingMenuOpen = $timeout(function() {
              self.pendingMenuOpen = undefined;
              if (self.currentlyOpenMenu) {
                self.currentlyOpenMenu.close(true, {closeAll: true});
              }
              menuCtrl.open();
            }, 200, false);
          }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
          var keyCodes = this.$mdConstant.KEY_CODE;
          var currentMenu = this.currentlyOpenMenu;
          var wasOpen = currentMenu && currentMenu.isOpen;
          this.setKeyboardMode(true);
          var handled,
              newMenu,
              newMenuCtrl;
          switch (e.keyCode) {
            case keyCodes.DOWN_ARROW:
              if (currentMenu) {
                currentMenu.focusMenuContainer();
              } else {
                this.openFocusedMenu();
              }
              handled = true;
              break;
            case keyCodes.UP_ARROW:
              currentMenu && currentMenu.close();
              handled = true;
              break;
            case keyCodes.LEFT_ARROW:
              newMenu = this.focusMenu(-1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
            case keyCodes.RIGHT_ARROW:
              newMenu = this.focusMenu(+1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
          }
          if (handled) {
            e && e.preventDefault && e.preventDefault();
            e && e.stopImmediatePropagation && e.stopImmediatePropagation();
          }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
          var menus = this.getMenus();
          var focusedIndex = this.getFocusedMenuIndex();
          if (focusedIndex == -1) {
            focusedIndex = this.getOpenMenuIndex();
          }
          var changed = false;
          if (focusedIndex == -1) {
            focusedIndex = 0;
          } else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
            focusedIndex += direction;
            changed = true;
          }
          if (changed) {
            menus[focusedIndex].querySelector('button').focus();
            return menus[focusedIndex];
          }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
          var menu = this.getFocusedMenu();
          menu && angular.element(menu).controller('mdMenu').open();
        };
        MenuBarController.prototype.getMenus = function() {
          var $element = this.$element;
          return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
            return el.nodeName == 'MD-MENU';
          });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
          return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
          var $mdUtil = this.$mdUtil;
          var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, 'MD-MENU');
          if (!focusedEl)
            return -1;
          var focusedIndex = this.getMenus().indexOf(focusedEl);
          return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
          var menus = this.getMenus();
          for (var i = 0; i < menus.length; ++i) {
            if (menus[i].classList.contains('md-open'))
              return i;
          }
          return -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuBar', MenuBarDirective);
        function MenuBarDirective($mdUtil, $mdTheming) {
          return {
            restrict: 'E',
            require: 'mdMenuBar',
            controller: 'MenuBarController',
            compile: function compile(templateEl, templateAttrs) {
              if (!templateAttrs.ariaRole) {
                templateEl[0].setAttribute('role', 'menubar');
              }
              angular.forEach(templateEl[0].children, function(menuEl) {
                if (menuEl.nodeName == 'MD-MENU') {
                  if (!menuEl.hasAttribute('md-position-mode')) {
                    menuEl.setAttribute('md-position-mode', 'left bottom');
                    menuEl.querySelector('button,a').setAttribute('role', 'menuitem');
                  }
                  var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content'));
                  angular.forEach(contentEls, function(contentEl) {
                    contentEl.classList.add('md-menu-bar-menu');
                    contentEl.classList.add('md-dense');
                    if (!contentEl.hasAttribute('width')) {
                      contentEl.setAttribute('width', 5);
                    }
                  });
                }
              });
              return function postLink(scope, el, attrs, ctrl) {
                $mdTheming(scope, el);
                ctrl.init();
              };
            }
          };
        }
        MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuDivider', MenuDividerDirective);
        function MenuDividerDirective() {
          return {
            restrict: 'E',
            compile: function(templateEl, templateAttrs) {
              if (!templateAttrs.role) {
                templateEl[0].setAttribute('role', 'separator');
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuItemController', MenuItemController);
        function MenuItemController($scope, $element, $attrs) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$scope = $scope;
        }
        MenuItemController.$inject = ["$scope", "$element", "$attrs"];
        MenuItemController.prototype.init = function(ngModel) {
          var $element = this.$element;
          var $attrs = this.$attrs;
          this.ngModel = ngModel;
          if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {
            this.mode = $attrs.type;
            this.iconEl = $element[0].children[0];
            this.buttonEl = $element[0].children[1];
            if (ngModel) {
              this.initClickListeners();
            }
          }
        };
        MenuItemController.prototype.clearNgAria = function() {
          var el = this.$element[0];
          var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked'];
          angular.forEach(clearAttrs, function(attr) {
            el.removeAttribute(attr);
          });
        };
        MenuItemController.prototype.initClickListeners = function() {
          var self = this;
          var ngModel = this.ngModel;
          var $scope = this.$scope;
          var $attrs = this.$attrs;
          var $element = this.$element;
          var mode = this.mode;
          this.handleClick = angular.bind(this, this.handleClick);
          var icon = this.iconEl;
          var button = angular.element(this.buttonEl);
          var handleClick = this.handleClick;
          $attrs.$observe('disabled', setDisabled);
          setDisabled($attrs.disabled);
          ngModel.$render = function render() {
            self.clearNgAria();
            if (isSelected()) {
              icon.style.display = '';
              button.attr('aria-checked', 'true');
            } else {
              icon.style.display = 'none';
              button.attr('aria-checked', 'false');
            }
          };
          $scope.$$postDigest(ngModel.$render);
          function isSelected() {
            if (mode == 'radio') {
              var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
              return ngModel.$modelValue == val;
            } else {
              return ngModel.$modelValue;
            }
          }
          function setDisabled(disabled) {
            if (disabled) {
              button.off('click', handleClick);
            } else {
              button.on('click', handleClick);
            }
          }
        };
        MenuItemController.prototype.handleClick = function(e) {
          var mode = this.mode;
          var ngModel = this.ngModel;
          var $attrs = this.$attrs;
          var newVal;
          if (mode == 'checkbox') {
            newVal = !ngModel.$modelValue;
          } else if (mode == 'radio') {
            newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;
          }
          ngModel.$setViewValue(newVal);
          ngModel.$render();
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuItem', MenuItemDirective);
        function MenuItemDirective() {
          return {
            require: ['mdMenuItem', '?ngModel'],
            priority: 210,
            compile: function(templateEl, templateAttrs) {
              if (templateAttrs.type == 'checkbox' || templateAttrs.type == 'radio') {
                var text = templateEl[0].textContent;
                var buttonEl = angular.element('<md-button type="button"></md-button>');
                buttonEl.html(text);
                buttonEl.attr('tabindex', '0');
                templateEl.html('');
                templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                templateEl.append(buttonEl);
                templateEl[0].classList.add('md-indent');
                setDefault('role', (templateAttrs.type == 'checkbox') ? 'menuitemcheckbox' : 'menuitemradio', buttonEl);
                angular.forEach(['ng-disabled'], moveAttrToButton);
              } else {
                setDefault('role', 'menuitem', templateEl[0].querySelector('md-button,button,a'));
              }
              return function(scope, el, attrs, ctrls) {
                var ctrl = ctrls[0];
                var ngModel = ctrls[1];
                ctrl.init(ngModel);
              };
              function setDefault(attr, val, el) {
                el = el || templateEl;
                if (el instanceof angular.element) {
                  el = el[0];
                }
                if (!el.hasAttribute(attr)) {
                  el.setAttribute(attr, val);
                }
              }
              function moveAttrToButton(attr) {
                if (templateEl[0].hasAttribute(attr)) {
                  var val = templateEl[0].getAttribute(attr);
                  buttonEl[0].setAttribute(attr, val);
                  templateEl[0].removeAttribute(attr);
                }
              }
            },
            controller: 'MenuItemController'
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').controller('mdMenuCtrl', MenuController);
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
          var menuContainer;
          var self = this;
          var triggerElement;
          this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
          this.init = function init(setMenuContainer, opts) {
            opts = opts || {};
            menuContainer = setMenuContainer;
            triggerElement = $element[0].querySelector('[ng-click],[ng-mouseenter]');
            triggerElement.setAttribute('aria-expanded', 'false');
            this.isInMenuBar = opts.isInMenuBar;
            this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu'));
            menuContainer.on('$mdInterimElementRemove', function() {
              self.isOpen = false;
            });
            var menuContainerId = 'menu_container_' + $mdUtil.nextUid();
            menuContainer.attr('id', menuContainerId);
            angular.element(triggerElement).attr({
              'aria-owns': menuContainerId,
              'aria-haspopup': 'true'
            });
            $scope.$on('$destroy', this.disableHoverListener);
            menuContainer.on('$destroy', function() {
              $mdMenu.destroy();
            });
          };
          var openMenuTimeout,
              menuItems,
              deregisterScopeListeners = [];
          this.enableHoverListener = function() {
            deregisterScopeListeners.push($rootScope.$on('$mdMenuOpen', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = el.controller('mdMenu');
                self.isAlreadyOpening = false;
                self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
              }
            }));
            deregisterScopeListeners.push($rootScope.$on('$mdMenuClose', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = undefined;
              }
            }));
            menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
            menuItems.on('mouseenter', self.handleMenuItemHover);
            menuItems.on('mouseleave', self.handleMenuItemMouseLeave);
          };
          this.disableHoverListener = function() {
            while (deregisterScopeListeners.length) {
              deregisterScopeListeners.shift()();
            }
            menuItems && menuItems.off('mouseenter', self.handleMenuItemHover);
            menuItems && menuItems.off('mouseleave', self.handleMenuMouseLeave);
          };
          this.handleMenuItemHover = function(event) {
            if (self.isAlreadyOpening)
              return;
            var nestedMenu = (event.target.querySelector('md-menu') || $mdUtil.getClosest(event.target, 'MD-MENU'));
            openMenuTimeout = $timeout(function() {
              if (nestedMenu) {
                nestedMenu = angular.element(nestedMenu).controller('mdMenu');
              }
              if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                var closeTo = self.nestLevel + 1;
                self.currentlyOpenMenu.close(true, {closeTo: closeTo});
              } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                self.isAlreadyOpening = true;
                nestedMenu.open();
              }
            }, nestedMenu ? 100 : 250);
            var focusableTarget = event.currentTarget.querySelector('.md-button:not([disabled])');
            focusableTarget && focusableTarget.focus();
          };
          this.handleMenuItemMouseLeave = function() {
            if (openMenuTimeout) {
              $timeout.cancel(openMenuTimeout);
              openMenuTimeout = undefined;
            }
          };
          this.open = function openMenu(ev) {
            ev && ev.stopPropagation();
            ev && ev.preventDefault();
            if (self.isOpen)
              return;
            self.enableHoverListener();
            self.isOpen = true;
            triggerElement = triggerElement || (ev ? ev.target : $element[0]);
            triggerElement.setAttribute('aria-expanded', 'true');
            $scope.$emit('$mdMenuOpen', $element);
            $mdMenu.show({
              scope: $scope,
              mdMenuCtrl: self,
              nestLevel: self.nestLevel,
              element: menuContainer,
              target: triggerElement,
              preserveElement: true,
              parent: 'body'
            }).finally(function() {
              triggerElement.setAttribute('aria-expanded', 'false');
              self.disableHoverListener();
            });
          };
          $scope.$mdOpenMenu = this.open;
          $scope.$watch(function() {
            return self.isOpen;
          }, function(isOpen) {
            if (isOpen) {
              menuContainer.attr('aria-hidden', 'false');
              $element[0].classList.add('md-open');
              angular.forEach(self.nestedMenus, function(el) {
                el.classList.remove('md-open');
              });
            } else {
              menuContainer.attr('aria-hidden', 'true');
              $element[0].classList.remove('md-open');
            }
            $scope.$mdMenuIsOpen = self.isOpen;
          });
          this.focusMenuContainer = function focusMenuContainer() {
            var focusTarget = menuContainer[0].querySelector('[md-menu-focus-target]');
            if (!focusTarget)
              focusTarget = menuContainer[0].querySelector('.md-button');
            focusTarget.focus();
          };
          this.registerContainerProxy = function registerContainerProxy(handler) {
            this.containerProxy = handler;
          };
          this.triggerContainerProxy = function triggerContainerProxy(ev) {
            this.containerProxy && this.containerProxy(ev);
          };
          this.destroy = function() {
            return self.isOpen ? $mdMenu.destroy() : $q.when(false);
          };
          this.close = function closeMenu(skipFocus, closeOpts) {
            if (!self.isOpen)
              return;
            self.isOpen = false;
            var eventDetails = angular.extend({}, closeOpts, {skipFocus: skipFocus});
            $scope.$emit('$mdMenuClose', $element, eventDetails);
            $mdMenu.hide(null, closeOpts);
            if (!skipFocus) {
              var el = self.restoreFocusTo || $element.find('button')[0];
              if (el instanceof angular.element)
                el = el[0];
              if (el)
                el.focus();
            }
          };
          this.positionMode = function positionMode() {
            var attachment = ($attrs.mdPositionMode || 'target').split(' ');
            if (attachment.length == 1) {
              attachment.push(attachment[0]);
            }
            return {
              left: attachment[0],
              top: attachment[1]
            };
          };
          this.offsets = function offsets() {
            var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);
            if (position.length == 2) {
              return {
                left: position[0],
                top: position[1]
              };
            } else if (position.length == 1) {
              return {
                top: position[0],
                left: position[0]
              };
            } else {
              throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');
            }
          };
        }
        MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').directive('mdMenu', MenuDirective);
        function MenuDirective($mdUtil) {
          var INVALID_PREFIX = 'Invalid HTML for md-menu: ';
          return {
            restrict: 'E',
            require: ['mdMenu', '?^mdMenuBar'],
            controller: 'mdMenuCtrl',
            scope: true,
            compile: compile
          };
          function compile(templateElement) {
            templateElement.addClass('md-menu');
            var triggerElement = templateElement.children()[0];
            if (!triggerElement.hasAttribute('ng-click')) {
              triggerElement = triggerElement.querySelector('[ng-click],[ng-mouseenter]') || triggerElement;
            }
            if (triggerElement && (triggerElement.nodeName == 'MD-BUTTON' || triggerElement.nodeName == 'BUTTON') && !triggerElement.hasAttribute('type')) {
              triggerElement.setAttribute('type', 'button');
            }
            if (templateElement.children().length != 2) {
              throw Error(INVALID_PREFIX + 'Expected two children elements.');
            }
            triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');
            var nestedMenus = templateElement[0].querySelectorAll('md-menu');
            var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0;
            if (nestedMenus) {
              angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                if (!menuEl.hasAttribute('md-position-mode')) {
                  menuEl.setAttribute('md-position-mode', 'cascade');
                }
                menuEl.classList.add('md-nested-menu');
                menuEl.setAttribute('md-nest-level', nestingDepth + 1);
              });
            }
            return link;
          }
          function link(scope, element, attrs, ctrls) {
            var mdMenuCtrl = ctrls[0];
            var isInMenuBar = ctrls[1] != undefined;
            var menuContainer = angular.element('<div class="md-open-menu-container md-whiteframe-z2"></div>');
            var menuContents = element.children()[1];
            if (!menuContents.hasAttribute('role')) {
              menuContents.setAttribute('role', 'menu');
            }
            menuContainer.append(menuContents);
            element.on('$destroy', function() {
              menuContainer.remove();
            });
            element.append(menuContainer);
            menuContainer[0].style.display = 'none';
            mdMenuCtrl.init(menuContainer, {isInMenuBar: isInMenuBar});
          }
        }
        MenuDirective.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').provider('$mdMenu', MenuProvider);
        function MenuProvider($$interimElementProvider) {
          var MENU_EDGE_MARGIN = 8;
          menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"];
          return $$interimElementProvider('$mdMenu').setDefaults({
            methods: ['target'],
            options: menuDefaultOptions
          });
          function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true,
              skipCompile: true,
              preserveScope: true,
              skipHide: true,
              themable: true
            };
            function showBackdrop(scope, element, options) {
              if (options.nestLevel)
                return angular.noop;
              if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
              } else {
                options.disableParentScroll = false;
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
                $animate.enter(options.backdrop, $document[0].body);
              }
              return function hideBackdrop() {
                if (options.backdrop)
                  options.backdrop.remove();
                if (options.disableParentScroll)
                  options.restoreScroll();
              };
            }
            function onRemove(scope, element, opts) {
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function detachAndClean() {
                element.removeClass('md-active');
                detachElement(element, opts);
                opts.alreadyOpen = false;
              }
            }
            function onShow(scope, element, opts) {
              sanitizeAndConfigure(opts);
              $mdTheming.inherit(opts.menuContentEl, opts.target);
              opts.cleanupResizing = startRepositioningOnResize();
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showMenu().then(function(response) {
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                return response;
              });
              function showMenu() {
                opts.parent.append(element);
                element[0].style.display = '';
                return $q(function(resolve) {
                  var position = calculateMenuPosition(element, opts);
                  element.removeClass('md-leave');
                  $animateCss(element, {
                    addClass: 'md-active',
                    from: animator.toCss(position),
                    to: animator.toCss({transform: ''})
                  }).start().then(resolve);
                });
              }
              function sanitizeAndConfigure() {
                if (!opts.target) {
                  throw Error('$mdMenu.show() expected a target to animate from in options.target');
                }
                angular.extend(opts, {
                  alreadyOpen: false,
                  isRemoved: false,
                  target: angular.element(opts.target),
                  parent: angular.element(opts.parent),
                  menuContentEl: angular.element(element[0].querySelector('md-menu-content'))
                });
              }
              function startRepositioningOnResize() {
                var repositionMenu = (function(target, options) {
                  return $$rAF.throttle(function() {
                    if (opts.isRemoved)
                      return;
                    var position = calculateMenuPosition(target, options);
                    target.css(animator.toCss(position));
                  });
                })(element, opts);
                $window.addEventListener('resize', repositionMenu);
                $window.addEventListener('orientationchange', repositionMenu);
                return function stopRepositioningOnResize() {
                  $window.removeEventListener('resize', repositionMenu);
                  $window.removeEventListener('orientationchange', repositionMenu);
                };
              }
              function activateInteraction() {
                element.addClass('md-clickable');
                if (opts.backdrop)
                  opts.backdrop.on('click', onBackdropClick);
                opts.menuContentEl.on('keydown', onMenuKeyDown);
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                var focusTarget = opts.menuContentEl[0].querySelector('[md-menu-focus-target]');
                if (!focusTarget) {
                  var firstChild = opts.menuContentEl[0].firstElementChild;
                  focusTarget = firstChild && (firstChild.querySelector('.md-button:not([disabled])') || firstChild.firstElementChild);
                }
                focusTarget && focusTarget.focus();
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  if (opts.backdrop)
                    opts.backdrop.off('click', onBackdropClick);
                  opts.menuContentEl.off('keydown', onMenuKeyDown);
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
                function onMenuKeyDown(ev) {
                  var handled;
                  switch (ev.keyCode) {
                    case $mdConstant.KEY_CODE.ESCAPE:
                      opts.mdMenuCtrl.close(false, {closeAll: true});
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.UP_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.DOWN_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.LEFT_ARROW:
                      if (opts.nestLevel) {
                        opts.mdMenuCtrl.close();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU');
                      if (parentMenu && parentMenu != opts.parent[0]) {
                        ev.target.click();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                  }
                  if (handled) {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                  }
                }
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  scope.$apply(function() {
                    opts.mdMenuCtrl.close(true, {closeAll: true});
                  });
                }
                function captureClickListener(e) {
                  var target = e.target;
                  do {
                    if (target == opts.menuContentEl[0])
                      return;
                    if ((hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) || target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close'])) {
                      var closestMenu = $mdUtil.getClosest(target, 'MD-MENU');
                      if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {
                        close();
                      }
                      break;
                    }
                  } while (target = target.parentNode);
                  function close() {
                    scope.$apply(function() {
                      opts.mdMenuCtrl.close(true, {closeAll: true});
                    });
                  }
                  function hasAnyAttribute(target, attrs) {
                    if (!target)
                      return false;
                    for (var i = 0,
                        attr; attr = attrs[i]; ++i) {
                      var altForms = [attr, 'data-' + attr, 'x-' + attr];
                      for (var j = 0,
                          rawAttr; rawAttr = altForms[j]; ++j) {
                        if (target.hasAttribute(rawAttr)) {
                          return true;
                        }
                      }
                    }
                    return false;
                  }
                }
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  opts.menuContentEl.off('keydown');
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
              }
            }
            function focusMenuItem(e, menuEl, opts, direction) {
              var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');
              var items = $mdUtil.nodesToArray(menuEl[0].children);
              var currentIndex = items.indexOf(currentItem);
              var didFocus;
              for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {
                var focusTarget = items[i].querySelector('.md-button');
                didFocus = attemptFocus(focusTarget);
                if (didFocus) {
                  break;
                }
              }
              return didFocus;
            }
            function attemptFocus(el) {
              if (el && el.getAttribute('tabindex') != -1) {
                el.focus();
                return ($document[0].activeElement == el);
              }
            }
            function detachElement(element, opts) {
              if (!opts.preserveElement) {
                if (toNode(element).parentNode === toNode(opts.parent)) {
                  toNode(opts.parent).removeChild(toNode(element));
                }
              } else {
                toNode(element).style.display = 'none';
              }
            }
            function calculateMenuPosition(el, opts) {
              var containerNode = el[0],
                  openMenuNode = el[0].firstElementChild,
                  openMenuNodeRect = openMenuNode.getBoundingClientRect(),
                  boundryNode = $document[0].body,
                  boundryNodeRect = boundryNode.getBoundingClientRect();
              var menuStyle = $window.getComputedStyle(openMenuNode);
              var originNode = opts.target[0].querySelector('[md-menu-origin]') || opts.target[0],
                  originNodeRect = originNode.getBoundingClientRect();
              var bounds = {
                left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                right: boundryNodeRect.right - MENU_EDGE_MARGIN
              };
              var alignTarget,
                  alignTargetRect = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  },
                  existingOffsets = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  };
              var positionMode = opts.mdMenuCtrl.positionMode();
              if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {
                alignTarget = firstVisibleChild();
                if (alignTarget) {
                  alignTarget = alignTarget.firstElementChild || alignTarget;
                  alignTarget = alignTarget.querySelector('[md-menu-align-target]') || alignTarget;
                  alignTargetRect = alignTarget.getBoundingClientRect();
                  existingOffsets = {
                    top: parseFloat(containerNode.style.top || 0),
                    left: parseFloat(containerNode.style.left || 0)
                  };
                }
              }
              var position = {};
              var transformOrigin = 'top ';
              switch (positionMode.top) {
                case 'target':
                  position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                  break;
                case 'cascade':
                  position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                  break;
                case 'bottom':
                  position.top = originNodeRect.top + originNodeRect.height;
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
              }
              switch (positionMode.left) {
                case 'target':
                  position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                  transformOrigin += 'left';
                  break;
                case 'target-right':
                  position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                  transformOrigin += 'right';
                  break;
                case 'cascade':
                  var willFitRight = (originNodeRect.right + openMenuNodeRect.width) < bounds.right;
                  position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                  transformOrigin += willFitRight ? 'left' : 'right';
                  break;
                case 'left':
                  position.left = originNodeRect.left;
                  transformOrigin += 'left';
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
              }
              var offsets = opts.mdMenuCtrl.offsets();
              position.top += offsets.top;
              position.left += offsets.left;
              clamp(position);
              var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;
              return {
                top: Math.round(position.top),
                left: Math.round(position.left),
                transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined,
                transformOrigin: transformOrigin
              };
              function clamp(pos) {
                pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
              }
              function firstVisibleChild() {
                for (var i = 0; i < openMenuNode.children.length; ++i) {
                  if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {
                    return openMenuNode.children[i];
                  }
                }
              }
            }
          }
          function toNode(el) {
            if (el instanceof angular.element) {
              el = el[0];
            }
            return el;
          }
        }
        MenuProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTab', MdTab);
        function MdTab() {
          return {
            require: '^?mdTabs',
            terminal: true,
            compile: function(element, attr) {
              var label = firstChild(element, 'md-tab-label'),
                  body = firstChild(element, 'md-tab-body');
              if (label.length == 0) {
                label = angular.element('<md-tab-label></md-tab-label>');
                if (attr.label)
                  label.text(attr.label);
                else
                  label.append(element.contents());
                if (body.length == 0) {
                  var contents = element.contents().detach();
                  body = angular.element('<md-tab-body></md-tab-body>');
                  body.append(contents);
                }
              }
              element.append(label);
              if (body.html())
                element.append(body);
              return postLink;
            },
            scope: {
              active: '=?mdActive',
              disabled: '=?ngDisabled',
              select: '&?mdOnSelect',
              deselect: '&?mdOnDeselect'
            }
          };
          function postLink(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var index = ctrl.getTabElementIndex(element),
                body = firstChild(element, 'md-tab-body').remove(),
                label = firstChild(element, 'md-tab-label').remove(),
                data = ctrl.insertTab({
                  scope: scope,
                  parent: scope.$parent,
                  index: index,
                  element: element,
                  template: body.html(),
                  label: label.html()
                }, index);
            scope.select = scope.select || angular.noop;
            scope.deselect = scope.deselect || angular.noop;
            scope.$watch('active', function(active) {
              if (active)
                ctrl.select(data.getIndex());
            });
            scope.$watch('disabled', function() {
              ctrl.refreshIndex();
            });
            scope.$watch(function() {
              return ctrl.getTabElementIndex(element);
            }, function(newIndex) {
              data.index = newIndex;
              ctrl.updateTabOrder();
            });
            scope.$on('$destroy', function() {
              ctrl.removeTab(data);
            });
          }
          function firstChild(element, tagName) {
            var children = element[0].children;
            for (var i = 0,
                len = children.length; i < len; i++) {
              var child = children[i];
              if (child.tagName === tagName.toUpperCase())
                return angular.element(child);
            }
            return angular.element();
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabItem', MdTabItem);
        function MdTabItem() {
          return {
            require: '^?mdTabs',
            link: function link(scope, element, attr, ctrl) {
              if (!ctrl)
                return;
              ctrl.attachRipple(scope, element);
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabLabel', MdTabLabel);
        function MdTabLabel() {
          return {terminal: true};
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabScroll', MdTabScroll);
        function MdTabScroll($parse) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr.mdTabScroll, null, true);
              return function ngEventHandler(scope, element) {
                element.on('mousewheel', function(event) {
                  scope.$apply(function() {
                    fn(scope, {$event: event});
                  });
                });
              };
            }
          };
        }
        MdTabScroll.$inject = ["$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').controller('MdTabsController', MdTabsController);
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
          var ctrl = this,
              locked = false,
              elements = getElements(),
              queue = [],
              destroyed = false,
              loaded = false;
          defineOneWayBinding('stretchTabs', handleStretchTabs);
          defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0);
          defineProperty('offsetLeft', handleOffsetChange, 0);
          defineProperty('hasContent', handleHasContent, false);
          defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth());
          defineProperty('shouldPaginate', handleShouldPaginate, false);
          defineBooleanAttribute('noInkBar', handleInkBar);
          defineBooleanAttribute('dynamicHeight', handleDynamicHeight);
          defineBooleanAttribute('noPagination');
          defineBooleanAttribute('swipeContent');
          defineBooleanAttribute('noDisconnect');
          defineBooleanAttribute('autoselect');
          defineBooleanAttribute('centerTabs', handleCenterTabs, false);
          defineBooleanAttribute('enableDisconnect');
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.tabs = [];
          ctrl.lastSelectedIndex = null;
          ctrl.hasFocus = false;
          ctrl.lastClick = true;
          ctrl.shouldCenterTabs = shouldCenterTabs();
          ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
          ctrl.redirectFocus = redirectFocus;
          ctrl.attachRipple = attachRipple;
          ctrl.insertTab = insertTab;
          ctrl.removeTab = removeTab;
          ctrl.select = select;
          ctrl.scroll = scroll;
          ctrl.nextPage = nextPage;
          ctrl.previousPage = previousPage;
          ctrl.keydown = keydown;
          ctrl.canPageForward = canPageForward;
          ctrl.canPageBack = canPageBack;
          ctrl.refreshIndex = refreshIndex;
          ctrl.incrementIndex = incrementIndex;
          ctrl.getTabElementIndex = getTabElementIndex;
          ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
          ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
          init();
          function init() {
            ctrl.selectedIndex = ctrl.selectedIndex || 0;
            compileTemplate();
            configureWatchers();
            bindEvents();
            $mdTheming($element);
            $mdUtil.nextTick(function() {
              updateHeightFromContent();
              adjustOffset();
              updateInkBarStyles();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
              loaded = true;
              updatePagination();
            });
          }
          function compileTemplate() {
            var template = $attrs.$mdTabsTemplate,
                element = angular.element(elements.data);
            element.html(template);
            $compile(element.contents())(ctrl.parent);
            delete $attrs.$mdTabsTemplate;
          }
          function bindEvents() {
            angular.element($window).on('resize', handleWindowResize);
            $scope.$on('$destroy', cleanup);
          }
          function configureWatchers() {
            $scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);
          }
          function defineOneWayBinding(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            $attrs.$observe(attr, function(newValue) {
              ctrl[key] = newValue;
            });
          }
          function defineBooleanAttribute(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            if ($attrs.hasOwnProperty(attr))
              updateValue($attrs[attr]);
            $attrs.$observe(attr, updateValue);
            function updateValue(newValue) {
              ctrl[key] = newValue !== 'false';
            }
          }
          function cleanup() {
            destroyed = true;
            angular.element($window).off('resize', handleWindowResize);
          }
          function handleStretchTabs(stretchTabs) {
            angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs());
            updateInkBarStyles();
          }
          function handleCenterTabs(newValue) {
            ctrl.shouldCenterTabs = shouldCenterTabs();
          }
          function handleMaxTabWidth(newWidth, oldWidth) {
            if (newWidth !== oldWidth) {
              angular.forEach(elements.tabs, function(tab) {
                tab.style.maxWidth = newWidth + 'px';
              });
              $mdUtil.nextTick(ctrl.updateInkBarStyles);
            }
          }
          function handleShouldPaginate(newValue, oldValue) {
            if (newValue !== oldValue) {
              ctrl.maxTabWidth = getMaxTabWidth();
              ctrl.shouldCenterTabs = shouldCenterTabs();
              $mdUtil.nextTick(function() {
                ctrl.maxTabWidth = getMaxTabWidth();
                adjustOffset(ctrl.selectedIndex);
              });
            }
          }
          function handleHasContent(hasContent) {
            $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');
          }
          function handleOffsetChange(left) {
            var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';
            angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');
            $scope.$broadcast('$mdTabsPaginationChanged');
          }
          function handleFocusIndexChange(newIndex, oldIndex) {
            if (newIndex === oldIndex)
              return;
            if (!elements.tabs[newIndex])
              return;
            adjustOffset();
            redirectFocus();
          }
          function handleSelectedIndexChange(newValue, oldValue) {
            if (newValue === oldValue)
              return;
            ctrl.selectedIndex = getNearestSafeIndex(newValue);
            ctrl.lastSelectedIndex = oldValue;
            ctrl.updateInkBarStyles();
            updateHeightFromContent();
            adjustOffset(newValue);
            $scope.$broadcast('$mdTabsChanged');
            ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
            ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
          }
          function getTabElementIndex(tabEl) {
            var tabs = $element[0].getElementsByTagName('md-tab');
            return Array.prototype.indexOf.call(tabs, tabEl[0]);
          }
          function handleResizeWhenVisible() {
            if (handleResizeWhenVisible.watcher)
              return;
            handleResizeWhenVisible.watcher = $scope.$watch(function() {
              $mdUtil.nextTick(function() {
                if (!handleResizeWhenVisible.watcher)
                  return;
                if ($element.prop('offsetParent')) {
                  handleResizeWhenVisible.watcher();
                  handleResizeWhenVisible.watcher = null;
                  handleWindowResize();
                }
              }, false);
            });
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                incrementIndex(-1, true);
                break;
              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                incrementIndex(1, true);
                break;
              case $mdConstant.KEY_CODE.SPACE:
              case $mdConstant.KEY_CODE.ENTER:
                event.preventDefault();
                if (!locked)
                  ctrl.selectedIndex = ctrl.focusIndex;
                break;
            }
            ctrl.lastClick = false;
          }
          function select(index) {
            if (!locked)
              ctrl.focusIndex = ctrl.selectedIndex = index;
            ctrl.lastClick = true;
            $mdUtil.nextTick(function() {
              ctrl.tabs[index].element.triggerHandler('click');
            }, false);
          }
          function scroll(event) {
            if (!ctrl.shouldPaginate)
              return;
            event.preventDefault();
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
          }
          function nextPage() {
            var viewportWidth = elements.canvas.clientWidth,
                totalWidth = viewportWidth + ctrl.offsetLeft,
                i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth > totalWidth)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft);
          }
          function previousPage() {
            var i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
          }
          function handleWindowResize() {
            ctrl.lastSelectedIndex = ctrl.selectedIndex;
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            $mdUtil.nextTick(function() {
              ctrl.updateInkBarStyles();
              updatePagination();
            });
          }
          function handleInkBar(hide) {
            angular.element(elements.inkBar).toggleClass('ng-hide', hide);
          }
          function handleDynamicHeight(value) {
            $element.toggleClass('md-dynamic-height', value);
          }
          function removeTab(tabData) {
            if (destroyed)
              return;
            var selectedIndex = ctrl.selectedIndex,
                tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
            refreshIndex();
            if (ctrl.selectedIndex === selectedIndex) {
              tab.scope.deselect();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
            }
            $mdUtil.nextTick(function() {
              updatePagination();
              ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            });
          }
          function insertTab(tabData, index) {
            var hasLoaded = loaded;
            var proto = {
              getIndex: function() {
                return ctrl.tabs.indexOf(tab);
              },
              isActive: function() {
                return this.getIndex() === ctrl.selectedIndex;
              },
              isLeft: function() {
                return this.getIndex() < ctrl.selectedIndex;
              },
              isRight: function() {
                return this.getIndex() > ctrl.selectedIndex;
              },
              shouldRender: function() {
                return !ctrl.noDisconnect || this.isActive();
              },
              hasFocus: function() {
                return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
              },
              id: $mdUtil.nextUid()
            },
                tab = angular.extend(proto, tabData);
            if (angular.isDefined(index)) {
              ctrl.tabs.splice(index, 0, tab);
            } else {
              ctrl.tabs.push(tab);
            }
            processQueue();
            updateHasContent();
            $mdUtil.nextTick(function() {
              updatePagination();
              if (hasLoaded && ctrl.autoselect)
                $mdUtil.nextTick(function() {
                  $mdUtil.nextTick(function() {
                    select(ctrl.tabs.indexOf(tab));
                  });
                });
            });
            return tab;
          }
          function getElements() {
            var elements = {};
            elements.wrapper = $element[0].getElementsByTagName('md-tabs-wrapper')[0];
            elements.data = $element[0].getElementsByTagName('md-tab-data')[0];
            elements.canvas = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];
            elements.paging = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];
            elements.tabs = elements.paging.getElementsByTagName('md-tab-item');
            elements.dummies = elements.canvas.getElementsByTagName('md-dummy-tab');
            elements.inkBar = elements.paging.getElementsByTagName('md-ink-bar')[0];
            elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];
            elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');
            return elements;
          }
          function canPageBack() {
            return ctrl.offsetLeft > 0;
          }
          function canPageForward() {
            var lastTab = elements.tabs[elements.tabs.length - 1];
            return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
          }
          function shouldStretchTabs() {
            switch (ctrl.stretchTabs) {
              case 'always':
                return true;
              case 'never':
                return false;
              default:
                return !ctrl.shouldPaginate && $window.matchMedia('(max-width: 600px)').matches;
            }
          }
          function shouldCenterTabs() {
            return ctrl.centerTabs && !ctrl.shouldPaginate;
          }
          function shouldPaginate() {
            if (ctrl.noPagination || !loaded)
              return false;
            var canvasWidth = $element.prop('clientWidth');
            angular.forEach(getElements().dummies, function(tab) {
              canvasWidth -= tab.offsetWidth;
            });
            return canvasWidth < 0;
          }
          function getNearestSafeIndex(newIndex) {
            if (newIndex === -1)
              return -1;
            var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),
                i,
                tab;
            for (i = 0; i <= maxOffset; i++) {
              tab = ctrl.tabs[newIndex + i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
              tab = ctrl.tabs[newIndex - i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
            }
            return newIndex;
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler && handler(newValue, oldValue);
              }
            });
          }
          function updatePagination() {
            if (!shouldStretchTabs())
              updatePagingWidth();
            ctrl.maxTabWidth = getMaxTabWidth();
            ctrl.shouldPaginate = shouldPaginate();
          }
          function updatePagingWidth() {
            var width = 1;
            angular.forEach(getElements().dummies, function(element) {
              width += Math.max(element.offsetWidth, element.getBoundingClientRect().width);
            });
            angular.element(elements.paging).css('width', Math.ceil(width) + 'px');
          }
          function getMaxTabWidth() {
            return $element.prop('clientWidth');
          }
          function updateTabOrder() {
            var selectedItem = ctrl.tabs[ctrl.selectedIndex],
                focusItem = ctrl.tabs[ctrl.focusIndex];
            ctrl.tabs = ctrl.tabs.sort(function(a, b) {
              return a.index - b.index;
            });
            ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
            ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
          }
          function incrementIndex(inc, focus) {
            var newIndex,
                key = focus ? 'focusIndex' : 'selectedIndex',
                index = ctrl[key];
            for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) {}
            if (ctrl.tabs[newIndex]) {
              ctrl[key] = newIndex;
            }
          }
          function redirectFocus() {
            getElements().dummies[ctrl.focusIndex].focus();
          }
          function adjustOffset(index) {
            if (index == null)
              index = ctrl.focusIndex;
            if (!elements.tabs[index])
              return;
            if (ctrl.shouldCenterTabs)
              return;
            var tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = tab.offsetWidth + left;
            ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 32 * 2));
            ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
          }
          function processQueue() {
            queue.forEach(function(func) {
              $mdUtil.nextTick(func);
            });
            queue = [];
          }
          function updateHasContent() {
            var hasContent = false;
            angular.forEach(ctrl.tabs, function(tab) {
              if (tab.template)
                hasContent = true;
            });
            ctrl.hasContent = hasContent;
          }
          function refreshIndex() {
            ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
            ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
          }
          function updateHeightFromContent() {
            if (!ctrl.dynamicHeight)
              return $element.css('height', '');
            if (!ctrl.tabs.length)
              return queue.push(updateHeightFromContent);
            var tabContent = elements.contents[ctrl.selectedIndex],
                contentHeight = tabContent ? tabContent.offsetHeight : 0,
                tabsHeight = elements.wrapper.offsetHeight,
                newHeight = contentHeight + tabsHeight,
                currentHeight = $element.prop('clientHeight');
            if (currentHeight === newHeight)
              return;
            if ($element.attr('md-align-tabs') === 'bottom') {
              currentHeight -= tabsHeight;
              newHeight -= tabsHeight;
              if ($element.attr('md-border-bottom') !== undefined)
                ++currentHeight;
            }
            locked = true;
            var fromHeight = {height: currentHeight + 'px'},
                toHeight = {height: newHeight + 'px'};
            $element.css(fromHeight);
            $animateCss($element, {
              from: fromHeight,
              to: toHeight,
              easing: 'cubic-bezier(0.35, 0, 0.25, 1)',
              duration: 0.5
            }).start().done(function() {
              $element.css({
                transition: 'none',
                height: ''
              });
              $mdUtil.nextTick(function() {
                $element.css('transition', '');
              });
              locked = false;
            });
          }
          function updateInkBarStyles() {
            if (!elements.tabs[ctrl.selectedIndex]) {
              angular.element(elements.inkBar).css({
                left: 'auto',
                right: 'auto'
              });
              return;
            }
            if (!ctrl.tabs.length)
              return queue.push(ctrl.updateInkBarStyles);
            if (!$element.prop('offsetParent'))
              return handleResizeWhenVisible();
            var index = ctrl.selectedIndex,
                totalWidth = elements.paging.offsetWidth,
                tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = totalWidth - left - tab.offsetWidth,
                tabWidth;
            if (ctrl.shouldCenterTabs) {
              tabWidth = Array.prototype.slice.call(elements.tabs).reduce(function(value, element) {
                return value + element.offsetWidth;
              }, 0);
              if (totalWidth > tabWidth)
                $mdUtil.nextTick(updateInkBarStyles, false);
            }
            updateInkBarClassName();
            angular.element(elements.inkBar).css({
              left: left + 'px',
              right: right + 'px'
            });
          }
          function updateInkBarClassName() {
            var newIndex = ctrl.selectedIndex,
                oldIndex = ctrl.lastSelectedIndex,
                ink = angular.element(elements.inkBar);
            if (!angular.isNumber(oldIndex))
              return;
            ink.toggleClass('md-left', newIndex < oldIndex).toggleClass('md-right', newIndex > oldIndex);
          }
          function fixOffset(value) {
            if (!elements.tabs.length || !ctrl.shouldPaginate)
              return 0;
            var lastTab = elements.tabs[elements.tabs.length - 1],
                totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            value = Math.max(0, value);
            value = Math.min(totalWidth - elements.canvas.clientWidth, value);
            return value;
          }
          function attachRipple(scope, element) {
            var options = {colorElement: angular.element(elements.inkBar)};
            $mdTabInkRipple.attach(scope, element, options);
          }
        }
        MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabs', MdTabs);
        function MdTabs() {
          return {
            scope: {selectedIndex: '=?mdSelected'},
            template: function(element, attr) {
              attr["$mdTabsTemplate"] = element.html();
              return '' + '<md-tabs-wrapper> ' + '<md-tab-data></md-tab-data> ' + '<md-prev-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Previous Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.previousPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-prev-button> ' + '<md-next-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Next Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.nextPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-next-button> ' + '<md-tabs-canvas ' + 'tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ' + 'aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ' + 'ng-focus="$mdTabsCtrl.redirectFocus()" ' + 'ng-class="{ ' + '\'md-paginated\': $mdTabsCtrl.shouldPaginate, ' + '\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs ' + '}" ' + 'ng-keydown="$mdTabsCtrl.keydown($event)" ' + 'role="tablist"> ' + '<md-pagination-wrapper ' + 'ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' + 'md-tab-scroll="$mdTabsCtrl.scroll($event)"> ' + '<md-tab-item ' + 'tabindex="-1" ' + 'class="md-tab" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' + 'ng-class="{ ' + '\'md-active\':    tab.isActive(), ' + '\'md-focused\':   tab.hasFocus(), ' + '\'md-disabled\':  tab.scope.disabled ' + '}" ' + 'ng-disabled="tab.scope.disabled" ' + 'md-swipe-left="$mdTabsCtrl.nextPage()" ' + 'md-swipe-right="$mdTabsCtrl.previousPage()" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-tab-item> ' + '<md-ink-bar></md-ink-bar> ' + '</md-pagination-wrapper> ' + '<div class="md-visually-hidden md-dummy-wrapper"> ' + '<md-dummy-tab ' + 'class="md-tab" ' + 'tabindex="-1" ' + 'id="tab-item-{{::tab.id}}" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-focus="$mdTabsCtrl.hasFocus = true" ' + 'ng-blur="$mdTabsCtrl.hasFocus = false" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-dummy-tab> ' + '</div> ' + '</md-tabs-canvas> ' + '</md-tabs-wrapper> ' + '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> ' + '<md-tab-content ' + 'id="tab-content-{{::tab.id}}" ' + 'role="tabpanel" ' + 'aria-labelledby="tab-item-{{::tab.id}}" ' + 'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' + 'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' + 'ng-if="$mdTabsCtrl.hasContent" ' + 'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' + 'ng-class="{ ' + '\'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, ' + '\'md-active\':        tab.isActive(), ' + '\'md-left\':          tab.isLeft(), ' + '\'md-right\':         tab.isRight(), ' + '\'md-no-scroll\':     $mdTabsCtrl.dynamicHeight ' + '}"> ' + '<div ' + 'md-tabs-template="::tab.template" ' + 'md-connected-if="tab.isActive()" ' + 'md-scope="::tab.parent" ' + 'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' + '</md-tab-content> ' + '</md-tabs-content-wrapper>';
            },
            controller: 'MdTabsController',
            controllerAs: '$mdTabsCtrl',
            bindToController: true
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabsTemplate', MdTabsTemplate);
        function MdTabsTemplate($compile, $mdUtil) {
          return {
            restrict: 'A',
            link: link,
            scope: {
              template: '=mdTabsTemplate',
              connected: '=?mdConnectedIf',
              compileScope: '=mdScope'
            },
            require: '^?mdTabs'
          };
          function link(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
            element.html(scope.template);
            $compile(element.contents())(compileScope);
            element.on('DOMSubtreeModified', function() {
              ctrl.updatePagination();
              ctrl.updateInkBarStyles();
            });
            return $mdUtil.nextTick(handleScope);
            function handleScope() {
              scope.$watch('connected', function(value) {
                value === false ? disconnect() : reconnect();
              });
              scope.$on('$destroy', reconnect);
            }
            function disconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.disconnectScope(compileScope);
            }
            function reconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.reconnectScope(compileScope);
            }
          }
        }
        MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-700}}'; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-700}}'; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}' !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: '{{foreground-1}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-hue-1}}';  color: '{{foreground-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: '{{background-color}}'; }.md-THEME_NAME-theme .md-datepicker-input {  color: '{{background-contrast}}';  background: '{{background-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-300}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-color}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [ng-messages] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme data-ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme x-ng-message :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message-exp] :not(.md-char-counter) {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{foreground-2}}'; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-color}}';  color: '{{foreground-1}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{primary-contrast}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: '{{foreground-2}}'; }");
      })();
    })(window, window.angular);
    ;
    window.ngMaterial = {version: {full: "1.0.6"}};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("e", ["b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('b');
  return module.exports;
});

$__System.registerDynamic("f", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          return {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                  });
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = element.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            while (parentElement && parentElement.length) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              var parentNode = parentElement[0];
              if (parentNode.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentNode) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentNode);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = parentHost;
                  continue;
                }
              }
              parentElement = parentElement.parent();
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("c", ["f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('f');
  return module.exports;
});

$__System.registerDynamic("10", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var ngAriaModule = angular.module('ngAria', ['ng']).provider('$aria', $AriaProvider);
      var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
      var isNodeOneOf = function(elem, nodeTypeArray) {
        if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
          return true;
        }
      };
      function $AriaProvider() {
        var config = {
          ariaHidden: true,
          ariaChecked: true,
          ariaDisabled: true,
          ariaRequired: true,
          ariaInvalid: true,
          ariaValue: true,
          tabindex: true,
          bindKeypress: true,
          bindRoleForClick: true
        };
        this.config = function(newConfig) {
          config = angular.extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
          return function(scope, elem, attr) {
            var ariaCamelName = attr.$normalize(ariaAttr);
            if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
              scope.$watch(attr[attrName], function(boolVal) {
                boolVal = negate ? !boolVal : !!boolVal;
                elem.attr(ariaAttr, boolVal);
              });
            }
          };
        }
        this.$get = function() {
          return {
            config: function(key) {
              return config[key];
            },
            $$watchExpr: watchExpr
          };
        };
      }
      ngAriaModule.directive('ngShow', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
      }]).directive('ngHide', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
      }]).directive('ngValue', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
      }]).directive('ngChecked', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
      }]).directive('ngRequired', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
      }]).directive('ngModel', ['$aria', function($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
          return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));
        }
        function shouldAttachRole(role, elem) {
          return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');
        }
        function getShape(attr, elem) {
          var type = attr.type,
              role = attr.role;
          return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' : ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' : (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : '';
        }
        return {
          restrict: 'A',
          require: 'ngModel',
          priority: 200,
          compile: function(elem, attr) {
            var shape = getShape(attr, elem);
            return {
              pre: function(scope, elem, attr, ngModel) {
                if (shape === 'checkbox') {
                  ngModel.$isEmpty = function(value) {
                    return value === false;
                  };
                }
              },
              post: function(scope, elem, attr, ngModel) {
                var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);
                function ngAriaWatchModelValue() {
                  return ngModel.$modelValue;
                }
                function getRadioReaction(newVal) {
                  var boolVal = (attr.value == ngModel.$viewValue);
                  elem.attr('aria-checked', boolVal);
                }
                function getCheckboxReaction() {
                  elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
                }
                switch (shape) {
                  case 'radio':
                  case 'checkbox':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', shape);
                    }
                    if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                      scope.$watch(ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction : getCheckboxReaction);
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                  case 'range':
                    if (shouldAttachRole(shape, elem)) {
                      elem.attr('role', 'slider');
                    }
                    if ($aria.config('ariaValue')) {
                      var needsAriaValuemin = !elem.attr('aria-valuemin') && (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                      var needsAriaValuemax = !elem.attr('aria-valuemax') && (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                      var needsAriaValuenow = !elem.attr('aria-valuenow');
                      if (needsAriaValuemin) {
                        attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemin', newVal);
                        });
                      }
                      if (needsAriaValuemax) {
                        attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                          elem.attr('aria-valuemax', newVal);
                        });
                      }
                      if (needsAriaValuenow) {
                        scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                          elem.attr('aria-valuenow', newVal);
                        });
                      }
                    }
                    if (needsTabIndex) {
                      elem.attr('tabindex', 0);
                    }
                    break;
                }
                if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
                  attr.$observe('required', function() {
                    elem.attr('aria-required', !!attr['required']);
                  });
                }
                if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
                  scope.$watch(function ngAriaInvalidWatch() {
                    return ngModel.$invalid;
                  }, function ngAriaInvalidReaction(newVal) {
                    elem.attr('aria-invalid', !!newVal);
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDisabled', ['$aria', function($aria) {
        return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
      }]).directive('ngMessages', function() {
        return {
          restrict: 'A',
          require: '?ngMessages',
          link: function(scope, elem, attr, ngMessages) {
            if (!elem.attr('aria-live')) {
              elem.attr('aria-live', 'assertive');
            }
          }
        };
      }).directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
        return {
          restrict: 'A',
          compile: function(elem, attr) {
            var fn = $parse(attr.ngClick, null, true);
            return function(scope, elem, attr) {
              if (!isNodeOneOf(elem, nodeBlackList)) {
                if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
                  elem.attr('role', 'button');
                }
                if ($aria.config('tabindex') && !elem.attr('tabindex')) {
                  elem.attr('tabindex', 0);
                }
                if ($aria.config('bindKeypress') && !attr.ngKeypress) {
                  elem.on('keypress', function(event) {
                    var keyCode = event.which || event.keyCode;
                    if (keyCode === 32 || keyCode === 13) {
                      scope.$apply(callback);
                    }
                    function callback() {
                      fn(scope, {$event: event});
                    }
                  });
                }
              }
            };
          }
        };
      }]).directive('ngDblclick', ['$aria', function($aria) {
        return function(scope, elem, attr) {
          if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
            elem.attr('tabindex', 0);
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("d", ["10"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('10');
  return module.exports;
});

$__System.registerDynamic("11", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    (function(window, angular, undefined) {
      "use strict";
      (function() {
        "use strict";
        angular.module('ngMaterial', ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.bottomSheet", "material.components.chips", "material.components.dialog", "material.components.divider", "material.components.datepicker", "material.components.content", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.fabTrigger", "material.components.icon", "material.components.input", "material.components.menuBar", "material.components.list", "material.components.menu", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.toast", "material.components.tabs", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe"]);
      })();
      (function() {
        "use strict";
        angular.module('material.core', ['ngAnimate', 'material.core.animate', 'material.core.layout', 'material.core.gestures', 'material.core.theming']).config(MdCoreConfigure).run(DetectNgTouch);
        function DetectNgTouch($log, $injector) {
          if ($injector.has('$swipe')) {
            var msg = "" + "You are using the ngTouch module. \n" + "Angular Material already has mobile click, tap, and swipe support... \n" + "ngTouch is not supported with Angular Material!";
            $log.warn(msg);
          }
        }
        DetectNgTouch.$inject = ["$log", "$injector"];
        function MdCoreConfigure($provide, $mdThemingProvider) {
          $provide.decorator('$$rAF', ["$delegate", rAFDecorator]);
          $mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('pink').warnPalette('deep-orange').backgroundPalette('grey');
        }
        MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
        function rAFDecorator($delegate) {
          $delegate.throttle = function(cb) {
            var queuedArgs,
                alreadyQueued,
                queueCb,
                context;
            return function debounced() {
              queuedArgs = arguments;
              context = this;
              queueCb = cb;
              if (!alreadyQueued) {
                alreadyQueued = true;
                $delegate(function() {
                  queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                  alreadyQueued = false;
                });
              }
            };
          };
          return $delegate;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').directive('mdAutofocus', MdAutofocusDirective).directive('mdAutoFocus', MdAutofocusDirective).directive('mdSidenavFocus', MdAutofocusDirective);
        function MdAutofocusDirective() {
          return {
            restrict: 'A',
            link: postLink
          };
        }
        function postLink(scope, element, attrs) {
          var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;
          scope.$watch(attr, function(canAutofocus) {
            element.toggleClass('_md-autofocus', canAutofocus);
          });
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdConstant', MdConstantFactory);
        function MdConstantFactory($sniffer) {
          var webkit = /webkit/i.test($sniffer.vendorPrefix);
          function vendorProperty(name) {
            return webkit ? ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;
          }
          return {
            KEY_CODE: {
              COMMA: 188,
              SEMICOLON: 186,
              ENTER: 13,
              ESCAPE: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT_ARROW: 37,
              UP_ARROW: 38,
              RIGHT_ARROW: 39,
              DOWN_ARROW: 40,
              TAB: 9,
              BACKSPACE: 8,
              DELETE: 46
            },
            CSS: {
              TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),
              ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),
              TRANSFORM: vendorProperty('transform'),
              TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
              TRANSITION: vendorProperty('transition'),
              TRANSITION_DURATION: vendorProperty('transitionDuration'),
              ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
              ANIMATION_DURATION: vendorProperty('animationDuration'),
              ANIMATION_NAME: vendorProperty('animationName'),
              ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
              ANIMATION_DIRECTION: vendorProperty('animationDirection')
            },
            MEDIA: {
              'xs': '(max-width: 599px)',
              'gt-xs': '(min-width: 600px)',
              'sm': '(min-width: 600px) and (max-width: 959px)',
              'gt-sm': '(min-width: 960px)',
              'md': '(min-width: 960px) and (max-width: 1279px)',
              'gt-md': '(min-width: 1280px)',
              'lg': '(min-width: 1280px) and (max-width: 1919px)',
              'gt-lg': '(min-width: 1920px)',
              'xl': '(min-width: 1920px)',
              'print': 'print'
            },
            MEDIA_PRIORITY: ['xl', 'gt-lg', 'lg', 'gt-md', 'md', 'gt-sm', 'sm', 'gt-xs', 'xs', 'print']
          };
        }
        MdConstantFactory.$inject = ["$sniffer"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').config(["$provide", function($provide) {
          $provide.decorator('$mdUtil', ['$delegate', function($delegate) {
            $delegate.iterator = MdIterator;
            return $delegate;
          }]);
        }]);
        function MdIterator(items, reloop) {
          var trueFn = function() {
            return true;
          };
          if (items && !angular.isArray(items)) {
            items = Array.prototype.slice.call(items);
          }
          reloop = !!reloop;
          var _items = items || [];
          return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
          };
          function getItems() {
            return [].concat(_items);
          }
          function count() {
            return _items.length;
          }
          function inRange(index) {
            return _items.length && (index > -1) && (index < _items.length);
          }
          function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
          }
          function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
          }
          function itemAt(index) {
            return inRange(index) ? _items[index] : null;
          }
          function findBy(key, val) {
            return _items.filter(function(item) {
              return item[key] === val;
            });
          }
          function add(item, index) {
            if (!item)
              return -1;
            if (!angular.isNumber(index)) {
              index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
          }
          function remove(item) {
            if (contains(item)) {
              _items.splice(indexOf(item), 1);
            }
          }
          function indexOf(item) {
            return _items.indexOf(item);
          }
          function contains(item) {
            return item && (indexOf(item) > -1);
          }
          function first() {
            return _items.length ? _items[0] : null;
          }
          function last() {
            return _items.length ? _items[_items.length - 1] : null;
          }
          function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            while (true) {
              if (!inRange(curIndex))
                return null;
              var nextIndex = curIndex + (backwards ? -1 : 1);
              var foundItem = null;
              if (inRange(nextIndex)) {
                foundItem = _items[nextIndex];
              } else if (reloop) {
                foundItem = backwards ? last() : first();
                nextIndex = indexOf(foundItem);
              }
              if ((foundItem === null) || (nextIndex === limit))
                return null;
              if (validate(foundItem))
                return foundItem;
              if (angular.isUndefined(limit))
                limit = nextIndex;
              curIndex = nextIndex;
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdMedia', mdMediaFactory);
        function mdMediaFactory($mdConstant, $rootScope, $window) {
          var queries = {};
          var mqls = {};
          var results = {};
          var normalizeCache = {};
          $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
          $mdMedia.getQuery = getQuery;
          $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
          return $mdMedia;
          function $mdMedia(query) {
            var validated = queries[query];
            if (angular.isUndefined(validated)) {
              validated = queries[query] = validate(query);
            }
            var result = results[validated];
            if (angular.isUndefined(result)) {
              result = add(validated);
            }
            return result;
          }
          function validate(query) {
            return $mdConstant.MEDIA[query] || ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);
          }
          function add(query) {
            var result = mqls[query];
            if (!result) {
              result = mqls[query] = $window.matchMedia(query);
            }
            result.addListener(onQueryChange);
            return (results[result.media] = !!result.matches);
          }
          function onQueryChange(query) {
            $rootScope.$evalAsync(function() {
              results[query.media] = !!query.matches;
            });
          }
          function getQuery(name) {
            return mqls[name];
          }
          function getResponsiveAttribute(attrs, attrName) {
            for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
              var mediaName = $mdConstant.MEDIA_PRIORITY[i];
              if (!mqls[queries[mediaName]].matches) {
                continue;
              }
              var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
              if (attrs[normalizedName]) {
                return attrs[normalizedName];
              }
            }
            return attrs[getNormalizedName(attrs, attrName)];
          }
          function watchResponsiveAttributes(attrNames, attrs, watchFn) {
            var unwatchFns = [];
            attrNames.forEach(function(attrName) {
              var normalizedName = getNormalizedName(attrs, attrName);
              if (angular.isDefined(attrs[normalizedName])) {
                unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
              }
              for (var mediaName in $mdConstant.MEDIA) {
                normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
                if (angular.isDefined(attrs[normalizedName])) {
                  unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                }
              }
            });
            return function unwatch() {
              unwatchFns.forEach(function(fn) {
                fn();
              });
            };
          }
          function getNormalizedName(attrs, attrName) {
            return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
          }
        }
        mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];
      })();
      (function() {
        "use strict";
        var nextUniqueId = 0;
        angular.module('material.core').factory('$mdUtil', UtilFactory);
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));
          var hasComputedStyle = function(target, key, expectedVal) {
            var hasValue = false;
            if (target && target.length) {
              var computedStyles = $window.getComputedStyle(target[0]);
              hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
            }
            return hasValue;
          };
          var $mdUtil = {
            dom: {},
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
              return new Date().getTime();
            },
            clientRect: function(element, offsetParent, isOffsetRect) {
              var node = getNode(element);
              offsetParent = getNode(offsetParent || node.offsetParent || document.body);
              var nodeRect = node.getBoundingClientRect();
              var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              };
              return {
                left: nodeRect.left - offsetRect.left,
                top: nodeRect.top - offsetRect.top,
                width: nodeRect.width,
                height: nodeRect.height
              };
            },
            offsetRect: function(element, offsetParent) {
              return $mdUtil.clientRect(element, offsetParent, true);
            },
            nodesToArray: function(nodes) {
              nodes = nodes || [];
              var results = [];
              for (var i = 0; i < nodes.length; ++i) {
                results.push(nodes.item(i));
              }
              return results;
            },
            scrollTop: function(element) {
              element = angular.element(element || $document[0].body);
              var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
              var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
              return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
            },
            findFocusTarget: function(containerEl, attributeVal) {
              var AUTO_FOCUS = '[md-autofocus]';
              var elToFocus;
              elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
              if (!elToFocus && attributeVal != AUTO_FOCUS) {
                elToFocus = scanForFocusable(containerEl, '[md-auto-focus]');
                if (!elToFocus) {
                  elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
                }
              }
              return elToFocus;
              function scanForFocusable(target, selector) {
                var elFound,
                    items = target[0].querySelectorAll(selector);
                if (items && items.length) {
                  items.length && angular.forEach(items, function(it) {
                    it = angular.element(it);
                    var isFocusable = it.hasClass('_md-autofocus');
                    if (isFocusable)
                      elFound = it;
                  });
                }
                return elFound;
              }
            },
            disableScrollAround: function(element, parent) {
              $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
              ++$mdUtil.disableScrollAround._count;
              if ($mdUtil.disableScrollAround._enableScrolling)
                return $mdUtil.disableScrollAround._enableScrolling;
              element = angular.element(element);
              var body = $document[0].body,
                  restoreBody = disableBodyScroll(),
                  restoreElement = disableElementScroll(parent);
              return $mdUtil.disableScrollAround._enableScrolling = function() {
                if (!--$mdUtil.disableScrollAround._count) {
                  restoreBody();
                  restoreElement();
                  delete $mdUtil.disableScrollAround._enableScrolling;
                }
              };
              function disableElementScroll(element) {
                element = angular.element(element || body)[0];
                var zIndex = 50;
                var scrollMask = angular.element('<div class="md-scroll-mask">' + '  <div class="md-scroll-mask-bar"></div>' + '</div>').css('z-index', zIndex);
                element.appendChild(scrollMask[0]);
                scrollMask.on('wheel', preventDefault);
                scrollMask.on('touchmove', preventDefault);
                $document.on('keydown', disableKeyNav);
                return function restoreScroll() {
                  scrollMask.off('wheel');
                  scrollMask.off('touchmove');
                  scrollMask[0].parentNode.removeChild(scrollMask[0]);
                  $document.off('keydown', disableKeyNav);
                  delete $mdUtil.disableScrollAround._enableScrolling;
                };
                function disableKeyNav(e) {}
                function preventDefault(e) {
                  e.preventDefault();
                }
              }
              function disableBodyScroll() {
                var htmlNode = body.parentNode;
                var restoreHtmlStyle = htmlNode.style.cssText || '';
                var restoreBodyStyle = body.style.cssText || '';
                var scrollOffset = $mdUtil.scrollTop(body);
                var clientWidth = body.clientWidth;
                if (body.scrollHeight > body.clientHeight + 1) {
                  applyStyles(body, {
                    position: 'fixed',
                    width: '100%',
                    top: -scrollOffset + 'px'
                  });
                  applyStyles(htmlNode, {overflowY: 'scroll'});
                }
                if (body.clientWidth < clientWidth)
                  applyStyles(body, {overflow: 'hidden'});
                return function restoreScroll() {
                  body.style.cssText = restoreBodyStyle;
                  htmlNode.style.cssText = restoreHtmlStyle;
                  body.scrollTop = scrollOffset;
                  htmlNode.scrollTop = scrollOffset;
                };
              }
              function applyStyles(el, styles) {
                for (var key in styles) {
                  el.style[key] = styles[key];
                }
              }
            },
            enableScrolling: function() {
              var method = this.disableScrollAround._enableScrolling;
              method && method();
            },
            floatingScrollbars: function() {
              if (this.floatingScrollbars.cached === undefined) {
                var tempNode = angular.element('<div><div></div></div>').css({
                  width: '100%',
                  'z-index': -1,
                  position: 'absolute',
                  height: '35px',
                  'overflow-y': 'scroll'
                });
                tempNode.children().css('height', '60px');
                $document[0].body.appendChild(tempNode[0]);
                this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
                tempNode.remove();
              }
              return this.floatingScrollbars.cached;
            },
            forceFocus: function(element) {
              var node = element[0] || element;
              document.addEventListener('click', function focusOnClick(ev) {
                if (ev.target === node && ev.$focus) {
                  node.focus();
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  node.removeEventListener('click', focusOnClick);
                }
              }, true);
              var newEvent = document.createEvent('MouseEvents');
              newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null);
              newEvent.$material = true;
              newEvent.$focus = true;
              node.dispatchEvent(newEvent);
            },
            createBackdrop: function(scope, addClass) {
              return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
            },
            supplant: function(template, values, pattern) {
              pattern = pattern || /\{([^\{\}]*)\}/g;
              return template.replace(pattern, function(a, b) {
                var p = b.split('.'),
                    r = values;
                try {
                  for (var s in p) {
                    if (p.hasOwnProperty(s)) {
                      r = r[p[s]];
                    }
                  }
                } catch (e) {
                  r = a;
                }
                return (typeof r === 'string' || typeof r === 'number') ? r : a;
              });
            },
            fakeNgModel: function() {
              return {
                $fake: true,
                $setTouched: angular.noop,
                $setViewValue: function(value) {
                  this.$viewValue = value;
                  this.$render(value);
                  this.$viewChangeListeners.forEach(function(cb) {
                    cb();
                  });
                },
                $isEmpty: function(value) {
                  return ('' + value).length === 0;
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: [],
                $render: angular.noop
              };
            },
            debounce: function(func, wait, scope, invokeApply) {
              var timer;
              return function debounced() {
                var context = scope,
                    args = Array.prototype.slice.call(arguments);
                $timeout.cancel(timer);
                timer = $timeout(function() {
                  timer = undefined;
                  func.apply(context, args);
                }, wait || 10, invokeApply);
              };
            },
            throttle: function throttle(func, delay) {
              var recent;
              return function throttled() {
                var context = this;
                var args = arguments;
                var now = $mdUtil.now();
                if (!recent || (now - recent > delay)) {
                  func.apply(context, args);
                  recent = now;
                }
              };
            },
            time: function time(cb) {
              var start = $mdUtil.now();
              cb();
              return $mdUtil.now() - start;
            },
            valueOnUse: function(scope, key, getter) {
              var value = null,
                  args = Array.prototype.slice.call(arguments);
              var params = (args.length > 3) ? args.slice(3) : [];
              Object.defineProperty(scope, key, {get: function() {
                  if (value === null)
                    value = getter.apply(scope, params);
                  return value;
                }});
            },
            nextUid: function() {
              return '' + nextUniqueId++;
            },
            disconnectScope: function disconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (scope.$$destroyed)
                return;
              var parent = scope.$parent;
              scope.$$disconnected = true;
              if (parent.$$childHead === scope)
                parent.$$childHead = scope.$$nextSibling;
              if (parent.$$childTail === scope)
                parent.$$childTail = scope.$$prevSibling;
              if (scope.$$prevSibling)
                scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
              if (scope.$$nextSibling)
                scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
              scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
              if (!scope)
                return;
              if (scope.$root === scope)
                return;
              if (!scope.$$disconnected)
                return;
              var child = scope;
              var parent = child.$parent;
              child.$$disconnected = false;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
            },
            getClosest: function getClosest(el, tagName, onlyParent) {
              if (el instanceof angular.element)
                el = el[0];
              tagName = tagName.toUpperCase();
              if (onlyParent)
                el = el.parentNode;
              if (!el)
                return null;
              do {
                if (el.nodeName === tagName) {
                  return el;
                }
              } while (el = el.parentNode);
              return null;
            },
            elementContains: function(node, child) {
              var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
              var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                return (node === child) || !!(this.compareDocumentPosition(arg) & 16);
              });
              return findFn(child);
            },
            extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
              var found = scanTree(element);
              if (!found && !!warnNotFound) {
                $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [nodeName, element[0].outerHTML]));
              }
              return angular.element(found || element);
              function scanTree(element) {
                return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
              }
              function scanLevel(element) {
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    if (element[i].nodeName.toLowerCase() === nodeName) {
                      return element[i];
                    }
                  }
                }
                return null;
              }
              function scanChildren(element) {
                var found;
                if (element) {
                  for (var i = 0,
                      len = element.length; i < len; i++) {
                    var target = element[i];
                    if (!found) {
                      for (var j = 0,
                          numChild = target.childNodes.length; j < numChild; j++) {
                        found = found || scanTree([target.childNodes[j]]);
                      }
                    }
                  }
                }
                return found;
              }
            },
            initOptionalProperties: function(scope, attr, defaults) {
              defaults = defaults || {};
              angular.forEach(scope.$$isolateBindings, function(binding, key) {
                if (binding.optional && angular.isUndefined(scope[key])) {
                  var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                  scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                }
              });
            },
            nextTick: function(callback, digest, scope) {
              var nextTick = $mdUtil.nextTick;
              var timeout = nextTick.timeout;
              var queue = nextTick.queue || [];
              queue.push(callback);
              if (digest == null)
                digest = true;
              nextTick.digest = nextTick.digest || digest;
              nextTick.queue = queue;
              return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));
              function processQueue() {
                var skip = scope && scope.$$destroyed;
                var queue = !skip ? nextTick.queue : [];
                var digest = !skip ? nextTick.digest : null;
                nextTick.queue = [];
                nextTick.timeout = null;
                nextTick.digest = false;
                queue.forEach(function(callback) {
                  callback();
                });
                if (digest)
                  $rootScope.$digest();
              }
            },
            processTemplate: function(template) {
              if (usesStandardSymbols) {
                return template;
              } else {
                if (!template || !angular.isString(template))
                  return template;
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              }
            },
            getParentWithPointerEvents: function(element) {
              var parent = element.parent();
              while (hasComputedStyle(parent, 'pointer-events', 'none')) {
                parent = parent.parent();
              }
              return parent;
            },
            getNearestContentElement: function(element) {
              var current = element.parent()[0];
              while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
                current = current.parentNode;
              }
              return current;
            },
            hasComputedStyle: hasComputedStyle
          };
          $mdUtil.dom.animator = $$mdAnimate($mdUtil);
          return $mdUtil;
          function getNode(el) {
            return el[0] || el;
          }
        }
        UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window"];
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
          if (this.length) {
            this[0].focus();
          }
          return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
          if (this.length) {
            this[0].blur();
          }
          return this;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdAria', AriaService);
        function AriaService($$rAF, $log, $window, $interpolate) {
          return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
          };
          function expect(element, attrName, defaultValue) {
            var node = angular.element(element)[0] || element;
            if (node && ((!node.hasAttribute(attrName) || node.getAttribute(attrName).length === 0) && !childHasAttribute(node, attrName))) {
              defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';
              if (defaultValue.length) {
                element.attr(attrName, defaultValue);
              } else {
                $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
              }
            }
          }
          function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
              expect(element, attrName, defaultValueGetter());
            });
          }
          function expectWithText(element, attrName) {
            var content = getText(element) || "";
            var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
            if (hasBinding) {
              expectAsync(element, attrName, function() {
                return getText(element);
              });
            } else {
              expect(element, attrName, content);
            }
          }
          function getText(element) {
            return (element.text() || "").trim();
          }
          function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(),
                hasAttr = false;
            function isHidden(el) {
              var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
              return (style.display === 'none');
            }
            if (hasChildren) {
              var children = node.childNodes;
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                  if (!isHidden(child)) {
                    hasAttr = true;
                  }
                }
              }
            }
            return hasAttr;
          }
        }
        AriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
      })();
      (function() {
        "use strict";
        angular.module('material.core').service('$mdCompiler', mdCompilerService);
        function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
          this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = angular.extend({}, options.resolve || {});
            var locals = angular.extend({}, options.locals || {});
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
              if (angular.isString(value)) {
                resolve[key] = $injector.get(value);
              } else {
                resolve[key] = $injector.invoke(value);
              }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
              resolve.$template = $http.get(templateUrl, {cache: $templateCache}).then(function(response) {
                return response.data;
              });
            } else {
              resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
              var compiledData;
              var template = transformTemplate(locals.$template, options);
              var element = options.element || angular.element('<div>').html(template.trim()).contents();
              var linkFn = $compile(element);
              return compiledData = {
                locals: locals,
                element: element,
                link: function link(scope) {
                  locals.$scope = scope;
                  if (controller) {
                    var invokeCtrl = $controller(controller, locals, true);
                    if (bindToController) {
                      angular.extend(invokeCtrl.instance, locals);
                    }
                    var ctrl = invokeCtrl();
                    element.data('$ngControllerController', ctrl);
                    element.children().data('$ngControllerController', ctrl);
                    if (controllerAs) {
                      scope[controllerAs] = ctrl;
                    }
                    compiledData.controller = ctrl;
                  }
                  return linkFn(scope);
                }
              };
            });
          };
        }
        mdCompilerService.$inject = ["$q", "$http", "$injector", "$compile", "$controller", "$templateCache"];
      })();
      (function() {
        "use strict";
        var HANDLERS = {};
        var pointer,
            lastPointer,
            forceSkipClickHijack = false;
        var lastLabelClickPos = null;
        var isInitialized = false;
        angular.module('material.core.gestures', []).provider('$mdGesture', MdGestureProvider).factory('$$MdGestureHandler', MdGestureHandler).run(attachToDocument);
        function MdGestureProvider() {}
        MdGestureProvider.prototype = {
          skipClickHijack: function() {
            return forceSkipClickHijack = true;
          },
          $get: ["$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
            return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
          }]
        };
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          var isIos = userAgent.match(/ipad|iphone|ipod/i);
          var isAndroid = userAgent.match(/android/i);
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          var self = {
            handler: addHandler,
            register: register,
            isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
          };
          if (self.isHijackingClicks) {
            var maxClickDistance = 6;
            self.handler('click', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('click')
            });
            self.handler('focus', {
              options: {maxDistance: maxClickDistance},
              onEnd: function(ev, pointer) {
                if (pointer.distance < this.state.options.maxDistance) {
                  if (canFocus(ev.target)) {
                    this.dispatchEvent(ev, 'focus', pointer);
                    ev.target.focus();
                  }
                }
                function canFocus(element) {
                  var focusableElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'];
                  return (element.getAttribute('tabindex') != '-1') && !element.hasAttribute('DISABLED') && (element.hasAttribute('tabindex') || element.hasAttribute('href') || (focusableElements.indexOf(element.nodeName) != -1));
                }
              }
            });
            self.handler('mouseup', {
              options: {maxDistance: maxClickDistance},
              onEnd: checkDistanceAndEmit('mouseup')
            });
            self.handler('mousedown', {onStart: function(ev) {
                this.dispatchEvent(ev, 'mousedown');
              }});
          }
          function checkDistanceAndEmit(eventName) {
            return function(ev, pointer) {
              if (pointer.distance < this.state.options.maxDistance) {
                this.dispatchEvent(ev, eventName, pointer);
              }
            };
          }
          function register(element, handlerName, options) {
            var handler = HANDLERS[handlerName.replace(/^\$md./, '')];
            if (!handler) {
              throw new Error('Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object.keys(HANDLERS).join(', '));
            }
            return handler.registerElement(element, options);
          }
          function addHandler(name, definition) {
            var handler = new $$MdGestureHandler(name);
            angular.extend(handler, definition);
            HANDLERS[name] = handler;
            return self;
          }
          return self.handler('press', {
            onStart: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressdown');
            },
            onEnd: function(ev, pointer) {
              this.dispatchEvent(ev, '$md.pressup');
            }
          }).handler('hold', {
            options: {
              maxDistance: 6,
              delay: 500
            },
            onCancel: function() {
              $timeout.cancel(this.state.timeout);
            },
            onStart: function(ev, pointer) {
              if (!this.state.registeredParent)
                return this.cancel();
              this.state.pos = {
                x: pointer.x,
                y: pointer.y
              };
              this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
                this.dispatchEvent(ev, '$md.hold');
                this.cancel();
              }), this.state.options.delay, false);
            },
            onMove: function(ev, pointer) {
              ev.preventDefault();
              var dx = this.state.pos.x - pointer.x;
              var dy = this.state.pos.y - pointer.y;
              if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
                this.cancel();
              }
            },
            onEnd: function() {
              this.onCancel();
            }
          }).handler('drag', {
            options: {
              minDistance: 6,
              horizontal: true,
              cancelMultiplier: 1.5
            },
            onStart: function(ev) {
              if (!this.state.registeredParent)
                this.cancel();
            },
            onMove: function(ev, pointer) {
              var shouldStartDrag,
                  shouldCancel;
              ev.preventDefault();
              if (!this.state.dragPointer) {
                if (this.state.options.horizontal) {
                  shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                } else {
                  shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                  shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                }
                if (shouldStartDrag) {
                  this.state.dragPointer = makeStartPointer(ev);
                  updatePointerState(ev, this.state.dragPointer);
                  this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);
                } else if (shouldCancel) {
                  this.cancel();
                }
              } else {
                this.dispatchDragMove(ev);
              }
            },
            dispatchDragMove: $$rAF.throttle(function(ev) {
              if (this.state.isRunning) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);
              }
            }),
            onEnd: function(ev, pointer) {
              if (this.state.dragPointer) {
                updatePointerState(ev, this.state.dragPointer);
                this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);
              }
            }
          }).handler('swipe', {
            options: {
              minVelocity: 0.65,
              minDistance: 10
            },
            onEnd: function(ev, pointer) {
              var eventType;
              if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';
                this.dispatchEvent(ev, eventType);
              } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown';
                this.dispatchEvent(ev, eventType);
              }
            }
          });
        }
        MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
        function GestureHandler(name) {
          this.name = name;
          this.state = {};
        }
        function MdGestureHandler() {
          var hasJQuery = (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);
          GestureHandler.prototype = {
            options: {},
            dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
            onStart: angular.noop,
            onMove: angular.noop,
            onEnd: angular.noop,
            onCancel: angular.noop,
            start: function(ev, pointer) {
              if (this.state.isRunning)
                return;
              var parentTarget = this.getNearestParent(ev.target);
              var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
              this.state = {
                isRunning: true,
                options: angular.extend({}, this.options, parentTargetOptions),
                registeredParent: parentTarget
              };
              this.onStart(ev, pointer);
            },
            move: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onMove(ev, pointer);
            },
            end: function(ev, pointer) {
              if (!this.state.isRunning)
                return;
              this.onEnd(ev, pointer);
              this.state.isRunning = false;
            },
            cancel: function(ev, pointer) {
              this.onCancel(ev, pointer);
              this.state = {};
            },
            getNearestParent: function(node) {
              var current = node;
              while (current) {
                if ((current.$mdGesture || {})[this.name]) {
                  return current;
                }
                current = current.parentNode;
              }
              return null;
            },
            registerElement: function(element, options) {
              var self = this;
              element[0].$mdGesture = element[0].$mdGesture || {};
              element[0].$mdGesture[this.name] = options || {};
              element.on('$destroy', onDestroy);
              return onDestroy;
              function onDestroy() {
                delete element[0].$mdGesture[self.name];
                element.off('$destroy', onDestroy);
              }
            }
          };
          return GestureHandler;
          function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj = new angular.element.Event(eventType);
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            angular.extend(eventObj, {
              clientX: eventPointer.x,
              clientY: eventPointer.y,
              screenX: eventPointer.x,
              screenY: eventPointer.y,
              pageX: eventPointer.x,
              pageY: eventPointer.y,
              ctrlKey: srcEvent.ctrlKey,
              altKey: srcEvent.altKey,
              shiftKey: srcEvent.shiftKey,
              metaKey: srcEvent.metaKey
            });
            angular.element(eventPointer.target).trigger(eventObj);
          }
          function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj;
            if (eventType === 'click' || eventType == 'mouseup' || eventType == 'mousedown') {
              eventObj = document.createEvent('MouseEvents');
              eventObj.initMouseEvent(eventType, true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
            } else {
              eventObj = document.createEvent('CustomEvent');
              eventObj.initCustomEvent(eventType, true, true, {});
            }
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            eventPointer.target.dispatchEvent(eventObj);
          }
        }
        function attachToDocument($mdGesture, $$MdGestureHandler) {
          document.contains || (document.contains = function(node) {
            return document.body.contains(node);
          });
          if (!isInitialized && $mdGesture.isHijackingClicks) {
            document.addEventListener('click', clickHijacker, true);
            document.addEventListener('mouseup', mouseInputHijacker, true);
            document.addEventListener('mousedown', mouseInputHijacker, true);
            document.addEventListener('focus', mouseInputHijacker, true);
            isInitialized = true;
          }
          function mouseInputHijacker(ev) {
            var isKeyClick = !ev.clientX && !ev.clientY;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          }
          function clickHijacker(ev) {
            var isKeyClick = ev.clientX === 0 && ev.clientY === 0;
            if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
              ev.preventDefault();
              ev.stopPropagation();
              lastLabelClickPos = null;
            } else {
              lastLabelClickPos = null;
              if (ev.target.tagName.toLowerCase() == 'label') {
                lastLabelClickPos = {
                  x: ev.x,
                  y: ev.y
                };
              }
            }
          }
          var START_EVENTS = 'mousedown touchstart pointerdown';
          var MOVE_EVENTS = 'mousemove touchmove pointermove';
          var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';
          angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on('$$mdGestureReset', function gestureClearCache() {
            lastPointer = pointer = null;
          });
          function runHandlers(handlerEvent, event) {
            var handler;
            for (var name in HANDLERS) {
              handler = HANDLERS[name];
              if (handler instanceof $$MdGestureHandler) {
                if (handlerEvent === 'start') {
                  handler.cancel();
                }
                handler[handlerEvent](event, pointer);
              }
            }
          }
          function gestureStart(ev) {
            if (pointer)
              return;
            var now = +Date.now();
            if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {
              return;
            }
            pointer = makeStartPointer(ev);
            runHandlers('start', ev);
          }
          function gestureMove(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            runHandlers('move', ev);
          }
          function gestureEnd(ev) {
            if (!pointer || !typesMatch(ev, pointer))
              return;
            updatePointerState(ev, pointer);
            pointer.endTime = +Date.now();
            runHandlers('end', ev);
            lastPointer = pointer;
            pointer = null;
          }
        }
        attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];
        function makeStartPointer(ev) {
          var point = getEventPoint(ev);
          var startPointer = {
            startTime: +Date.now(),
            target: ev.target,
            type: ev.type.charAt(0)
          };
          startPointer.startX = startPointer.x = point.pageX;
          startPointer.startY = startPointer.y = point.pageY;
          return startPointer;
        }
        function typesMatch(ev, pointer) {
          return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        function isInputEventFromLabelClick(event) {
          return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        function updatePointerState(ev, pointer) {
          var point = getEventPoint(ev);
          var x = pointer.x = point.pageX;
          var y = pointer.y = point.pageY;
          pointer.distanceX = x - pointer.startX;
          pointer.distanceY = y - pointer.startY;
          pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
          pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';
          pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : '';
          pointer.duration = +Date.now() - pointer.startTime;
          pointer.velocityX = pointer.distanceX / pointer.duration;
          pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        function getEventPoint(ev) {
          ev = ev.originalEvent || ev;
          return (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').provider('$$interimElement', InterimElementProvider);
        function InterimElementProvider() {
          createInterimElementProvider.$get = InterimElementFactory;
          InterimElementFactory.$inject = ["$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector"];
          return createInterimElementProvider;
          function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];
            var customMethods = {};
            var providerConfig = {presets: {}};
            var provider = {
              setDefaults: setDefaults,
              addPreset: addPreset,
              addMethod: addMethod,
              $get: factory
            };
            provider.addPreset('build', {methods: ['controller', 'controllerAs', 'resolve', 'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']});
            factory.$inject = ["$$interimElement", "$injector"];
            return provider;
            function setDefaults(definition) {
              providerConfig.optionsFactory = definition.options;
              providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
              return provider;
            }
            function addMethod(name, fn) {
              customMethods[name] = fn;
              return provider;
            }
            function addPreset(name, definition) {
              definition = definition || {};
              definition.methods = definition.methods || [];
              definition.options = definition.options || function() {
                return {};
              };
              if (/^cancel|hide|show$/.test(name)) {
                throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
              }
              if (definition.methods.indexOf('_options') > -1) {
                throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
              }
              providerConfig.presets[name] = {
                methods: definition.methods.concat(EXPOSED_METHODS),
                optionsFactory: definition.options,
                argOption: definition.argOption
              };
              return provider;
            }
            function addPresetMethod(presetName, methodName, method) {
              providerConfig.presets[presetName][methodName] = method;
            }
            function factory($$interimElement, $injector) {
              var defaultMethods;
              var defaultOptions;
              var interimElementService = $$interimElement();
              var publicService = {
                hide: interimElementService.hide,
                cancel: interimElementService.cancel,
                show: showInterimElement,
                destroy: destroyInterimElement
              };
              defaultMethods = providerConfig.methods || [];
              defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
              angular.forEach(customMethods, function(fn, name) {
                publicService[name] = fn;
              });
              angular.forEach(providerConfig.presets, function(definition, name) {
                var presetDefaults = invokeFactory(definition.optionsFactory, {});
                var presetMethods = (definition.methods || []).concat(defaultMethods);
                angular.extend(presetDefaults, {$type: name});
                function Preset(opts) {
                  this._options = angular.extend({}, presetDefaults, opts);
                }
                angular.forEach(presetMethods, function(name) {
                  Preset.prototype[name] = function(value) {
                    this._options[name] = value;
                    return this;
                  };
                });
                if (definition.argOption) {
                  var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);
                  publicService[methodName] = function(arg) {
                    var config = publicService[name](arg);
                    return publicService.show(config);
                  };
                }
                publicService[name] = function(arg) {
                  if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                    return (new Preset())[definition.argOption](arg);
                  } else {
                    return new Preset(arg);
                  }
                };
              });
              return publicService;
              function showInterimElement(opts) {
                opts = opts || {};
                if (opts._options)
                  opts = opts._options;
                return interimElementService.show(angular.extend({}, defaultOptions, opts));
              }
              function destroyInterimElement(opts) {
                return interimElementService.destroy(opts);
              }
              function invokeFactory(factory, defaultVal) {
                var locals = {};
                locals[interimFactoryName] = publicService;
                return $injector.invoke(factory || function() {
                  return defaultVal;
                }, {}, locals);
              }
            }
          }
          function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
            return function createInterimElementService() {
              var SHOW_CANCELLED = false;
              var service,
                  stack = [];
              return service = {
                show: show,
                hide: hide,
                cancel: cancel,
                destroy: destroy,
                $injector_: $injector
              };
              function show(options) {
                options = options || {};
                var interimElement = new InterimElement(options || {});
                var hideExisting = !options.skipHide && stack.length ? service.hide() : $q.when(true);
                hideExisting.finally(function() {
                  stack.push(interimElement);
                  interimElement.show().catch(function(reason) {
                    return reason;
                  });
                });
                return interimElement.deferred.promise;
              }
              function hide(reason, options) {
                if (!stack.length)
                  return $q.when(reason);
                options = options || {};
                if (options.closeAll) {
                  var promise = $q.all(stack.reverse().map(closeElement));
                  stack = [];
                  return promise;
                } else if (options.closeTo !== undefined) {
                  return $q.all(stack.splice(options.closeTo).map(closeElement));
                } else {
                  var interim = stack.pop();
                  return closeElement(interim);
                }
                function closeElement(interim) {
                  interim.remove(reason, false, options || {}).catch(function(reason) {
                    return reason;
                  });
                  return interim.deferred.promise;
                }
              }
              function cancel(reason, options) {
                var interim = stack.shift();
                if (!interim)
                  return $q.when(reason);
                interim.remove(reason, true, options || {}).catch(function(reason) {
                  return reason;
                });
                return interim.deferred.promise;
              }
              function destroy(target) {
                var interim = !target ? stack.shift() : null;
                var cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                if (cntr) {
                  var filtered = stack.filter(function(entry) {
                    var currNode = entry.options.element[0];
                    return (currNode === cntr);
                  });
                  if (filtered.length > 0) {
                    interim = filtered[0];
                    stack.splice(stack.indexOf(interim), 1);
                  }
                }
                return interim ? interim.remove(SHOW_CANCELLED, false, {'$destroy': true}) : $q.when(SHOW_CANCELLED);
              }
              function InterimElement(options) {
                var self,
                    element,
                    showAction = $q.when(true);
                options = configureScopeAndTransitions(options);
                return self = {
                  options: options,
                  deferred: $q.defer(),
                  show: createAndTransitionIn,
                  remove: transitionOutAndRemove
                };
                function createAndTransitionIn() {
                  return $q(function(resolve, reject) {
                    compileElement(options).then(function(compiledData) {
                      element = linkElement(compiledData, options);
                      showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                    }, rejectAll);
                    function rejectAll(fault) {
                      self.deferred.reject(fault);
                      reject(fault);
                    }
                  });
                }
                function transitionOutAndRemove(response, isCancelled, opts) {
                  if (!element)
                    return $q.when(false);
                  options = angular.extend(options || {}, opts || {});
                  options.cancelAutoHide && options.cancelAutoHide();
                  options.element.triggerHandler('$mdInterimElementRemove');
                  if (options.$destroy === true) {
                    return hideElement(options.element, options).then(function() {
                      (isCancelled && rejectAll(response)) || resolveAll(response);
                    });
                  } else {
                    $q.when(showAction).finally(function() {
                      hideElement(options.element, options).then(function() {
                        (isCancelled && rejectAll(response)) || resolveAll(response);
                      }, rejectAll);
                    });
                    return self.deferred.promise;
                  }
                  function resolveAll(response) {
                    self.deferred.resolve(response);
                  }
                  function rejectAll(fault) {
                    self.deferred.reject(fault);
                  }
                }
                function configureScopeAndTransitions(options) {
                  options = options || {};
                  if (options.template) {
                    options.template = $mdUtil.processTemplate(options.template);
                  }
                  return angular.extend({
                    preserveScope: false,
                    cancelAutoHide: angular.noop,
                    scope: options.scope || $rootScope.$new(options.isolateScope),
                    onShow: function transitionIn(scope, element, options) {
                      return $animate.enter(element, options.parent);
                    },
                    onRemove: function transitionOut(scope, element) {
                      return element && $animate.leave(element) || $q.when();
                    }
                  }, options);
                }
                function compileElement(options) {
                  var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;
                  return compiled || $q(function(resolve) {
                    resolve({
                      locals: {},
                      link: function() {
                        return options.element;
                      }
                    });
                  });
                }
                function linkElement(compileData, options) {
                  angular.extend(compileData.locals, options);
                  var element = compileData.link(options.scope);
                  options.element = element;
                  options.parent = findParent(element, options);
                  if (options.themable)
                    $mdTheming(element);
                  return element;
                }
                function findParent(element, options) {
                  var parent = options.parent;
                  if (angular.isFunction(parent)) {
                    parent = parent(options.scope, element, options);
                  } else if (angular.isString(parent)) {
                    parent = angular.element($document[0].querySelector(parent));
                  } else {
                    parent = angular.element(parent);
                  }
                  if (!(parent || {}).length) {
                    var el;
                    if ($rootElement[0] && $rootElement[0].querySelector) {
                      el = $rootElement[0].querySelector(':not(svg) > body');
                    }
                    if (!el)
                      el = $rootElement[0];
                    if (el.nodeName == '#comment') {
                      el = $document[0].body;
                    }
                    return angular.element(el);
                  }
                  return parent;
                }
                function startAutoHide() {
                  var autoHideTimer,
                      cancelAutoHide = angular.noop;
                  if (options.hideDelay) {
                    autoHideTimer = $timeout(service.hide, options.hideDelay);
                    cancelAutoHide = function() {
                      $timeout.cancel(autoHideTimer);
                    };
                  }
                  options.cancelAutoHide = function() {
                    cancelAutoHide();
                    options.cancelAutoHide = undefined;
                  };
                }
                function showElement(element, options, controller) {
                  var notifyShowing = options.onShowing || angular.noop;
                  var notifyComplete = options.onComplete || angular.noop;
                  notifyShowing(options.scope, element, options, controller);
                  return $q(function(resolve, reject) {
                    try {
                      $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                        notifyComplete(options.scope, element, options);
                        startAutoHide();
                        resolve(element);
                      }, reject);
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
                function hideElement(element, options) {
                  var announceRemoving = options.onRemoving || angular.noop;
                  return $$q(function(resolve, reject) {
                    try {
                      var action = $$q.when(options.onRemove(options.scope, element, options) || true);
                      announceRemoving(element, action);
                      if (options.$destroy == true) {
                        resolve(element);
                      } else {
                        action.then(function() {
                          if (!options.preserveScope && options.scope) {
                            options.scope.$destroy();
                          }
                          resolve(element);
                        }, reject);
                      }
                    } catch (e) {
                      reject(e.message);
                    }
                  });
                }
              }
            };
          }
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var $mdUtil,
              $interpolate,
              $log;
          var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
          var WHITESPACE = /\s+/g;
          var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow'];
          var LAYOUT_OPTIONS = ['row', 'column'];
          var ALIGNMENT_MAIN_AXIS = ["", "start", "center", "end", "stretch", "space-around", "space-between"];
          var ALIGNMENT_CROSS_AXIS = ["", "start", "center", "end", "stretch"];
          var config = {
            enabled: true,
            breakpoints: []
          };
          registerLayoutAPI(angular.module('material.core.layout', ['ng']));
          function registerLayoutAPI(module) {
            var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var BREAKPOINTS = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"];
            var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
            var API_NO_VALUES = ["show", "hide", "layout-padding", "layout-margin"];
            angular.forEach(BREAKPOINTS, function(mqb) {
              angular.forEach(API_WITH_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
              });
              angular.forEach(API_NO_VALUES, function(name) {
                var fullName = mqb ? name + "-" + mqb : name;
                module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
              });
            });
            module.directive('mdLayoutCss', disableLayoutDirective).directive('ngCloak', buildCloakInterceptor('ng-cloak')).directive('layoutWrap', attributeWithoutValue('layout-wrap')).directive('layoutNowrap', attributeWithoutValue('layout-nowrap')).directive('layoutNoWrap', attributeWithoutValue('layout-no-wrap')).directive('layoutFill', attributeWithoutValue('layout-fill')).directive('layoutLtMd', warnAttrNotSupported('layout-lt-md', true)).directive('layoutLtLg', warnAttrNotSupported('layout-lt-lg', true)).directive('flexLtMd', warnAttrNotSupported('flex-lt-md', true)).directive('flexLtLg', warnAttrNotSupported('flex-lt-lg', true)).directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md')).directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg')).directive('flexOrderLtMd', warnAttrNotSupported('flex-order-lt-md')).directive('flexOrderLtLg', warnAttrNotSupported('flex-order-lt-lg')).directive('offsetLtMd', warnAttrNotSupported('flex-offset-lt-md')).directive('offsetLtLg', warnAttrNotSupported('flex-offset-lt-lg')).directive('hideLtMd', warnAttrNotSupported('hide-lt-md')).directive('hideLtLg', warnAttrNotSupported('hide-lt-lg')).directive('showLtMd', warnAttrNotSupported('show-lt-md')).directive('showLtLg', warnAttrNotSupported('show-lt-lg'));
            function directiveNormalize(name) {
              return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
              });
            }
          }
          function disableLayoutDirective() {
            return {
              restrict: 'A',
              priority: '900',
              compile: function(element, attr) {
                config.enabled = false;
                return angular.noop;
              }
            };
          }
          function buildCloakInterceptor(className) {
            return ['$timeout', function($timeout) {
              return {
                restrict: 'A',
                priority: -10,
                compile: function(element) {
                  if (!config.enabled)
                    return angular.noop;
                  element.addClass(className);
                  return function(scope, element) {
                    $timeout(function() {
                      element.removeClass(className);
                    }, 10, false);
                  };
                }
              };
            }];
          }
          function attributeWithObserve(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeUsage(className, attr, element, $log);
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    linkFn = translateWithValueToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateWithValueToCssClass(scope, element, attrs) {
              var updateFn = updateClassWithValue(element, className, attrs);
              var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
              updateFn(getNormalizedAttrValue(className, attrs, ""));
              scope.$on("$destroy", function() {
                unwatch();
              });
            }
          }
          function attributeWithoutValue(className) {
            return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
              $mdUtil = _$mdUtil_;
              $interpolate = _$interpolate_;
              $log = _$log_;
              return {
                restrict: 'A',
                compile: function(element, attr) {
                  var linkFn;
                  if (config.enabled) {
                    validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                    translateToCssClass(null, element);
                    linkFn = translateToCssClass;
                  }
                  return linkFn || angular.noop;
                }
              };
            }];
            function translateToCssClass(scope, element) {
              element.addClass(className);
            }
          }
          function updateClassWithValue(element, className) {
            var lastClass;
            return function updateClassFn(newValue) {
              var value = validateAttributeValue(className, newValue || "");
              if (angular.isDefined(value)) {
                if (lastClass)
                  element.removeClass(lastClass);
                lastClass = !value ? className : className + "-" + value.replace(WHITESPACE, "-");
                element.addClass(lastClass);
              }
            };
          }
          function warnAttrNotSupported(className) {
            var parts = className.split("-");
            return ["$log", function($log) {
              $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
              return angular.noop;
            }];
          }
          function validateAttributeUsage(className, attr, element, $log) {
            var message,
                usage,
                url;
            var nodeName = element[0].nodeName.toLowerCase();
            switch (className.replace(SUFFIXES, "")) {
              case "flex":
                if ((nodeName == "md-button") || (nodeName == "fieldset")) {
                  usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                  url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                  message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                  $log.warn($mdUtil.supplant(message, [usage, url]));
                }
            }
          }
          function validateAttributeValue(className, value, updateFn) {
            var origValue = value;
            if (!needsInterpolation(value)) {
              switch (className.replace(SUFFIXES, "")) {
                case 'layout':
                  if (!findIn(value, LAYOUT_OPTIONS)) {
                    value = LAYOUT_OPTIONS[0];
                  }
                  break;
                case 'flex':
                  if (!findIn(value, FLEX_OPTIONS)) {
                    if (isNaN(value)) {
                      value = '';
                    }
                  }
                  break;
                case 'flex-offset':
                case 'flex-order':
                  if (!value || isNaN(+value)) {
                    value = '0';
                  }
                  break;
                case 'layout-align':
                  var axis = extractAlignAxis(value);
                  value = $mdUtil.supplant("{main}-{cross}", axis);
                  break;
                case 'layout-padding':
                case 'layout-margin':
                case 'layout-fill':
                case 'layout-wrap':
                case 'layout-nowrap':
                case 'layout-nowrap':
                  value = '';
                  break;
              }
              if (value != origValue) {
                (updateFn || angular.noop)(value);
              }
            }
            return value;
          }
          function buildUpdateFn(element, className, attrs) {
            return function updateAttrValue(fallback) {
              if (!needsInterpolation(fallback)) {
                attrs[attrs.$normalize(className)] = fallback;
              }
            };
          }
          function needsInterpolation(value) {
            return (value || "").indexOf($interpolate.startSymbol()) > -1;
          }
          function getNormalizedAttrValue(className, attrs, defaultVal) {
            var normalizedAttr = attrs.$normalize(className);
            return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
          }
          function findIn(item, list, replaceWith) {
            item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
            var found = false;
            if (item) {
              list.forEach(function(it) {
                it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                found = found || (it === item);
              });
            }
            return found;
          }
          function extractAlignAxis(attrValue) {
            var axis = {
              main: "start",
              cross: "stretch"
            },
                values;
            attrValue = (attrValue || "");
            if (attrValue.indexOf("-") == 0 || attrValue.indexOf(" ") == 0) {
              attrValue = "none" + attrValue;
            }
            values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
            if (values.length && (values[0] === "space")) {
              values = [values[0] + "-" + values[1], values[2]];
            }
            if (values.length > 0)
              axis.main = values[0] || axis.main;
            if (values.length > 1)
              axis.cross = values[1] || axis.cross;
            if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0)
              axis.main = "start";
            if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0)
              axis.cross = "stretch";
            return axis;
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdComponentRegistry', ComponentRegistry);
        function ComponentRegistry($log, $q) {
          var self;
          var instances = [];
          var pendings = {};
          return self = {
            notFoundError: function(handle) {
              $log.error('No instance found for handle', handle);
            },
            getInstances: function() {
              return instances;
            },
            get: function(handle) {
              if (!isValidID(handle))
                return null;
              var i,
                  j,
                  instance;
              for (i = 0, j = instances.length; i < j; i++) {
                instance = instances[i];
                if (instance.$$mdHandle === handle) {
                  return instance;
                }
              }
              return null;
            },
            register: function(instance, handle) {
              if (!handle)
                return angular.noop;
              instance.$$mdHandle = handle;
              instances.push(instance);
              resolveWhen();
              return deregister;
              function deregister() {
                var index = instances.indexOf(instance);
                if (index !== -1) {
                  instances.splice(index, 1);
                }
              }
              function resolveWhen() {
                var dfd = pendings[handle];
                if (dfd) {
                  dfd.resolve(instance);
                  delete pendings[handle];
                }
              }
            },
            when: function(handle) {
              if (isValidID(handle)) {
                var deferred = $q.defer();
                var instance = self.get(handle);
                if (instance) {
                  deferred.resolve(instance);
                } else {
                  pendings[handle] = deferred;
                }
                return deferred.promise;
              }
              return $q.reject("Invalid `md-component-id` value.");
            }
          };
          function isValidID(handle) {
            return handle && (handle !== "");
          }
        }
        ComponentRegistry.$inject = ["$log", "$q"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdButtonInkRipple', MdButtonInkRipple);
          function MdButtonInkRipple($mdInkRipple) {
            return {attach: function attachRipple(scope, element, options) {
                options = angular.extend(optionsForElement(element), options);
                return $mdInkRipple.attach(scope, element, options);
              }};
            function optionsForElement(element) {
              if (element.hasClass('md-icon-button')) {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  fitRipple: true,
                  center: true
                };
              } else {
                return {
                  isMenuItem: element.hasClass('md-menu-item'),
                  dimBackground: true
                };
              }
            }
            ;
          }
          MdButtonInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);
          function MdCheckboxInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: true,
                dimBackground: false,
                fitRipple: true
              }, options));
            }
            ;
          }
          MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdListInkRipple', MdListInkRipple);
          function MdListInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdListInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$mdInkRipple', InkRippleService).directive('mdInkRipple', InkRippleDirective).directive('mdNoInk', attrNoDirective).directive('mdNoBar', attrNoDirective).directive('mdNoStretch', attrNoDirective);
        var DURATION = 450;
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
          return {
            controller: angular.noop,
            link: function(scope, element, attr) {
              attr.hasOwnProperty('mdInkRippleCheckbox') ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
            }
          };
        }
        InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
        function InkRippleService($injector) {
          return {attach: attach};
          function attach(scope, element, options) {
            if (element.controller('mdNoInk'))
              return angular.noop;
            return $injector.instantiate(InkRippleCtrl, {
              $scope: scope,
              $element: element,
              rippleOptions: options
            });
          }
        }
        InkRippleService.$inject = ["$injector"];
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
          this.$window = $window;
          this.$timeout = $timeout;
          this.$mdUtil = $mdUtil;
          this.$scope = $scope;
          this.$element = $element;
          this.options = rippleOptions;
          this.mousedown = false;
          this.ripples = [];
          this.timeout = null;
          this.lastRipple = null;
          $mdUtil.valueOnUse(this, 'container', this.createContainer);
          this.$element.addClass('md-ink-ripple');
          ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple);
          ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color);
          this.bindEvents();
        }
        InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil"];
        function autoCleanup(self, cleanupFn) {
          if (self.mousedown || self.lastRipple) {
            self.mousedown = false;
            self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);
          }
        }
        InkRippleCtrl.prototype.color = function(value) {
          var self = this;
          if (angular.isDefined(value)) {
            self._color = self._parseColor(value);
          }
          return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
          function getElementColor() {
            var items = self.options && self.options.colorElement ? self.options.colorElement : [];
            var elem = items.length ? items[0] : self.$element[0];
            return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';
          }
        };
        InkRippleCtrl.prototype.calculateColor = function() {
          return this.color();
        };
        InkRippleCtrl.prototype._parseColor = function parseColor(color, multiplier) {
          multiplier = multiplier || 1;
          if (!color)
            return;
          if (color.indexOf('rgba') === 0)
            return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')');
          if (color.indexOf('rgb') === 0)
            return rgbToRGBA(color);
          if (color.indexOf('#') === 0)
            return hexToRGBA(color);
          function hexToRGBA(color) {
            var hex = color[0] === '#' ? color.substr(1) : color,
                dig = hex.length / 3,
                red = hex.substr(0, dig),
                green = hex.substr(dig, dig),
                blue = hex.substr(dig * 2);
            if (dig === 1) {
              red += red;
              green += green;
              blue += blue;
            }
            return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';
          }
          function rgbToRGBA(color) {
            return color.replace(')', ', 0.1)').replace('(', 'a(');
          }
        };
        InkRippleCtrl.prototype.bindEvents = function() {
          this.$element.on('mousedown', angular.bind(this, this.handleMousedown));
          this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup));
          this.$element.on('mouseleave', angular.bind(this, this.handleMouseup));
          this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));
        };
        InkRippleCtrl.prototype.handleMousedown = function(event) {
          if (this.mousedown)
            return;
          if (event.hasOwnProperty('originalEvent'))
            event = event.originalEvent;
          this.mousedown = true;
          if (this.options.center) {
            this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);
          } else {
            if (event.srcElement !== this.$element[0]) {
              var layerRect = this.$element[0].getBoundingClientRect();
              var layerX = event.clientX - layerRect.left;
              var layerY = event.clientY - layerRect.top;
              this.createRipple(layerX, layerY);
            } else {
              this.createRipple(event.offsetX, event.offsetY);
            }
          }
        };
        InkRippleCtrl.prototype.handleMouseup = function() {
          autoCleanup(this, this.clearRipples);
        };
        InkRippleCtrl.prototype.handleTouchmove = function() {
          autoCleanup(this, this.deleteRipples);
        };
        InkRippleCtrl.prototype.deleteRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.ripples[i].remove();
          }
        };
        InkRippleCtrl.prototype.clearRipples = function() {
          for (var i = 0; i < this.ripples.length; i++) {
            this.fadeInComplete(this.ripples[i]);
          }
        };
        InkRippleCtrl.prototype.createContainer = function() {
          var container = angular.element('<div class="md-ripple-container"></div>');
          this.$element.append(container);
          return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
          if (this.timeout) {
            this.$timeout.cancel(this.timeout);
            this.timeout = null;
          }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
          var element = this.$element[0];
          do {
            if (!element.tagName || element.tagName === 'BODY')
              break;
            if (element && angular.isFunction(element.hasAttribute)) {
              if (element.hasAttribute('disabled'))
                return false;
              if (this.inkRipple() === 'false' || this.inkRipple() === '0')
                return false;
            }
          } while (element = element.parentNode);
          return true;
        };
        InkRippleCtrl.prototype.inkRipple = function() {
          return this.$element.attr('md-ink-ripple');
        };
        InkRippleCtrl.prototype.createRipple = function(left, top) {
          if (!this.isRippleAllowed())
            return;
          var ctrl = this;
          var ripple = angular.element('<div class="md-ripple"></div>');
          var width = this.$element.prop('clientWidth');
          var height = this.$element.prop('clientHeight');
          var x = Math.max(Math.abs(width - left), left) * 2;
          var y = Math.max(Math.abs(height - top), top) * 2;
          var size = getSize(this.options.fitRipple, x, y);
          var color = this.calculateColor();
          ripple.css({
            left: left + 'px',
            top: top + 'px',
            background: 'black',
            width: size + 'px',
            height: size + 'px',
            backgroundColor: rgbaToRGB(color),
            borderColor: rgbaToRGB(color)
          });
          this.lastRipple = ripple;
          this.clearTimeout();
          this.timeout = this.$timeout(function() {
            ctrl.clearTimeout();
            if (!ctrl.mousedown)
              ctrl.fadeInComplete(ripple);
          }, DURATION * 0.35, false);
          if (this.options.dimBackground)
            this.container.css({backgroundColor: color});
          this.container.append(ripple);
          this.ripples.push(ripple);
          ripple.addClass('md-ripple-placed');
          this.$mdUtil.nextTick(function() {
            ripple.addClass('md-ripple-scaled md-ripple-active');
            ctrl.$timeout(function() {
              ctrl.clearRipples();
            }, DURATION, false);
          }, false);
          function rgbaToRGB(color) {
            return color ? color.replace('rgba', 'rgb').replace(/,[^\),]+\)/, ')') : 'rgb(0,0,0)';
          }
          function getSize(fit, x, y) {
            return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
          }
        };
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
          if (this.lastRipple === ripple) {
            if (!this.timeout && !this.mousedown) {
              this.removeRipple(ripple);
            }
          } else {
            this.removeRipple(ripple);
          }
        };
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
          var ctrl = this;
          var index = this.ripples.indexOf(ripple);
          if (index < 0)
            return;
          this.ripples.splice(this.ripples.indexOf(ripple), 1);
          ripple.removeClass('md-ripple-active');
          if (this.ripples.length === 0)
            this.container.css({backgroundColor: ''});
          this.$timeout(function() {
            ctrl.fadeOutComplete(ripple);
          }, DURATION, false);
        };
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
          ripple.remove();
          this.lastRipple = null;
        };
        function attrNoDirective() {
          return {controller: angular.noop};
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.core').factory('$mdTabInkRipple', MdTabInkRipple);
          function MdTabInkRipple($mdInkRipple) {
            return {attach: attach};
            function attach(scope, element, options) {
              return $mdInkRipple.attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: 'full'
              }, options));
            }
            ;
          }
          MdTabInkRipple.$inject = ["$mdInkRipple"];
          ;
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming.palette', []).constant('$mdColorPalette', {
          'red': {
            '50': '#ffebee',
            '100': '#ffcdd2',
            '200': '#ef9a9a',
            '300': '#e57373',
            '400': '#ef5350',
            '500': '#f44336',
            '600': '#e53935',
            '700': '#d32f2f',
            '800': '#c62828',
            '900': '#b71c1c',
            'A100': '#ff8a80',
            'A200': '#ff5252',
            'A400': '#ff1744',
            'A700': '#d50000',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 A100',
            'contrastStrongLightColors': '400 500 600 700 A200 A400 A700'
          },
          'pink': {
            '50': '#fce4ec',
            '100': '#f8bbd0',
            '200': '#f48fb1',
            '300': '#f06292',
            '400': '#ec407a',
            '500': '#e91e63',
            '600': '#d81b60',
            '700': '#c2185b',
            '800': '#ad1457',
            '900': '#880e4f',
            'A100': '#ff80ab',
            'A200': '#ff4081',
            'A400': '#f50057',
            'A700': '#c51162',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '500 600 A200 A400 A700'
          },
          'purple': {
            '50': '#f3e5f5',
            '100': '#e1bee7',
            '200': '#ce93d8',
            '300': '#ba68c8',
            '400': '#ab47bc',
            '500': '#9c27b0',
            '600': '#8e24aa',
            '700': '#7b1fa2',
            '800': '#6a1b9a',
            '900': '#4a148c',
            'A100': '#ea80fc',
            'A200': '#e040fb',
            'A400': '#d500f9',
            'A700': '#aa00ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400 A700'
          },
          'deep-purple': {
            '50': '#ede7f6',
            '100': '#d1c4e9',
            '200': '#b39ddb',
            '300': '#9575cd',
            '400': '#7e57c2',
            '500': '#673ab7',
            '600': '#5e35b1',
            '700': '#512da8',
            '800': '#4527a0',
            '900': '#311b92',
            'A100': '#b388ff',
            'A200': '#7c4dff',
            'A400': '#651fff',
            'A700': '#6200ea',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200'
          },
          'indigo': {
            '50': '#e8eaf6',
            '100': '#c5cae9',
            '200': '#9fa8da',
            '300': '#7986cb',
            '400': '#5c6bc0',
            '500': '#3f51b5',
            '600': '#3949ab',
            '700': '#303f9f',
            '800': '#283593',
            '900': '#1a237e',
            'A100': '#8c9eff',
            'A200': '#536dfe',
            'A400': '#3d5afe',
            'A700': '#304ffe',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 A100',
            'contrastStrongLightColors': '300 400 A200 A400'
          },
          'blue': {
            '50': '#e3f2fd',
            '100': '#bbdefb',
            '200': '#90caf9',
            '300': '#64b5f6',
            '400': '#42a5f5',
            '500': '#2196f3',
            '600': '#1e88e5',
            '700': '#1976d2',
            '800': '#1565c0',
            '900': '#0d47a1',
            'A100': '#82b1ff',
            'A200': '#448aff',
            'A400': '#2979ff',
            'A700': '#2962ff',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100',
            'contrastStrongLightColors': '500 600 700 A200 A400 A700'
          },
          'light-blue': {
            '50': '#e1f5fe',
            '100': '#b3e5fc',
            '200': '#81d4fa',
            '300': '#4fc3f7',
            '400': '#29b6f6',
            '500': '#03a9f4',
            '600': '#039be5',
            '700': '#0288d1',
            '800': '#0277bd',
            '900': '#01579b',
            'A100': '#80d8ff',
            'A200': '#40c4ff',
            'A400': '#00b0ff',
            'A700': '#0091ea',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900 A700',
            'contrastStrongLightColors': '600 700 800 A700'
          },
          'cyan': {
            '50': '#e0f7fa',
            '100': '#b2ebf2',
            '200': '#80deea',
            '300': '#4dd0e1',
            '400': '#26c6da',
            '500': '#00bcd4',
            '600': '#00acc1',
            '700': '#0097a7',
            '800': '#00838f',
            '900': '#006064',
            'A100': '#84ffff',
            'A200': '#18ffff',
            'A400': '#00e5ff',
            'A700': '#00b8d4',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'teal': {
            '50': '#e0f2f1',
            '100': '#b2dfdb',
            '200': '#80cbc4',
            '300': '#4db6ac',
            '400': '#26a69a',
            '500': '#009688',
            '600': '#00897b',
            '700': '#00796b',
            '800': '#00695c',
            '900': '#004d40',
            'A100': '#a7ffeb',
            'A200': '#64ffda',
            'A400': '#1de9b6',
            'A700': '#00bfa5',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '500 600 700 800 900',
            'contrastStrongLightColors': '500 600 700'
          },
          'green': {
            '50': '#e8f5e9',
            '100': '#c8e6c9',
            '200': '#a5d6a7',
            '300': '#81c784',
            '400': '#66bb6a',
            '500': '#4caf50',
            '600': '#43a047',
            '700': '#388e3c',
            '800': '#2e7d32',
            '900': '#1b5e20',
            'A100': '#b9f6ca',
            'A200': '#69f0ae',
            'A400': '#00e676',
            'A700': '#00c853',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900',
            'contrastStrongLightColors': '600 700'
          },
          'light-green': {
            '50': '#f1f8e9',
            '100': '#dcedc8',
            '200': '#c5e1a5',
            '300': '#aed581',
            '400': '#9ccc65',
            '500': '#8bc34a',
            '600': '#7cb342',
            '700': '#689f38',
            '800': '#558b2f',
            '900': '#33691e',
            'A100': '#ccff90',
            'A200': '#b2ff59',
            'A400': '#76ff03',
            'A700': '#64dd17',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '700 800 900',
            'contrastStrongLightColors': '700 800 900'
          },
          'lime': {
            '50': '#f9fbe7',
            '100': '#f0f4c3',
            '200': '#e6ee9c',
            '300': '#dce775',
            '400': '#d4e157',
            '500': '#cddc39',
            '600': '#c0ca33',
            '700': '#afb42b',
            '800': '#9e9d24',
            '900': '#827717',
            'A100': '#f4ff81',
            'A200': '#eeff41',
            'A400': '#c6ff00',
            'A700': '#aeea00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '900',
            'contrastStrongLightColors': '900'
          },
          'yellow': {
            '50': '#fffde7',
            '100': '#fff9c4',
            '200': '#fff59d',
            '300': '#fff176',
            '400': '#ffee58',
            '500': '#ffeb3b',
            '600': '#fdd835',
            '700': '#fbc02d',
            '800': '#f9a825',
            '900': '#f57f17',
            'A100': '#ffff8d',
            'A200': '#ffff00',
            'A400': '#ffea00',
            'A700': '#ffd600',
            'contrastDefaultColor': 'dark'
          },
          'amber': {
            '50': '#fff8e1',
            '100': '#ffecb3',
            '200': '#ffe082',
            '300': '#ffd54f',
            '400': '#ffca28',
            '500': '#ffc107',
            '600': '#ffb300',
            '700': '#ffa000',
            '800': '#ff8f00',
            '900': '#ff6f00',
            'A100': '#ffe57f',
            'A200': '#ffd740',
            'A400': '#ffc400',
            'A700': '#ffab00',
            'contrastDefaultColor': 'dark'
          },
          'orange': {
            '50': '#fff3e0',
            '100': '#ffe0b2',
            '200': '#ffcc80',
            '300': '#ffb74d',
            '400': '#ffa726',
            '500': '#ff9800',
            '600': '#fb8c00',
            '700': '#f57c00',
            '800': '#ef6c00',
            '900': '#e65100',
            'A100': '#ffd180',
            'A200': '#ffab40',
            'A400': '#ff9100',
            'A700': '#ff6d00',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '800 900',
            'contrastStrongLightColors': '800 900'
          },
          'deep-orange': {
            '50': '#fbe9e7',
            '100': '#ffccbc',
            '200': '#ffab91',
            '300': '#ff8a65',
            '400': '#ff7043',
            '500': '#ff5722',
            '600': '#f4511e',
            '700': '#e64a19',
            '800': '#d84315',
            '900': '#bf360c',
            'A100': '#ff9e80',
            'A200': '#ff6e40',
            'A400': '#ff3d00',
            'A700': '#dd2c00',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300 400 A100 A200',
            'contrastStrongLightColors': '500 600 700 800 900 A400 A700'
          },
          'brown': {
            '50': '#efebe9',
            '100': '#d7ccc8',
            '200': '#bcaaa4',
            '300': '#a1887f',
            '400': '#8d6e63',
            '500': '#795548',
            '600': '#6d4c41',
            '700': '#5d4037',
            '800': '#4e342e',
            '900': '#3e2723',
            'A100': '#d7ccc8',
            'A200': '#bcaaa4',
            'A400': '#8d6e63',
            'A700': '#5d4037',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200',
            'contrastStrongLightColors': '300 400'
          },
          'grey': {
            '50': '#fafafa',
            '100': '#f5f5f5',
            '200': '#eeeeee',
            '300': '#e0e0e0',
            '400': '#bdbdbd',
            '500': '#9e9e9e',
            '600': '#757575',
            '700': '#616161',
            '800': '#424242',
            '900': '#212121',
            '1000': '#000000',
            'A100': '#ffffff',
            'A200': '#eeeeee',
            'A400': '#bdbdbd',
            'A700': '#616161',
            'contrastDefaultColor': 'dark',
            'contrastLightColors': '600 700 800 900'
          },
          'blue-grey': {
            '50': '#eceff1',
            '100': '#cfd8dc',
            '200': '#b0bec5',
            '300': '#90a4ae',
            '400': '#78909c',
            '500': '#607d8b',
            '600': '#546e7a',
            '700': '#455a64',
            '800': '#37474f',
            '900': '#263238',
            'A100': '#cfd8dc',
            'A200': '#b0bec5',
            'A400': '#78909c',
            'A700': '#455a64',
            'contrastDefaultColor': 'light',
            'contrastDarkColors': '50 100 200 300',
            'contrastStrongLightColors': '400 500'
          }
        });
      })();
      (function() {
        "use strict";
        angular.module('material.core.theming', ['material.core.theming.palette']).directive('mdTheme', ThemingDirective).directive('mdThemable', ThemableDirective).provider('$mdTheming', ThemingProvider).run(generateAllThemes);
        var GENERATED = {};
        var PALETTES;
        var THEMES;
        var DARK_FOREGROUND = {
          name: 'dark',
          '1': 'rgba(0,0,0,0.87)',
          '2': 'rgba(0,0,0,0.54)',
          '3': 'rgba(0,0,0,0.26)',
          '4': 'rgba(0,0,0,0.12)'
        };
        var LIGHT_FOREGROUND = {
          name: 'light',
          '1': 'rgba(255,255,255,1.0)',
          '2': 'rgba(255,255,255,0.7)',
          '3': 'rgba(255,255,255,0.3)',
          '4': 'rgba(255,255,255,0.12)'
        };
        var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';
        var LIGHT_SHADOW = '';
        var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');
        var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)');
        var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');
        var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];
        var DEFAULT_COLOR_TYPE = 'primary';
        var LIGHT_DEFAULT_HUES = {
          'accent': {
            'default': 'A200',
            'hue-1': 'A100',
            'hue-2': 'A400',
            'hue-3': 'A700'
          },
          'background': {
            'default': 'A100',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': '900'
          }
        };
        var DARK_DEFAULT_HUES = {'background': {
            'default': '800',
            'hue-1': '600',
            'hue-2': '300',
            'hue-3': '900'
          }};
        THEME_COLOR_TYPES.forEach(function(colorType) {
          var defaultDefaultHues = {
            'default': '500',
            'hue-1': '300',
            'hue-2': '800',
            'hue-3': 'A100'
          };
          if (!LIGHT_DEFAULT_HUES[colorType])
            LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
          if (!DARK_DEFAULT_HUES[colorType])
            DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
        });
        var VALID_HUE_VALUES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'A100', 'A200', 'A400', 'A700'];
        var generateOnDemand = false;
        var nonce = null;
        function ThemingProvider($mdColorPalette) {
          PALETTES = {};
          THEMES = {};
          var themingProvider;
          var defaultTheme = 'default';
          var alwaysWatchTheme = false;
          angular.extend(PALETTES, $mdColorPalette);
          ThemingService.$inject = ["$rootScope", "$log"];
          return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            setNonce: function(nonceValue) {
              nonce = nonceValue;
            },
            setDefaultTheme: function(theme) {
              defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
              alwaysWatchTheme = alwaysWatch;
            },
            generateThemesOnDemand: function(onDemand) {
              generateOnDemand = onDemand;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
          };
          function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
          }
          function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
          }
          function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
              return !map[field];
            });
            if (missingColors.length) {
              throw new Error("Missing colors %1 in palette %2!".replace('%1', missingColors.join(', ')).replace('%2', name));
            }
            return map;
          }
          function registerTheme(name, inheritFrom) {
            if (THEMES[name])
              return THEMES[name];
            inheritFrom = inheritFrom || 'default';
            var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
              angular.forEach(parentTheme.colors, function(color, colorType) {
                theme.colors[colorType] = {
                  name: color.name,
                  hues: angular.extend({}, color.hues)
                };
              });
            }
            THEMES[name] = theme;
            return theme;
          }
          function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
              isDark = arguments.length === 0 ? true : !!isDark;
              if (isDark === self.isDark)
                return;
              self.isDark = isDark;
              self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
              self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
              var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
              var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
              angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                var color = self.colors[colorType];
                var oldDefaults = oldDefaultHues[colorType];
                if (color) {
                  for (var hueName in color.hues) {
                    if (color.hues[hueName] === oldDefaults[hueName]) {
                      color.hues[hueName] = newDefaults[hueName];
                    }
                  }
                }
              });
              return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
              self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {
                var color = self.colors[colorType] = {
                  name: paletteName,
                  hues: angular.extend({}, defaultHues, hues)
                };
                Object.keys(color.hues).forEach(function(name) {
                  if (!defaultHues[name]) {
                    throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace('%1', name).replace('%2', self.name).replace('%3', paletteName).replace('%4', Object.keys(defaultHues).join(', ')));
                  }
                });
                Object.keys(color.hues).map(function(key) {
                  return color.hues[key];
                }).forEach(function(hueValue) {
                  if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                    throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace('%1', hueValue).replace('%2', self.name).replace('%3', colorType).replace('%4', paletteName).replace('%5', VALID_HUE_VALUES.join(', ')));
                  }
                });
                return self;
              };
              self[colorType + 'Color'] = function() {
                var args = Array.prototype.slice.call(arguments);
                console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' + 'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');
                return self[colorType + 'Palette'].apply(self, args);
              };
            });
          }
          function ThemingService($rootScope, $log) {
            applyTheme.inherit = function(el, parent) {
              var ctrl = parent.controller('mdTheme');
              var attrThemeValue = el.attr('md-theme-watch');
              if ((alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {
                var deregisterWatch = $rootScope.$watch(function() {
                  return ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                }, changeTheme);
                el.on('$destroy', deregisterWatch);
              } else {
                var theme = ctrl && ctrl.$mdTheme || (defaultTheme == 'default' ? '' : defaultTheme);
                changeTheme(theme);
              }
              function changeTheme(theme) {
                if (!theme)
                  return;
                if (!registered(theme)) {
                  $log.warn('Attempted to use unregistered theme \'' + theme + '\'. ' + 'Register it with $mdThemingProvider.theme().');
                }
                var oldTheme = el.data('$mdThemeName');
                if (oldTheme)
                  el.removeClass('md-' + oldTheme + '-theme');
                el.addClass('md-' + theme + '-theme');
                el.data('$mdThemeName', theme);
                if (ctrl) {
                  el.data('$mdThemeController', ctrl);
                }
              }
            };
            applyTheme.THEMES = angular.extend({}, THEMES);
            applyTheme.defaultTheme = function() {
              return defaultTheme;
            };
            applyTheme.registered = registered;
            applyTheme.generateTheme = function(name) {
              generateTheme(name, nonce);
            };
            return applyTheme;
            function registered(themeName) {
              if (themeName === undefined || themeName === '')
                return true;
              return applyTheme.THEMES[themeName] !== undefined;
            }
            function applyTheme(scope, el) {
              if (el === undefined) {
                el = scope;
                scope = undefined;
              }
              if (scope === undefined) {
                scope = $rootScope;
              }
              applyTheme.inherit(el, el);
            }
          }
        }
        ThemingProvider.$inject = ["$mdColorPalette"];
        function ThemingDirective($mdTheming, $interpolate, $log) {
          return {
            priority: 100,
            link: {pre: function(scope, el, attrs) {
                var ctrl = {$setTheme: function(theme) {
                    if (!$mdTheming.registered(theme)) {
                      $log.warn('attempted to use unregistered theme \'' + theme + '\'');
                    }
                    ctrl.$mdTheme = theme;
                  }};
                el.data('$mdThemeController', ctrl);
                ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                attrs.$observe('mdTheme', ctrl.$setTheme);
              }}
          };
        }
        ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$log"];
        function ThemableDirective($mdTheming) {
          return $mdTheming;
        }
        ThemableDirective.$inject = ["$mdTheming"];
        function parseRules(theme, colorType, rules) {
          checkValidPalette(theme, colorType);
          rules = rules.replace(/THEME_NAME/g, theme.name);
          var generatedRules = [];
          var color = theme.colors[colorType];
          var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');
          var hueRegex = new RegExp('(\'|")?{{\\s*(' + colorType + ')-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|\')?', 'g');
          var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;
          var palette = PALETTES[color.name];
          rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
            if (colorType === 'foreground') {
              if (hue == 'shadow') {
                return theme.foregroundShadow;
              } else {
                return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];
              }
            }
            if (hue.indexOf('hue') === 0) {
              hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || '')[contrast ? 'contrast' : 'value'], opacity);
          });
          angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
              return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);
            });
            if (hueName !== 'default') {
              newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);
            }
            if (theme.name == 'default') {
              var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
              newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                return match + ', ' + prefix + target + suffix;
              });
            }
            generatedRules.push(newRule);
          });
          return generatedRules;
        }
        var rulesByType = {};
        function generateAllThemes($injector) {
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';
          if (!firstChild)
            return;
          if (themeCss.length === 0)
            return;
          angular.forEach(PALETTES, sanitizePalette);
          var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
          }).map(function(rule) {
            return rule.trim() + '}';
          });
          var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');
          THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = '';
          });
          rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0,
                type; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf('.md-' + type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
              if (rule.indexOf(type) > -1) {
                return rulesByType[type] += rule;
              }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
          });
          if (generateOnDemand)
            return;
          angular.forEach(THEMES, function(theme) {
            if (!GENERATED[theme.name]) {
              generateTheme(theme.name, nonce);
            }
          });
          function sanitizePalette(palette) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var strongLightColors = palette.contrastStrongLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === 'string')
              lightColors = lightColors.split(' ');
            if (typeof strongLightColors === 'string')
              strongLightColors = strongLightColors.split(' ');
            if (typeof darkColors === 'string')
              darkColors = darkColors.split(' ');
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastStrongLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
              if (angular.isObject(hueValue))
                return;
              var rgbValue = colorToRgbaArray(hueValue);
              if (!rgbValue) {
                throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace('%1', hueValue).replace('%2', palette.name).replace('%3', hueName));
              }
              palette[hueName] = {
                value: rgbValue,
                contrast: getContrastColor()
              };
              function getContrastColor() {
                if (defaultContrast === 'light') {
                  if (darkColors.indexOf(hueName) > -1) {
                    return DARK_CONTRAST_COLOR;
                  } else {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  }
                } else {
                  if (lightColors.indexOf(hueName) > -1) {
                    return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                  } else {
                    return DARK_CONTRAST_COLOR;
                  }
                }
              }
            });
          }
        }
        generateAllThemes.$inject = ["$injector"];
        function generateTheme(name, nonce) {
          var theme = THEMES[name];
          var head = document.head;
          var firstChild = head ? head.firstElementChild : null;
          if (!GENERATED[name]) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
              var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
              while (styleStrings.length) {
                var styleContent = styleStrings.shift();
                if (styleContent) {
                  var style = document.createElement('style');
                  style.setAttribute('md-theme-style', '');
                  if (nonce) {
                    style.setAttribute('nonce', nonce);
                  }
                  style.appendChild(document.createTextNode(styleContent));
                  head.insertBefore(style, firstChild);
                }
              }
            });
            if (theme.colors.primary.name == theme.colors.accent.name) {
              console.warn('$mdThemingProvider: Using the same palette for primary and' + ' accent. This violates the material design spec.');
            }
            GENERATED[theme.name] = true;
          }
        }
        function checkValidPalette(theme, colorType) {
          if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace('%1', theme.name).replace('%2', colorType).replace('%3', Object.keys(PALETTES).join(', ')));
          }
        }
        function colorToRgbaArray(clr) {
          if (angular.isArray(clr) && clr.length == 3)
            return clr;
          if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, '').split(',').map(function(value, i) {
              return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
            });
          }
          if (clr.charAt(0) == '#')
            clr = clr.substring(1);
          if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr))
            return;
          var dig = clr.length / 3;
          var red = clr.substr(0, dig);
          var grn = clr.substr(dig, dig);
          var blu = clr.substr(dig * 2);
          if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
          }
          return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
        }
        function rgba(rgbArray, opacity) {
          if (!rgbArray)
            return "rgb('0,0,0')";
          if (rgbArray.length == 4) {
            rgbArray = angular.copy(rgbArray);
            opacity ? rgbArray.pop() : opacity = rgbArray.pop();
          }
          return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ? 'rgba(' + rgbArray.join(',') + ',' + opacity + ')' : 'rgb(' + rgbArray.join(',') + ')';
        }
      })();
      (function() {
        "use strict";
        angular.module('material.core').factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
          return function($mdUtil) {
            return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
          };
        }]);
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
          var self;
          return self = {
            translate3d: function(target, from, to, options) {
              return $animateCss(target, {
                from: from,
                to: to,
                addClass: options.transitionInClass
              }).start().then(function() {
                return reverseTranslate;
              });
              function reverseTranslate(newFrom) {
                return $animateCss(target, {
                  to: newFrom || from,
                  addClass: options.transitionOutClass,
                  removeClass: options.transitionInClass
                }).start();
              }
            },
            waitTransitionEnd: function(element, opts) {
              var TIMEOUT = 3000;
              return $q(function(resolve, reject) {
                opts = opts || {};
                var timer = $timeout(finished, opts.timeout || TIMEOUT);
                element.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                  if (ev && ev.target !== element[0])
                    return;
                  if (ev)
                    $timeout.cancel(timer);
                  element.off($mdConstant.CSS.TRANSITIONEND, finished);
                  resolve();
                }
              });
            },
            calculateZoomToOrigin: function(element, originator) {
              var origin = originator.element;
              var bounds = originator.bounds;
              var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
              var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
              var zoomStyle = buildZoom({
                centerX: 0,
                centerY: 0,
                scaleX: 0.5,
                scaleY: 0.5
              });
              if (origin || bounds) {
                var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
                var dialogRect = self.copyRect(element[0].getBoundingClientRect());
                var dialogCenterPt = self.centerPointFor(dialogRect);
                var originCenterPt = self.centerPointFor(originBnds);
                zoomStyle = buildZoom({
                  centerX: originCenterPt.x - dialogCenterPt.x,
                  centerY: originCenterPt.y - dialogCenterPt.y,
                  scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100,
                  scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100
                });
              }
              return zoomStyle;
              function currentBounds() {
                var cntr = element ? element.parent() : null;
                var parent = cntr ? cntr.parent() : null;
                return parent ? self.clientRect(parent) : null;
              }
            },
            toCss: function(raw) {
              var css = {};
              var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';
              angular.forEach(raw, function(value, key) {
                if (angular.isUndefined(value))
                  return;
                if (lookups.indexOf(key) >= 0) {
                  css[key] = value + 'px';
                } else {
                  switch (key) {
                    case 'transition':
                      convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                      break;
                    case 'transform':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                      break;
                    case 'transformOrigin':
                      convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                      break;
                  }
                }
              });
              return css;
              function convertToVendor(key, vendor, value) {
                angular.forEach(vendor.split(' '), function(key) {
                  css[key] = value;
                });
              }
            },
            toTransformCss: function(transform, addTransition, transition) {
              var css = {};
              angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function(key) {
                css[key] = transform;
              });
              if (addTransition) {
                transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                css['transition'] = transition;
              }
              return css;
            },
            copyRect: function(source, destination) {
              if (!source)
                return null;
              destination = destination || {};
              angular.forEach('left top right bottom width height'.split(' '), function(key) {
                destination[key] = Math.round(source[key]);
              });
              destination.width = destination.width || (destination.right - destination.left);
              destination.height = destination.height || (destination.bottom - destination.top);
              return destination;
            },
            clientRect: function(element) {
              var bounds = angular.element(element)[0].getBoundingClientRect();
              var isPositiveSizeClientRect = function(rect) {
                return rect && (rect.width > 0) && (rect.height > 0);
              };
              return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
            },
            centerPointFor: function(targetRect) {
              return targetRect ? {
                x: Math.round(targetRect.left + (targetRect.width / 2)),
                y: Math.round(targetRect.top + (targetRect.height / 2))
              } : {
                x: 0,
                y: 0
              };
            }
          };
        }
        ;
      })();
      (function() {
        "use strict";
        "use strict";
        if (angular.version.minor >= 4) {
          angular.module('material.core.animate', []);
        } else {
          (function() {
            var forEach = angular.forEach;
            var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
            var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition';
            var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation';
            var PREFIX = WEBKIT ? '-webkit-' : '';
            var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend';
            var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend';
            var $$ForceReflowFactory = ['$document', function($document) {
              return function() {
                return $document[0].body.clientWidth + 1;
              };
            }];
            var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
              return function() {
                var passed = false;
                $$rAF(function() {
                  passed = true;
                });
                return function(fn) {
                  passed ? fn() : $$rAF(fn);
                };
              };
            }];
            var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
              var INITIAL_STATE = 0;
              var DONE_PENDING_STATE = 1;
              var DONE_COMPLETE_STATE = 2;
              function AnimateRunner(host) {
                this.setHost(host);
                this._doneCallbacks = [];
                this._runInAnimationFrame = $$rAFMutex();
                this._state = 0;
              }
              AnimateRunner.prototype = {
                setHost: function(host) {
                  this.host = host || {};
                },
                done: function(fn) {
                  if (this._state === DONE_COMPLETE_STATE) {
                    fn();
                  } else {
                    this._doneCallbacks.push(fn);
                  }
                },
                progress: angular.noop,
                getPromise: function() {
                  if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                      self.done(function(status) {
                        status === false ? reject() : resolve();
                      });
                    });
                  }
                  return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                  return this.getPromise().then(resolveHandler, rejectHandler);
                },
                'catch': function(handler) {
                  return this.getPromise()['catch'](handler);
                },
                'finally': function(handler) {
                  return this.getPromise()['finally'](handler);
                },
                pause: function() {
                  if (this.host.pause) {
                    this.host.pause();
                  }
                },
                resume: function() {
                  if (this.host.resume) {
                    this.host.resume();
                  }
                },
                end: function() {
                  if (this.host.end) {
                    this.host.end();
                  }
                  this._resolve(true);
                },
                cancel: function() {
                  if (this.host.cancel) {
                    this.host.cancel();
                  }
                  this._resolve(false);
                },
                complete: function(response) {
                  var self = this;
                  if (self._state === INITIAL_STATE) {
                    self._state = DONE_PENDING_STATE;
                    self._runInAnimationFrame(function() {
                      self._resolve(response);
                    });
                  }
                },
                _resolve: function(response) {
                  if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function(fn) {
                      fn(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                  }
                }
              };
              return AnimateRunner;
            }];
            angular.module('material.core.animate', []).factory('$$forceReflow', $$ForceReflowFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).factory('$$rAFMutex', $$rAFMutexFactory).factory('$animateCss', ['$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout) {
              function init(element, options) {
                var temporaryStyles = [];
                var node = getDomNode(element);
                if (options.transitionStyle) {
                  temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);
                }
                if (options.keyframeStyle) {
                  temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);
                }
                if (options.delay) {
                  temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);
                }
                if (options.duration) {
                  temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);
                }
                var hasCompleteStyles = options.keyframeStyle || (options.to && (options.duration > 0 || options.transitionStyle));
                var hasCompleteClasses = !!options.addClass || !!options.removeClass;
                var hasCompleteAnimation = hasCompleteStyles || hasCompleteClasses;
                blockTransition(element, true);
                applyAnimationFromStyles(element, options);
                var animationClosed = false;
                var events,
                    eventFn;
                return {
                  close: $window.close,
                  start: function() {
                    var runner = new $$AnimateRunner();
                    waitUntilQuiet(function() {
                      blockTransition(element, false);
                      if (!hasCompleteAnimation) {
                        return close();
                      }
                      forEach(temporaryStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                      });
                      applyClasses(element, options);
                      var timings = computeTimings(element);
                      if (timings.duration === 0) {
                        return close();
                      }
                      var moreStyles = [];
                      if (options.easing) {
                        if (timings.transitionDuration) {
                          moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);
                        }
                        if (timings.animationDuration) {
                          moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);
                        }
                      }
                      if (options.delay && timings.animationDelay) {
                        moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);
                      }
                      if (options.duration && timings.animationDuration) {
                        moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);
                      }
                      forEach(moreStyles, function(entry) {
                        var key = entry[0];
                        var value = entry[1];
                        node.style[camelCase(key)] = value;
                        temporaryStyles.push(entry);
                      });
                      var maxDelay = timings.delay;
                      var maxDelayTime = maxDelay * 1000;
                      var maxDuration = timings.duration;
                      var maxDurationTime = maxDuration * 1000;
                      var startTime = Date.now();
                      events = [];
                      if (timings.transitionDuration) {
                        events.push(TRANSITION_EVENTS);
                      }
                      if (timings.animationDuration) {
                        events.push(ANIMATION_EVENTS);
                      }
                      events = events.join(' ');
                      eventFn = function(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event;
                        var timeStamp = ev.timeStamp || Date.now();
                        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                          close();
                        }
                      };
                      element.on(events, eventFn);
                      applyAnimationToStyles(element, options);
                      $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
                    });
                    return runner;
                    function close() {
                      if (animationClosed)
                        return;
                      animationClosed = true;
                      if (events && eventFn) {
                        element.off(events, eventFn);
                      }
                      applyClasses(element, options);
                      applyAnimationStyles(element, options);
                      forEach(temporaryStyles, function(entry) {
                        node.style[camelCase(entry[0])] = '';
                      });
                      runner.complete(true);
                      return runner;
                    }
                  }
                };
              }
              function applyClasses(element, options) {
                if (options.addClass) {
                  $$jqLite.addClass(element, options.addClass);
                  options.addClass = null;
                }
                if (options.removeClass) {
                  $$jqLite.removeClass(element, options.removeClass);
                  options.removeClass = null;
                }
              }
              function computeTimings(element) {
                var node = getDomNode(element);
                var cs = $window.getComputedStyle(node);
                var tdr = parseMaxTime(cs[prop('transitionDuration')]);
                var adr = parseMaxTime(cs[prop('animationDuration')]);
                var tdy = parseMaxTime(cs[prop('transitionDelay')]);
                var ady = parseMaxTime(cs[prop('animationDelay')]);
                adr *= (parseInt(cs[prop('animationIterationCount')], 10) || 1);
                var duration = Math.max(adr, tdr);
                var delay = Math.max(ady, tdy);
                return {
                  duration: duration,
                  delay: delay,
                  animationDuration: adr,
                  transitionDuration: tdr,
                  animationDelay: ady,
                  transitionDelay: tdy
                };
                function prop(key) {
                  return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1) : key;
                }
              }
              function parseMaxTime(str) {
                var maxValue = 0;
                var values = (str || "").split(/\s*,\s*/);
                forEach(values, function(value) {
                  if (value.charAt(value.length - 1) == 's') {
                    value = value.substring(0, value.length - 1);
                  }
                  value = parseFloat(value) || 0;
                  maxValue = maxValue ? Math.max(value, maxValue) : value;
                });
                return maxValue;
              }
              var cancelLastRAFRequest;
              var rafWaitQueue = [];
              function waitUntilQuiet(callback) {
                if (cancelLastRAFRequest) {
                  cancelLastRAFRequest();
                }
                rafWaitQueue.push(callback);
                cancelLastRAFRequest = $$rAF(function() {
                  cancelLastRAFRequest = null;
                  var pageWidth = $$forceReflow();
                  for (var i = 0; i < rafWaitQueue.length; i++) {
                    rafWaitQueue[i](pageWidth);
                  }
                  rafWaitQueue.length = 0;
                });
              }
              function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options);
                applyAnimationToStyles(element, options);
              }
              function applyAnimationFromStyles(element, options) {
                if (options.from) {
                  element.css(options.from);
                  options.from = null;
                }
              }
              function applyAnimationToStyles(element, options) {
                if (options.to) {
                  element.css(options.to);
                  options.to = null;
                }
              }
              function getDomNode(element) {
                for (var i = 0; i < element.length; i++) {
                  if (element[i].nodeType === 1)
                    return element[i];
                }
              }
              function blockTransition(element, bool) {
                var node = getDomNode(element);
                var key = camelCase(PREFIX + 'transition-delay');
                node.style[key] = bool ? '-9999s' : '';
              }
              return init;
            }]);
            function camelCase(str) {
              return str.replace(/-[a-z]/g, function(str) {
                return str.charAt(1).toUpperCase();
              });
            }
          })();
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.backdrop', ['material.core']).directive('mdBackdrop', ["$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $animate, $rootElement, $window, $log, $$rAF, $document) {
          var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
          return {
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attrs) {
            var body = $window.getComputedStyle($document[0].body);
            if (body.position == 'fixed') {
              var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
              element.css({height: hViewport + 'px'});
            }
            if ($animate.pin)
              $animate.pin(element, $rootElement);
            $$rAF(function() {
              var parent = element.parent()[0];
              if (parent) {
                if (parent.nodeName == 'BODY') {
                  element.css({position: 'fixed'});
                }
                var styles = $window.getComputedStyle(parent);
                if (styles.position == 'static') {
                  $log.warn(ERROR_CSS_POSITION);
                }
              }
              $mdTheming.inherit(element, element.parent());
            });
          }
        }]);
      })();
      (function() {
        "use strict";
        angular.module('material.components.button', ['material.core']).directive('mdButton', MdButtonDirective);
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
          return {
            restrict: 'EA',
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
          };
          function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
          }
          function getTemplate(element, attr) {
            if (isAnchor(attr)) {
              return '<a class="md-button" ng-transclude></a>';
            } else {
              var btnType = (typeof attr.type === 'undefined') ? 'button' : attr.type;
              return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            $mdButtonInkRipple.attach(scope, element);
            $mdAria.expectWithText(element, 'aria-label');
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
              scope.$watch(attr.ngDisabled, function(isDisabled) {
                element.attr('tabindex', isDisabled ? -1 : 0);
              });
            }
            element.on('click', function(e) {
              if (attr.disabled === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });
            scope.mouseActive = false;
            element.on('mousedown', function() {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                element.addClass('md-focused');
              }
            }).on('blur', function(ev) {
              element.removeClass('md-focused');
            });
          }
        }
        MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.card', ['material.core']).directive('mdCard', mdCardDirective);
        function mdCardDirective($mdTheming) {
          return {
            restrict: 'E',
            link: function($scope, $element) {
              $mdTheming($element);
            }
          };
        }
        mdCardDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.checkbox', ['material.core']).directive('mdCheckbox', MdCheckboxDirective);
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
          inputDirective = inputDirective[0];
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            transclude: true,
            require: '?ngModel',
            priority: 210,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            tAttrs.type = 'checkbox';
            tAttrs.tabindex = tAttrs.tabindex || '0';
            tElement.attr('role', tAttrs.type);
            tElement.on('click', function(event) {
              if (this.hasAttribute('disabled')) {
                event.stopImmediatePropagation();
              }
            });
            return function postLink(scope, element, attr, ngModelCtrl) {
              ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
              $mdTheming(element);
              if (attr.ngChecked) {
                scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
              }
              $$watchExpr('ngDisabled', 'tabindex', {
                true: '-1',
                false: attr.tabindex
              });
              $mdAria.expectWithText(element, 'aria-label');
              inputDirective.link.pre(scope, {
                on: angular.noop,
                0: {}
              }, attr, [ngModelCtrl]);
              scope.mouseActive = false;
              element.on('click', listener).on('keypress', keypressHandler).on('mousedown', function() {
                scope.mouseActive = true;
                $timeout(function() {
                  scope.mouseActive = false;
                }, 100);
              }).on('focus', function() {
                if (scope.mouseActive === false) {
                  element.addClass('md-focused');
                }
              }).on('blur', function() {
                element.removeClass('md-focused');
              });
              ngModelCtrl.$render = render;
              function $$watchExpr(expr, htmlAttr, valueOpts) {
                if (attr[expr]) {
                  scope.$watch(attr[expr], function(val) {
                    if (valueOpts[val]) {
                      element.attr(htmlAttr, valueOpts[val]);
                    }
                  });
                }
              }
              function keypressHandler(ev) {
                var keyCode = ev.which || ev.keyCode;
                if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                  ev.preventDefault();
                  if (!element.hasClass('md-focused')) {
                    element.addClass('md-focused');
                  }
                  listener(ev);
                }
              }
              function listener(ev) {
                if (element[0].hasAttribute('disabled')) {
                  return;
                }
                scope.$apply(function() {
                  var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                  ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                  ngModelCtrl.$render();
                });
              }
              function render() {
                if (ngModelCtrl.$viewValue) {
                  element.addClass(CHECKED_CSS);
                } else {
                  element.removeClass(CHECKED_CSS);
                }
              }
            };
          }
        }
        MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.bottomSheet', ['material.core', 'material.components.backdrop']).directive('mdBottomSheet', MdBottomSheetDirective).provider('$mdBottomSheet', MdBottomSheetProvider);
        function MdBottomSheetDirective($mdBottomSheet) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdBottomSheet.destroy();
              });
            }
          };
        }
        MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
        function MdBottomSheetProvider($$interimElementProvider) {
          var CLOSING_VELOCITY = 0.5;
          var PADDING = 80;
          bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture"];
          return $$interimElementProvider('$mdBottomSheet').setDefaults({
            methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'],
            options: bottomSheetDefaults
          });
          function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {
            var backdrop;
            return {
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              escapeToClose: true,
              clickOutsideToClose: true,
              disableParentScroll: true
            };
            function onShow(scope, element, options, controller) {
              element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');
              backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
              if (options.clickOutsideToClose) {
                backdrop.on('click', function() {
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                });
              }
              $mdTheming.inherit(backdrop, options.parent);
              $animate.enter(backdrop, options.parent, null);
              var bottomSheet = new BottomSheet(element, options.parent);
              options.bottomSheet = bottomSheet;
              $mdTheming.inherit(bottomSheet.element, options.parent);
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent);
              }
              return $animate.enter(bottomSheet.element, options.parent).then(function() {
                var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector('button') || element[0].querySelector('a') || element[0].querySelector('[ng-click]'));
                focusable.focus();
                if (options.escapeToClose) {
                  options.rootElementKeyupCallback = function(e) {
                    if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                      $mdUtil.nextTick($mdBottomSheet.cancel, true);
                    }
                  };
                  $rootElement.on('keyup', options.rootElementKeyupCallback);
                }
              });
            }
            function onRemove(scope, element, options) {
              var bottomSheet = options.bottomSheet;
              $animate.leave(backdrop);
              return $animate.leave(bottomSheet.element).then(function() {
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                bottomSheet.cleanup();
              });
            }
            function BottomSheet(element, parent) {
              var deregister = $mdGesture.register(parent, 'drag', {horizontal: false});
              parent.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              return {
                element: element,
                cleanup: function cleanup() {
                  deregister();
                  parent.off('$md.dragstart', onDragStart);
                  parent.off('$md.drag', onDrag);
                  parent.off('$md.dragend', onDragEnd);
                }
              };
              function onDragStart(ev) {
                element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');
              }
              function onDrag(ev) {
                var transform = ev.pointer.distanceY;
                if (transform < 5) {
                  transform = Math.max(-PADDING, transform / 2);
                }
                element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');
              }
              function onDragEnd(ev) {
                if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                  var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;
                  var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);
                  element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');
                  $mdUtil.nextTick($mdBottomSheet.cancel, true);
                } else {
                  element.css($mdConstant.CSS.TRANSITION_DURATION, '');
                  element.css($mdConstant.CSS.TRANSFORM, '');
                }
              }
            }
          }
        }
        MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips', ['material.core', 'material.components.autocomplete']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.dialog', ['material.core', 'material.components.backdrop']).directive('mdDialog', MdDialogDirective).provider('$mdDialog', MdDialogProvider);
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
          return {
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              $$rAF(function() {
                var images;
                var content = element[0].querySelector('md-dialog-content');
                if (content) {
                  images = content.getElementsByTagName('img');
                  addOverflowClass();
                  angular.element(images).on('load', addOverflowClass);
                }
                scope.$on('$destroy', function() {
                  $mdDialog.destroy(element);
                });
                function addOverflowClass() {
                  element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);
                }
              });
            }
          };
        }
        MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
        function MdDialogProvider($$interimElementProvider) {
          var topFocusTrap,
              bottomFocusTrap;
          advancedDialogOptions.$inject = ["$mdDialog", "$mdTheming"];
          dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector"];
          return $$interimElementProvider('$mdDialog').setDefaults({
            methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen'],
            options: dialogDefaultOptions
          }).addPreset('alert', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme', 'css'],
            options: advancedDialogOptions
          }).addPreset('confirm', {
            methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel', 'theme', 'css'],
            options: advancedDialogOptions
          });
          function advancedDialogOptions($mdDialog, $mdTheming) {
            return {
              template: ['<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', '      <p>{{::dialog.mdTextContent}}</p>', '    </div>', '  </md-dialog-content>', '  <md-dialog-actions>', '    <md-button ng-if="dialog.$type == \'confirm\'"' + '               ng-click="dialog.abort()" class="md-primary">', '      {{ dialog.cancel }}', '    </md-button>', '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type!=\'confirm\'">', '      {{ dialog.ok }}', '    </md-button>', '  </md-dialog-actions>', '</md-dialog>'].join('').replace(/\s\s+/g, ''),
              controller: function mdDialogCtrl() {
                this.hide = function() {
                  $mdDialog.hide(true);
                };
                this.abort = function() {
                  $mdDialog.cancel();
                };
              },
              controllerAs: 'dialog',
              bindToController: true,
              theme: $mdTheming.defaultTheme()
            };
          }
          function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector) {
            return {
              hasBackdrop: true,
              isolateScope: true,
              onShow: onShow,
              onShowing: beforeShow,
              onRemove: onRemove,
              clickOutsideToClose: false,
              escapeToClose: true,
              targetEvent: null,
              closeTo: null,
              openFrom: null,
              focusOnOpen: true,
              disableParentScroll: true,
              autoWrap: true,
              fullscreen: false,
              transformTemplate: function(template, options) {
                return '<div class="md-dialog-container">' + validatedTemplate(template) + '</div>';
                function validatedTemplate(template) {
                  if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {
                    return '<md-dialog>' + (template || '') + '</md-dialog>';
                  } else {
                    return template || '';
                  }
                }
              }
            };
            function beforeShow(scope, element, options, controller) {
              if (controller) {
                controller.mdHtmlContent = controller.htmlContent || options.htmlContent || '';
                controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || '';
                if (controller.mdHtmlContent && !$injector.has('$sanitize')) {
                  throw Error('The ngSanitize module must be loaded in order to use htmlContent.');
                }
                if (controller.mdHtmlContent && controller.mdTextContent) {
                  throw Error('md-dialog cannot have both `htmlContent` and `textContent`');
                }
              }
            }
            function onShow(scope, element, options, controller) {
              angular.element($document[0].body).addClass('md-dialog-is-showing');
              captureParentAndFromToElements(options);
              configureAria(element.find('md-dialog'), options);
              showBackdrop(scope, element, options);
              return dialogPopIn(element, options).then(function() {
                activateListeners(element, options);
                lockScreenReader(element, options);
                warnDeprecatedActions();
                focusOnOpen();
              });
              function warnDeprecatedActions() {
                var badActions = element[0].querySelectorAll('.md-actions');
                if (badActions.length > 0) {
                  $log.warn('Using a class of md-actions is deprected, please use <md-dialog-actions>.');
                }
              }
              function focusOnOpen() {
                if (options.focusOnOpen) {
                  var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                  target.focus();
                }
                function findCloseButton() {
                  var closeButton = element[0].querySelector('.dialog-close');
                  if (!closeButton) {
                    var actionButtons = element[0].querySelectorAll('.md-actions button, md-dialog-actions button');
                    closeButton = actionButtons[actionButtons.length - 1];
                  }
                  return angular.element(closeButton);
                }
              }
            }
            function onRemove(scope, element, options) {
              options.deactivateListeners();
              options.unlockScreenReader();
              options.hideBackdrop(options.$destroy);
              if (topFocusTrap && topFocusTrap.parentNode) {
                topFocusTrap.parentNode.removeChild(topFocusTrap);
              }
              if (bottomFocusTrap && bottomFocusTrap.parentNode) {
                bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
              }
              return !!options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return dialogPopOut(element, options);
              }
              function detachAndClean() {
                angular.element($document[0].body).removeClass('md-dialog-is-showing');
                element.remove();
                if (!options.$destroy)
                  options.origin.focus();
              }
            }
            function captureParentAndFromToElements(options) {
              options.origin = angular.extend({
                element: null,
                bounds: null,
                focus: angular.noop
              }, options.origin || {});
              options.parent = getDomElement(options.parent, $rootElement);
              options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
              options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
              if (options.targetEvent) {
                options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
              }
              function getBoundingClientRect(element, orig) {
                var source = angular.element((element || {}));
                if (source && source.length) {
                  var bounds = {
                    top: 0,
                    left: 0,
                    height: 0,
                    width: 0
                  };
                  var hasFn = angular.isFunction(source[0].getBoundingClientRect);
                  return angular.extend(orig || {}, {
                    element: hasFn ? source : undefined,
                    bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                    focus: angular.bind(source, source.focus)
                  });
                }
              }
              function getDomElement(element, defaultElement) {
                if (angular.isString(element)) {
                  var simpleSelector = element,
                      container = $document[0].querySelectorAll(simpleSelector);
                  element = container.length ? container[0] : null;
                }
                return angular.element(element || defaultElement);
              }
            }
            function activateListeners(element, options) {
              var window = angular.element($window);
              var onWindowResize = $mdUtil.debounce(function() {
                stretchDialogContainerToViewport(element, options);
              }, 60);
              var removeListeners = [];
              var smartClose = function() {
                var closeFn = (options.$type == 'alert') ? $mdDialog.hide : $mdDialog.cancel;
                $mdUtil.nextTick(closeFn, true);
              };
              if (options.escapeToClose) {
                var parentTarget = options.parent;
                var keyHandlerFn = function(ev) {
                  if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                element.on('keydown', keyHandlerFn);
                parentTarget.on('keydown', keyHandlerFn);
                removeListeners.push(function() {
                  element.off('keydown', keyHandlerFn);
                  parentTarget.off('keydown', keyHandlerFn);
                });
              }
              window.on('resize', onWindowResize);
              removeListeners.push(function() {
                window.off('resize', onWindowResize);
              });
              if (options.clickOutsideToClose) {
                var target = element;
                var sourceElem;
                var mousedownHandler = function(ev) {
                  sourceElem = ev.target;
                };
                var mouseupHandler = function(ev) {
                  if (sourceElem === target[0] && ev.target === target[0]) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    smartClose();
                  }
                };
                target.on('mousedown', mousedownHandler);
                target.on('mouseup', mouseupHandler);
                removeListeners.push(function() {
                  target.off('mousedown', mousedownHandler);
                  target.off('mouseup', mouseupHandler);
                });
              }
              options.deactivateListeners = function() {
                removeListeners.forEach(function(removeFn) {
                  removeFn();
                });
                options.deactivateListeners = null;
              };
            }
            function showBackdrop(scope, element, options) {
              if (options.disableParentScroll) {
                options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
                $animate.enter(options.backdrop, options.parent);
              }
              options.hideBackdrop = function hideBackdrop($destroy) {
                if (options.backdrop) {
                  if (!!$destroy)
                    options.backdrop.remove();
                  else
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                  options.restoreScroll();
                  delete options.restoreScroll;
                }
                options.hideBackdrop = null;
              };
            }
            function configureAria(element, options) {
              var role = (options.$type === 'alert') ? 'alertdialog' : 'dialog';
              var dialogContent = element.find('md-dialog-content');
              var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());
              element.attr({
                'role': role,
                'tabIndex': '-1'
              });
              if (dialogContent.length === 0) {
                dialogContent = element;
              }
              dialogContent.attr('id', dialogId);
              element.attr('aria-describedby', dialogId);
              if (options.ariaLabel) {
                $mdAria.expect(element, 'aria-label', options.ariaLabel);
              } else {
                $mdAria.expectAsync(element, 'aria-label', function() {
                  var words = dialogContent.text().split(/\s+/);
                  if (words.length > 3)
                    words = words.slice(0, 3).concat('...');
                  return words.join(' ');
                });
              }
              topFocusTrap = document.createElement('div');
              topFocusTrap.classList.add('md-dialog-focus-trap');
              topFocusTrap.tabIndex = 0;
              bottomFocusTrap = topFocusTrap.cloneNode(false);
              var focusHandler = function() {
                element.focus();
              };
              topFocusTrap.addEventListener('focus', focusHandler);
              bottomFocusTrap.addEventListener('focus', focusHandler);
              element[0].parentNode.insertBefore(topFocusTrap, element[0]);
              element.append(bottomFocusTrap);
            }
            function lockScreenReader(element, options) {
              var isHidden = true;
              walkDOM(element[0]);
              options.unlockScreenReader = function() {
                isHidden = false;
                walkDOM(element[0]);
                options.unlockScreenReader = null;
              };
              function walkDOM(element) {
                while (element.parentNode) {
                  if (element === document.body) {
                    return;
                  }
                  var children = element.parentNode.children;
                  for (var i = 0; i < children.length; i++) {
                    if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {
                      children[i].setAttribute('aria-hidden', isHidden);
                    }
                  }
                  walkDOM(element = element.parentNode);
                }
              }
            }
            function stretchDialogContainerToViewport(container, options) {
              var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed';
              var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
              var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
              container.css({
                top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + 'px',
                height: height ? height + 'px' : '100%'
              });
              return container;
            }
            function dialogPopIn(container, options) {
              options.parent.append(container);
              stretchDialogContainerToViewport(container, options);
              var dialogEl = container.find('md-dialog');
              var animator = $mdUtil.dom.animator;
              var buildTranslateToOrigin = animator.calculateZoomToOrigin;
              var translateOptions = {
                transitionInClass: 'md-transition-in',
                transitionOutClass: 'md-transition-out'
              };
              var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
              var to = animator.toTransformCss("");
              if (options.fullscreen) {
                dialogEl.addClass('md-dialog-fullscreen');
              }
              return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                options.reverseAnimate = function() {
                  delete options.reverseAnimate;
                  if (options.closeTo) {
                    translateOptions = {
                      transitionInClass: 'md-transition-out',
                      transitionOutClass: 'md-transition-in'
                    };
                    from = to;
                    to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                    return animator.translate3d(dialogEl, from, to, translateOptions);
                  }
                  return animateReversal(animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                };
                return true;
              });
            }
            function dialogPopOut(container, options) {
              return options.reverseAnimate();
            }
            function isNodeOneOf(elem, nodeTypeArray) {
              if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
                return true;
              }
            }
          }
        }
        MdDialogProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.divider', ['material.core']).directive('mdDivider', MdDividerDirective);
        function MdDividerDirective($mdTheming) {
          return {
            restrict: 'E',
            link: $mdTheming
          };
        }
        MdDividerDirective.$inject = ["$mdTheming"];
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker', ['material.core', 'material.components.icon', 'material.components.virtualRepeat']).directive('mdCalendar', calendarDirective);
          var TBODY_HEIGHT = 265;
          var TBODY_SINGLE_ROW_HEIGHT = 45;
          function calendarDirective() {
            return {
              template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' + '<div class="md-calendar-scroll-mask">' + '<md-virtual-repeat-container class="md-calendar-scroll-container" ' + 'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' + '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' + '<tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month ' + 'md-month-offset="$index" class="md-calendar-month" ' + 'md-start-index="ctrl.getSelectedMonthIndex()" ' + 'md-item-size="' + TBODY_HEIGHT + '"></tbody>' + '</table>' + '</md-virtual-repeat-container>' + '</div>',
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                dateFilter: '=mdDateFilter'
              },
              require: ['ngModel', 'mdCalendar'],
              controller: CalendarCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var mdCalendarCtrl = controllers[1];
                mdCalendarCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          var nextUniqueId = 0;
          var firstRenderableDate = null;
          function CalendarCtrl($element, $attrs, $scope, $animate, $q, $mdConstant, $mdTheming, $$mdDateUtil, $mdDateLocale, $mdInkRipple, $mdUtil) {
            $mdTheming($element);
            this.items = {length: 2000};
            if (this.maxDate && this.minDate) {
              var numMonths = $$mdDateUtil.getMonthDistance(this.minDate, this.maxDate) + 1;
              numMonths = Math.max(numMonths, 1);
              numMonths += 1;
              this.items.length = numMonths;
            }
            this.$animate = $animate;
            this.$q = $q;
            this.$mdInkRipple = $mdInkRipple;
            this.$mdUtil = $mdUtil;
            this.keyCode = $mdConstant.KEY_CODE;
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.$scope = $scope;
            this.calendarElement = $element[0].querySelector('.md-calendar');
            this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');
            this.today = this.dateUtil.createDateAtMidnight();
            this.firstRenderableDate = this.dateUtil.incrementMonths(this.today, -this.items.length / 2);
            if (this.minDate && this.minDate > this.firstRenderableDate) {
              this.firstRenderableDate = this.minDate;
            } else if (this.maxDate) {
              var monthDifference = this.items.length - 2;
              this.firstRenderableDate = this.dateUtil.incrementMonths(this.maxDate, -(this.items.length - 2));
            }
            this.id = nextUniqueId++;
            this.ngModelCtrl = null;
            this.selectedDate = null;
            this.displayDate = null;
            this.focusDate = null;
            this.isInitialized = false;
            this.isMonthTransitionInProgress = false;
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            var self = this;
            this.cellClickHandler = function() {
              var cellElement = this;
              if (this.hasAttribute('data-timestamp')) {
                $scope.$apply(function() {
                  var timestamp = Number(cellElement.getAttribute('data-timestamp'));
                  self.setNgModelValue(self.dateUtil.createDateAtMidnight(timestamp));
                });
              }
            };
            this.attachCalendarEventListeners();
          }
          CalendarCtrl.$inject = ["$element", "$attrs", "$scope", "$animate", "$q", "$mdConstant", "$mdTheming", "$$mdDateUtil", "$mdDateLocale", "$mdInkRipple", "$mdUtil"];
          CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              self.changeSelectedDate(self.ngModelCtrl.$viewValue);
            };
          };
          CalendarCtrl.prototype.buildInitialCalendarDisplay = function() {
            this.buildWeekHeader();
            this.hideVerticalScrollbar();
            this.displayDate = this.selectedDate || this.today;
            this.isInitialized = true;
          };
          CalendarCtrl.prototype.hideVerticalScrollbar = function() {
            var element = this.$element[0];
            var scrollMask = element.querySelector('.md-calendar-scroll-mask');
            var scroller = this.calendarScroller;
            var headerWidth = element.querySelector('.md-calendar-day-header').clientWidth;
            var scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
            scrollMask.style.width = headerWidth + 'px';
            scroller.style.width = (headerWidth + scrollbarWidth) + 'px';
            scroller.style.paddingRight = scrollbarWidth + 'px';
          };
          CalendarCtrl.prototype.attachCalendarEventListeners = function() {
            this.$element.on('keydown', angular.bind(this, this.handleKeyEvent));
          };
          CalendarCtrl.prototype.handleKeyEvent = function(event) {
            var self = this;
            this.$scope.$apply(function() {
              if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {
                self.$scope.$emit('md-calendar-close');
                if (event.which == self.keyCode.TAB) {
                  event.preventDefault();
                }
                return;
              }
              if (event.which === self.keyCode.ENTER) {
                self.setNgModelValue(self.displayDate);
                event.preventDefault();
                return;
              }
              var date = self.getFocusDateFromKeyEvent(event);
              if (date) {
                date = self.boundDateByMinAndMax(date);
                event.preventDefault();
                event.stopPropagation();
                self.changeDisplayDate(date).then(function() {
                  self.focus(date);
                });
              }
            });
          };
          CalendarCtrl.prototype.getFocusDateFromKeyEvent = function(event) {
            var dateUtil = this.dateUtil;
            var keyCode = this.keyCode;
            switch (event.which) {
              case keyCode.RIGHT_ARROW:
                return dateUtil.incrementDays(this.displayDate, 1);
              case keyCode.LEFT_ARROW:
                return dateUtil.incrementDays(this.displayDate, -1);
              case keyCode.DOWN_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, 1) : dateUtil.incrementDays(this.displayDate, 7);
              case keyCode.UP_ARROW:
                return event.metaKey ? dateUtil.incrementMonths(this.displayDate, -1) : dateUtil.incrementDays(this.displayDate, -7);
              case keyCode.PAGE_DOWN:
                return dateUtil.incrementMonths(this.displayDate, 1);
              case keyCode.PAGE_UP:
                return dateUtil.incrementMonths(this.displayDate, -1);
              case keyCode.HOME:
                return dateUtil.getFirstDateOfMonth(this.displayDate);
              case keyCode.END:
                return dateUtil.getLastDateOfMonth(this.displayDate);
              default:
                return null;
            }
          };
          CalendarCtrl.prototype.getSelectedMonthIndex = function() {
            return this.dateUtil.getMonthDistance(this.firstRenderableDate, this.selectedDate || this.today);
          };
          CalendarCtrl.prototype.scrollToMonth = function(date) {
            if (!this.dateUtil.isValidDate(date)) {
              return;
            }
            var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
            this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
          };
          CalendarCtrl.prototype.setNgModelValue = function(date) {
            this.$scope.$emit('md-calendar-change', date);
            this.ngModelCtrl.$setViewValue(date);
            this.ngModelCtrl.$render();
          };
          CalendarCtrl.prototype.focus = function(opt_date) {
            var date = opt_date || this.selectedDate || this.today;
            var previousFocus = this.calendarElement.querySelector('.md-focus');
            if (previousFocus) {
              previousFocus.classList.remove(FOCUSED_DATE_CLASS);
            }
            var cellId = this.getDateId(date);
            var cell = document.getElementById(cellId);
            if (cell) {
              cell.classList.add(FOCUSED_DATE_CLASS);
              cell.focus();
            } else {
              this.focusDate = date;
            }
          };
          CalendarCtrl.prototype.boundDateByMinAndMax = function(date) {
            var boundDate = date;
            if (this.minDate && date < this.minDate) {
              boundDate = new Date(this.minDate.getTime());
            }
            if (this.maxDate && date > this.maxDate) {
              boundDate = new Date(this.maxDate.getTime());
            }
            return boundDate;
          };
          CalendarCtrl.prototype.changeSelectedDate = function(date) {
            var self = this;
            var previousSelectedDate = this.selectedDate;
            this.selectedDate = date;
            this.changeDisplayDate(date).then(function() {
              if (previousSelectedDate) {
                var prevDateCell = document.getElementById(self.getDateId(previousSelectedDate));
                if (prevDateCell) {
                  prevDateCell.classList.remove(SELECTED_DATE_CLASS);
                  prevDateCell.setAttribute('aria-selected', 'false');
                }
              }
              if (date) {
                var dateCell = document.getElementById(self.getDateId(date));
                if (dateCell) {
                  dateCell.classList.add(SELECTED_DATE_CLASS);
                  dateCell.setAttribute('aria-selected', 'true');
                }
              }
            });
          };
          CalendarCtrl.prototype.changeDisplayDate = function(date) {
            if (!this.isInitialized) {
              this.buildInitialCalendarDisplay();
              return this.$q.when();
            }
            if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {
              return this.$q.when();
            }
            this.isMonthTransitionInProgress = true;
            var animationPromise = this.animateDateChange(date);
            this.displayDate = date;
            var self = this;
            animationPromise.then(function() {
              self.isMonthTransitionInProgress = false;
            });
            return animationPromise;
          };
          CalendarCtrl.prototype.animateDateChange = function(date) {
            this.scrollToMonth(date);
            return this.$q.when();
          };
          CalendarCtrl.prototype.buildWeekHeader = function() {
            var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
            var shortDays = this.dateLocale.shortDays;
            var row = document.createElement('tr');
            for (var i = 0; i < 7; i++) {
              var th = document.createElement('th');
              th.textContent = shortDays[(i + firstDayOfWeek) % 7];
              row.appendChild(th);
            }
            this.$element.find('thead').append(row);
          };
          CalendarCtrl.prototype.getDateId = function(date) {
            return ['md', this.id, date.getFullYear(), date.getMonth(), date.getDate()].join('-');
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdCalendarMonth', mdCalendarMonthDirective);
          function mdCalendarMonthDirective() {
            return {
              require: ['^^mdCalendar', 'mdCalendarMonth'],
              scope: {offset: '=mdMonthOffset'},
              controller: CalendarMonthCtrl,
              controllerAs: 'mdMonthCtrl',
              bindToController: true,
              link: function(scope, element, attrs, controllers) {
                var calendarCtrl = controllers[0];
                var monthCtrl = controllers[1];
                monthCtrl.calendarCtrl = calendarCtrl;
                monthCtrl.generateContent();
                scope.$watch(function() {
                  return monthCtrl.offset;
                }, function(offset, oldOffset) {
                  if (offset != oldOffset) {
                    monthCtrl.generateContent();
                  }
                });
              }
            };
          }
          var TODAY_CLASS = 'md-calendar-date-today';
          var SELECTED_DATE_CLASS = 'md-calendar-selected-date';
          var FOCUSED_DATE_CLASS = 'md-focus';
          function CalendarMonthCtrl($element, $$mdDateUtil, $mdDateLocale) {
            this.dateUtil = $$mdDateUtil;
            this.dateLocale = $mdDateLocale;
            this.$element = $element;
            this.calendarCtrl = null;
            this.offset;
            this.focusAfterAppend = null;
          }
          CalendarMonthCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
          CalendarMonthCtrl.prototype.generateContent = function() {
            var calendarCtrl = this.calendarCtrl;
            var date = this.dateUtil.incrementMonths(calendarCtrl.firstRenderableDate, this.offset);
            this.$element.empty();
            this.$element.append(this.buildCalendarForMonth(date));
            if (this.focusAfterAppend) {
              this.focusAfterAppend.classList.add(FOCUSED_DATE_CLASS);
              this.focusAfterAppend.focus();
              this.focusAfterAppend = null;
            }
          };
          CalendarMonthCtrl.prototype.buildDateCell = function(opt_date) {
            var calendarCtrl = this.calendarCtrl;
            var cell = document.createElement('td');
            cell.tabIndex = -1;
            cell.classList.add('md-calendar-date');
            cell.setAttribute('role', 'gridcell');
            if (opt_date) {
              cell.setAttribute('tabindex', '-1');
              cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date));
              cell.id = calendarCtrl.getDateId(opt_date);
              cell.setAttribute('data-timestamp', opt_date.getTime());
              if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {
                cell.classList.add(TODAY_CLASS);
              }
              if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                cell.classList.add(SELECTED_DATE_CLASS);
                cell.setAttribute('aria-selected', 'true');
              }
              var cellText = this.dateLocale.dates[opt_date.getDate()];
              if (this.isDateEnabled(opt_date)) {
                var selectionIndicator = document.createElement('span');
                cell.appendChild(selectionIndicator);
                selectionIndicator.classList.add('md-calendar-date-selection-indicator');
                selectionIndicator.textContent = cellText;
                cell.addEventListener('click', calendarCtrl.cellClickHandler);
                if (calendarCtrl.focusDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.focusDate)) {
                  this.focusAfterAppend = cell;
                }
              } else {
                cell.classList.add('md-calendar-date-disabled');
                cell.textContent = cellText;
              }
            }
            return cell;
          };
          CalendarMonthCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
          };
          CalendarMonthCtrl.prototype.buildDateRow = function(rowNumber) {
            var row = document.createElement('tr');
            row.setAttribute('role', 'row');
            row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber));
            return row;
          };
          CalendarMonthCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
            var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date();
            var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
            var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
            var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);
            var monthBody = document.createDocumentFragment();
            var rowNumber = 1;
            var row = this.buildDateRow(rowNumber);
            monthBody.appendChild(row);
            var isFinalMonth = this.offset === this.calendarCtrl.items.length - 1;
            var blankCellOffset = 0;
            var monthLabelCell = document.createElement('td');
            monthLabelCell.classList.add('md-calendar-month-label');
            if (this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate) {
              monthLabelCell.classList.add('md-calendar-month-label-disabled');
            }
            monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
            if (firstDayOfTheWeek <= 2) {
              monthLabelCell.setAttribute('colspan', '7');
              var monthLabelRow = this.buildDateRow();
              monthLabelRow.appendChild(monthLabelCell);
              monthBody.insertBefore(monthLabelRow, row);
              if (isFinalMonth) {
                return monthBody;
              }
            } else {
              blankCellOffset = 2;
              monthLabelCell.setAttribute('colspan', '2');
              row.appendChild(monthLabelCell);
            }
            for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {
              row.appendChild(this.buildDateCell());
            }
            var dayOfWeek = firstDayOfTheWeek;
            var iterationDate = firstDayOfMonth;
            for (var d = 1; d <= numberOfDaysInMonth; d++) {
              if (dayOfWeek === 7) {
                if (isFinalMonth) {
                  return monthBody;
                }
                dayOfWeek = 0;
                rowNumber++;
                row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
              }
              iterationDate.setDate(d);
              var cell = this.buildDateCell(iterationDate);
              row.appendChild(cell);
              dayOfWeek++;
            }
            while (row.childNodes.length < 7) {
              row.appendChild(this.buildDateCell());
            }
            while (monthBody.childNodes.length < 6) {
              var whitespaceRow = this.buildDateRow();
              for (var i = 0; i < 7; i++) {
                whitespaceRow.appendChild(this.buildDateCell());
              }
              monthBody.appendChild(whitespaceRow);
            }
            return monthBody;
          };
          CalendarMonthCtrl.prototype.getLocaleDay_ = function(date) {
            return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').config(["$provide", function($provide) {
            function DateLocaleProvider() {
              this.months = null;
              this.shortMonths = null;
              this.days = null;
              this.shortDays = null;
              this.dates = null;
              this.firstDayOfWeek = 0;
              this.formatDate = null;
              this.parseDate = null;
              this.monthHeaderFormatter = null;
              this.weekNumberFormatter = null;
              this.longDateFormatter = null;
              this.msgCalendar = '';
              this.msgOpenCalendar = '';
            }
            DateLocaleProvider.prototype.$get = function($locale) {
              function defaultFormatDate(date) {
                if (!date) {
                  return '';
                }
                var localeTime = date.toLocaleTimeString();
                var formatDate = date;
                if (date.getHours() == 0 && (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {
                  formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);
                }
                return formatDate.toLocaleDateString();
              }
              function defaultParseDate(dateString) {
                return new Date(dateString);
              }
              function defaultIsDateComplete(dateString) {
                dateString = dateString.trim();
                var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                return re.test(dateString);
              }
              function defaultMonthHeaderFormatter(date) {
                return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();
              }
              function defaultWeekNumberFormatter(number) {
                return 'Week ' + number;
              }
              function defaultLongDateFormatter(date) {
                return [service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear()].join(' ');
              }
              var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                return day[0];
              });
              var defaultDates = Array(32);
              for (var i = 1; i <= 31; i++) {
                defaultDates[i] = i;
              }
              var defaultMsgCalendar = 'Calendar';
              var defaultMsgOpenCalendar = 'Open calendar';
              var service = {
                months: this.months || $locale.DATETIME_FORMATS.MONTH,
                shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                days: this.days || $locale.DATETIME_FORMATS.DAY,
                shortDays: this.shortDays || defaultShortDays,
                dates: this.dates || defaultDates,
                firstDayOfWeek: this.firstDayOfWeek || 0,
                formatDate: this.formatDate || defaultFormatDate,
                parseDate: this.parseDate || defaultParseDate,
                isDateComplete: this.isDateComplete || defaultIsDateComplete,
                monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                msgCalendar: this.msgCalendar || defaultMsgCalendar,
                msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
              };
              return service;
            };
            DateLocaleProvider.prototype.$get.$inject = ["$locale"];
            $provide.provider('$mdDateLocale', new DateLocaleProvider());
          }]);
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').directive('mdDatepicker', datePickerDirective);
          function datePickerDirective() {
            return {
              template: '<md-button class="md-datepicker-button md-icon-button" type="button" ' + 'tabindex="-1" aria-hidden="true" ' + 'ng-click="ctrl.openCalendarPane($event)">' + '<md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"></md-icon>' + '</md-button>' + '<div class="md-datepicker-input-container" ' + 'ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' + '<input class="md-datepicker-input" aria-haspopup="true" ' + 'ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)">' + '<md-button type="button" md-no-ink ' + 'class="md-datepicker-triangle-button md-icon-button" ' + 'ng-click="ctrl.openCalendarPane($event)" ' + 'aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}">' + '<div class="md-datepicker-expand-triangle"></div>' + '</md-button>' + '</div>' + '<div class="md-datepicker-calendar-pane md-whiteframe-z1">' + '<div class="md-datepicker-input-mask">' + '<div class="md-datepicker-input-mask-opaque"></div>' + '</div>' + '<div class="md-datepicker-calendar">' + '<md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" ' + 'md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"' + 'md-date-filter="ctrl.dateFilter"' + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' + '</md-calendar>' + '</div>' + '</div>',
              require: ['ngModel', 'mdDatepicker', '?^mdInputContainer'],
              scope: {
                minDate: '=mdMinDate',
                maxDate: '=mdMaxDate',
                placeholder: '@mdPlaceholder',
                dateFilter: '=mdDateFilter'
              },
              controller: DatePickerCtrl,
              controllerAs: 'ctrl',
              bindToController: true,
              link: function(scope, element, attr, controllers) {
                var ngModelCtrl = controllers[0];
                var mdDatePickerCtrl = controllers[1];
                var mdInputContainer = controllers[2];
                if (mdInputContainer) {
                  throw Error('md-datepicker should not be placed inside md-input-container.');
                }
                mdDatePickerCtrl.configureNgModel(ngModelCtrl);
              }
            };
          }
          var EXTRA_INPUT_SIZE = 3;
          var INVALID_CLASS = 'md-datepicker-invalid';
          var DEFAULT_DEBOUNCE_INTERVAL = 500;
          var CALENDAR_PANE_HEIGHT = 368;
          var CALENDAR_PANE_WIDTH = 360;
          function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
            this.$compile = $compile;
            this.$timeout = $timeout;
            this.$window = $window;
            this.dateLocale = $mdDateLocale;
            this.dateUtil = $$mdDateUtil;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$$rAF = $$rAF;
            this.documentElement = angular.element(document.documentElement);
            this.ngModelCtrl = null;
            this.inputElement = $element[0].querySelector('input');
            this.ngInputElement = angular.element(this.inputElement);
            this.inputContainer = $element[0].querySelector('.md-datepicker-input-container');
            this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane');
            this.calendarButton = $element[0].querySelector('.md-datepicker-button');
            this.inputMask = $element[0].querySelector('.md-datepicker-input-mask-opaque');
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
            this.date = null;
            this.isFocused = false;
            this.isDisabled;
            this.setDisabled($element[0].disabled || angular.isString($attrs['disabled']));
            this.isCalendarOpen = false;
            this.calendarPaneOpenedFrom = null;
            this.calendarPane.id = 'md-date-pane' + $mdUtil.nextUid();
            $mdTheming($element);
            this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
            this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
            if (!$attrs['tabindex']) {
              $element.attr('tabindex', '-1');
            }
            this.installPropertyInterceptors();
            this.attachChangeListeners();
            this.attachInteractionListeners();
            var self = this;
            $scope.$on('$destroy', function() {
              self.detachCalendarPane();
            });
          }
          DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF"];
          DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
              var value = self.ngModelCtrl.$viewValue;
              if (value && !(value instanceof Date)) {
                throw Error('The ng-model for md-datepicker must be a Date instance. ' + 'Currently the model is a: ' + (typeof value));
              }
              self.date = value;
              self.inputElement.value = self.dateLocale.formatDate(value);
              self.resizeInputElement();
              self.updateErrorState();
            };
          };
          DatePickerCtrl.prototype.attachChangeListeners = function() {
            var self = this;
            self.$scope.$on('md-calendar-change', function(event, date) {
              self.ngModelCtrl.$setViewValue(date);
              self.date = date;
              self.inputElement.value = self.dateLocale.formatDate(date);
              self.closeCalendarPane();
              self.resizeInputElement();
              self.updateErrorState();
            });
            self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement));
            self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
          };
          DatePickerCtrl.prototype.attachInteractionListeners = function() {
            var self = this;
            var $scope = this.$scope;
            var keyCodes = this.$mdConstant.KEY_CODE;
            self.ngInputElement.on('keydown', function(event) {
              if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                self.openCalendarPane(event);
                $scope.$digest();
              }
            });
            $scope.$on('md-calendar-close', function() {
              self.closeCalendarPane();
            });
          };
          DatePickerCtrl.prototype.installPropertyInterceptors = function() {
            var self = this;
            if (this.$attrs['ngDisabled']) {
              var scope = this.$scope.$parent;
              if (scope) {
                scope.$watch(this.$attrs['ngDisabled'], function(isDisabled) {
                  self.setDisabled(isDisabled);
                });
              }
            }
            Object.defineProperty(this, 'placeholder', {
              get: function() {
                return self.inputElement.placeholder;
              },
              set: function(value) {
                self.inputElement.placeholder = value || '';
              }
            });
          };
          DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
            this.isDisabled = isDisabled;
            this.inputElement.disabled = isDisabled;
            this.calendarButton.disabled = isDisabled;
          };
          DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
            var date = opt_date || this.date;
            this.clearErrorState();
            if (this.dateUtil.isValidDate(date)) {
              date = this.dateUtil.createDateAtMidnight(date);
              if (this.dateUtil.isValidDate(this.minDate)) {
                var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                this.ngModelCtrl.$setValidity('mindate', date >= minDate);
              }
              if (this.dateUtil.isValidDate(this.maxDate)) {
                var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                this.ngModelCtrl.$setValidity('maxdate', date <= maxDate);
              }
              if (angular.isFunction(this.dateFilter)) {
                this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));
              }
            } else {
              this.ngModelCtrl.$setValidity('valid', date == null);
            }
            if (!this.ngModelCtrl.$valid) {
              this.inputContainer.classList.add(INVALID_CLASS);
            }
          };
          DatePickerCtrl.prototype.clearErrorState = function() {
            this.inputContainer.classList.remove(INVALID_CLASS);
            ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function(field) {
              this.ngModelCtrl.$setValidity(field, true);
            }, this);
          };
          DatePickerCtrl.prototype.resizeInputElement = function() {
            this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
          };
          DatePickerCtrl.prototype.handleInputEvent = function() {
            var inputString = this.inputElement.value;
            var parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
            this.dateUtil.setDateTimeToMidnight(parsedDate);
            var isValidInput = inputString == '' || (this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate));
            if (isValidInput) {
              this.ngModelCtrl.$setViewValue(parsedDate);
              this.date = parsedDate;
            }
            this.updateErrorState(parsedDate);
          };
          DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
            return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
          };
          DatePickerCtrl.prototype.attachCalendarPane = function() {
            var calendarPane = this.calendarPane;
            calendarPane.style.transform = '';
            this.$element.addClass('md-datepicker-open');
            var elementRect = this.inputContainer.getBoundingClientRect();
            var bodyRect = document.body.getBoundingClientRect();
            var paneTop = elementRect.top - bodyRect.top;
            var paneLeft = elementRect.left - bodyRect.left;
            var viewportTop = (bodyRect.top < 0 && document.body.scrollTop == 0) ? -bodyRect.top : document.body.scrollTop;
            var viewportLeft = (bodyRect.left < 0 && document.body.scrollLeft == 0) ? -bodyRect.left : document.body.scrollLeft;
            var viewportBottom = viewportTop + this.$window.innerHeight;
            var viewportRight = viewportLeft + this.$window.innerWidth;
            if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
              if (viewportRight - CALENDAR_PANE_WIDTH > 0) {
                paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
              } else {
                paneLeft = viewportLeft;
                var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                calendarPane.style.transform = 'scale(' + scale + ')';
              }
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
              paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
              calendarPane.classList.add('md-datepicker-pos-adjusted');
            }
            calendarPane.style.left = paneLeft + 'px';
            calendarPane.style.top = paneTop + 'px';
            document.body.appendChild(calendarPane);
            this.inputMask.style.left = elementRect.width + 'px';
            this.$$rAF(function() {
              calendarPane.classList.add('md-pane-open');
            });
          };
          DatePickerCtrl.prototype.detachCalendarPane = function() {
            this.$element.removeClass('md-datepicker-open');
            this.calendarPane.classList.remove('md-pane-open');
            this.calendarPane.classList.remove('md-datepicker-pos-adjusted');
            if (this.calendarPane.parentNode) {
              this.calendarPane.parentNode.removeChild(this.calendarPane);
            }
          };
          DatePickerCtrl.prototype.openCalendarPane = function(event) {
            if (!this.isCalendarOpen && !this.isDisabled) {
              this.isCalendarOpen = true;
              this.calendarPaneOpenedFrom = event.target;
              this.$mdUtil.disableScrollAround(this.calendarPane);
              this.attachCalendarPane();
              this.focusCalendar();
              var self = this;
              this.$mdUtil.nextTick(function() {
                self.documentElement.on('click touchstart', self.bodyClickHandler);
              }, false);
              window.addEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.closeCalendarPane = function() {
            if (this.isCalendarOpen) {
              this.isCalendarOpen = false;
              this.detachCalendarPane();
              this.calendarPaneOpenedFrom.focus();
              this.calendarPaneOpenedFrom = null;
              this.$mdUtil.enableScrolling();
              this.ngModelCtrl.$setTouched();
              this.documentElement.off('click touchstart', this.bodyClickHandler);
              window.removeEventListener('resize', this.windowResizeHandler);
            }
          };
          DatePickerCtrl.prototype.getCalendarCtrl = function() {
            return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');
          };
          DatePickerCtrl.prototype.focusCalendar = function() {
            var self = this;
            this.$mdUtil.nextTick(function() {
              self.getCalendarCtrl().focus();
            }, false);
          };
          DatePickerCtrl.prototype.setFocused = function(isFocused) {
            if (!isFocused) {
              this.ngModelCtrl.$setTouched();
            }
            this.isFocused = isFocused;
          };
          DatePickerCtrl.prototype.handleBodyClick = function(event) {
            if (this.isCalendarOpen) {
              var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar');
              if (!isInCalendar) {
                this.closeCalendarPane();
              }
              this.$scope.$digest();
            }
          };
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.datepicker').factory('$$mdDateUtil', function() {
            return {
              getFirstDateOfMonth: getFirstDateOfMonth,
              getNumberOfDaysInMonth: getNumberOfDaysInMonth,
              getDateInNextMonth: getDateInNextMonth,
              getDateInPreviousMonth: getDateInPreviousMonth,
              isInNextMonth: isInNextMonth,
              isInPreviousMonth: isInPreviousMonth,
              getDateMidpoint: getDateMidpoint,
              isSameMonthAndYear: isSameMonthAndYear,
              getWeekOfMonth: getWeekOfMonth,
              incrementDays: incrementDays,
              incrementMonths: incrementMonths,
              getLastDateOfMonth: getLastDateOfMonth,
              isSameDay: isSameDay,
              getMonthDistance: getMonthDistance,
              isValidDate: isValidDate,
              setDateTimeToMidnight: setDateTimeToMidnight,
              createDateAtMidnight: createDateAtMidnight,
              isDateWithinRange: isDateWithinRange
            };
            function getFirstDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), 1);
            }
            function getNumberOfDaysInMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            }
            function getDateInNextMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 1);
            }
            function getDateInPreviousMonth(date) {
              return new Date(date.getFullYear(), date.getMonth() - 1, 1);
            }
            function isSameMonthAndYear(d1, d2) {
              return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
            }
            function isSameDay(d1, d2) {
              return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
            }
            function isInNextMonth(startDate, endDate) {
              var nextMonth = getDateInNextMonth(startDate);
              return isSameMonthAndYear(nextMonth, endDate);
            }
            function isInPreviousMonth(startDate, endDate) {
              var previousMonth = getDateInPreviousMonth(startDate);
              return isSameMonthAndYear(endDate, previousMonth);
            }
            function getDateMidpoint(d1, d2) {
              return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
            }
            function getWeekOfMonth(date) {
              var firstDayOfMonth = getFirstDateOfMonth(date);
              return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
            }
            function incrementDays(date, numberOfDays) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
            }
            function incrementMonths(date, numberOfMonths) {
              var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
              var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
              if (numberOfDaysInMonth < date.getDate()) {
                dateInTargetMonth.setDate(numberOfDaysInMonth);
              } else {
                dateInTargetMonth.setDate(date.getDate());
              }
              return dateInTargetMonth;
            }
            function getMonthDistance(start, end) {
              return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
            }
            function getLastDateOfMonth(date) {
              return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
            }
            function isValidDate(date) {
              return date != null && date.getTime && !isNaN(date.getTime());
            }
            function setDateTimeToMidnight(date) {
              if (isValidDate(date)) {
                date.setHours(0, 0, 0, 0);
              }
            }
            function createDateAtMidnight(opt_value) {
              var date;
              if (angular.isUndefined(opt_value)) {
                date = new Date();
              } else {
                date = new Date(opt_value);
              }
              setDateTimeToMidnight(date);
              return date;
            }
            function isDateWithinRange(date, minDate, maxDate) {
              var dateAtMidnight = createDateAtMidnight(date);
              var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null;
              var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
              return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
            }
          });
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.content', ['material.core']).directive('mdContent', mdContentDirective);
        function mdContentDirective($mdTheming) {
          return {
            restrict: 'E',
            controller: ['$scope', '$element', ContentController],
            link: function(scope, element, attr) {
              var node = element[0];
              $mdTheming(element);
              scope.$broadcast('$mdContentLoaded', element);
              iosScrollFix(element[0]);
            }
          };
          function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
          }
        }
        mdContentDirective.$inject = ["$mdTheming"];
        function iosScrollFix(node) {
          angular.element(node).on('$md.pressdown', function(ev) {
            if (ev.pointer.type !== 't')
              return;
            if (ev.$materialScrollFixed)
              return;
            ev.$materialScrollFixed = true;
            if (node.scrollTop === 0) {
              node.scrollTop = 1;
            } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
              node.scrollTop -= 1;
            }
          });
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabActions', ['material.core']).directive('mdFabActions', MdFabActionsDirective);
          function MdFabActionsDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],
              compile: function(element, attributes) {
                var children = element.children();
                var hasNgRepeat = false;
                angular.forEach(['', 'data-', 'x-'], function(prefix) {
                  hasNgRepeat = hasNgRepeat || (children.attr(prefix + 'ng-repeat') ? true : false);
                });
                if (hasNgRepeat) {
                  children.addClass('md-fab-action-item');
                } else {
                  children.wrap('<div class="md-fab-action-item">');
                }
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabShared', ['material.core']).controller('FabController', FabController);
          function FabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
            var vm = this;
            vm.open = function() {
              $scope.$evalAsync("vm.isOpen = true");
            };
            vm.close = function() {
              $scope.$evalAsync("vm.isOpen = false");
              $element.find('md-fab-trigger')[0].focus();
            };
            vm.toggle = function() {
              $scope.$evalAsync("vm.isOpen = !vm.isOpen");
            };
            setupDefaults();
            setupListeners();
            setupWatchers();
            var initialAnimationAttempts = 0;
            fireInitialAnimations();
            function setupDefaults() {
              vm.direction = vm.direction || 'down';
              vm.isOpen = vm.isOpen || false;
              resetActionIndex();
              $element.addClass('md-animations-waiting');
            }
            function setupListeners() {
              var eventTypes = ['click', 'focusin', 'focusout'];
              angular.forEach(eventTypes, function(eventType) {
                $element.on(eventType, parseEvents);
              });
              $scope.$on('$destroy', function() {
                angular.forEach(eventTypes, function(eventType) {
                  $element.off(eventType, parseEvents);
                });
                disableKeyboard();
              });
            }
            var closeTimeout;
            function parseEvents(event) {
              if (event.type == 'click') {
                handleItemClick(event);
              }
              if (event.type == 'focusout' && !closeTimeout) {
                closeTimeout = $timeout(function() {
                  vm.close();
                }, 100, false);
              }
              if (event.type == 'focusin' && closeTimeout) {
                $timeout.cancel(closeTimeout);
                closeTimeout = null;
              }
            }
            function resetActionIndex() {
              vm.currentActionIndex = -1;
            }
            function setupWatchers() {
              $scope.$watch('vm.direction', function(newDir, oldDir) {
                $animate.removeClass($element, 'md-' + oldDir);
                $animate.addClass($element, 'md-' + newDir);
                resetActionIndex();
              });
              var trigger,
                  actions;
              $scope.$watch('vm.isOpen', function(isOpen) {
                resetActionIndex();
                if (!trigger || !actions) {
                  trigger = getTriggerElement();
                  actions = getActionsElement();
                }
                if (isOpen) {
                  enableKeyboard();
                } else {
                  disableKeyboard();
                }
                var toAdd = isOpen ? 'md-is-open' : '';
                var toRemove = isOpen ? '' : 'md-is-open';
                trigger.attr('aria-haspopup', true);
                trigger.attr('aria-expanded', isOpen);
                actions.attr('aria-hidden', !isOpen);
                $animate.setClass($element, toAdd, toRemove);
              });
            }
            function fireInitialAnimations() {
              if ($element[0].scrollHeight > 0) {
                $animate.addClass($element, 'md-animations-ready').then(function() {
                  $element.removeClass('md-animations-waiting');
                });
              } else if (initialAnimationAttempts < 10) {
                $timeout(fireInitialAnimations, 100);
                initialAnimationAttempts = initialAnimationAttempts + 1;
              }
            }
            function enableKeyboard() {
              $element.on('keydown', keyPressed);
              $mdUtil.nextTick(function() {
                angular.element(document).on('click touchend', checkForOutsideClick);
              });
            }
            function disableKeyboard() {
              $element.off('keydown', keyPressed);
              angular.element(document).off('click touchend', checkForOutsideClick);
            }
            function checkForOutsideClick(event) {
              if (event.target) {
                var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger');
                var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions');
                if (!closestTrigger && !closestActions) {
                  vm.close();
                }
              }
            }
            function keyPressed(event) {
              switch (event.which) {
                case $mdConstant.KEY_CODE.ESCAPE:
                  vm.close();
                  event.preventDefault();
                  return false;
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                  doKeyLeft(event);
                  return false;
                case $mdConstant.KEY_CODE.UP_ARROW:
                  doKeyUp(event);
                  return false;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  doKeyRight(event);
                  return false;
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  doKeyDown(event);
                  return false;
              }
            }
            function doActionPrev(event) {
              focusAction(event, -1);
            }
            function doActionNext(event) {
              focusAction(event, 1);
            }
            function focusAction(event, direction) {
              var actions = resetActionTabIndexes();
              vm.currentActionIndex = vm.currentActionIndex + direction;
              vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
              vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
              var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
              angular.element(focusElement).attr('tabindex', 0);
              focusElement.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
            function resetActionTabIndexes() {
              var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item');
              angular.forEach(actions, function(action) {
                angular.element(angular.element(action).children()[0]).attr('tabindex', -1);
              });
              return actions;
            }
            function doKeyLeft(event) {
              if (vm.direction === 'left') {
                doActionNext(event);
              } else {
                doActionPrev(event);
              }
            }
            function doKeyUp(event) {
              if (vm.direction === 'down') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyRight(event) {
              if (vm.direction === 'left') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function doKeyDown(event) {
              if (vm.direction === 'up') {
                doActionPrev(event);
              } else {
                doActionNext(event);
              }
            }
            function isTrigger(element) {
              return $mdUtil.getClosest(element, 'md-fab-trigger');
            }
            function isAction(element) {
              return $mdUtil.getClosest(element, 'md-fab-actions');
            }
            function handleItemClick(event) {
              if (isTrigger(event.target)) {
                vm.toggle();
              }
              if (isAction(event.target)) {
                vm.close();
              }
            }
            function getTriggerElement() {
              return $element.find('md-fab-trigger');
            }
            function getActionsElement() {
              return $element.find('md-fab-actions');
            }
          }
          FabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          var cssAnimationDuration = 300;
          angular.module('material.components.fabSpeedDial', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabSpeedDial', MdFabSpeedDialDirective).animation('.md-fling', MdFabSpeedDialFlingAnimation).animation('.md-scale', MdFabSpeedDialScaleAnimation).service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation).service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation);
          function MdFabSpeedDialDirective() {
            return {
              restrict: 'E',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: FabSpeedDialLink
            };
            function FabSpeedDialLink(scope, element) {
              element.prepend('<div class="md-css-variables"></div>');
            }
          }
          function MdFabSpeedDialFlingAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            function runAnimation(element) {
              if (element.hasClass('md-animations-waiting') && !element.hasClass('md-animations-ready')) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var triggerElement = el.querySelector('md-fab-trigger');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style;
                styles.transform = styles.webkitTransform = '';
                styles.transitionDelay = '';
                styles.opacity = 1;
                styles.zIndex = (items.length - index) + startZIndex;
              });
              triggerElement.style.zIndex = startZIndex + items.length + 1;
              if (!ctrl.isOpen) {
                angular.forEach(items, function(item, index) {
                  var newPosition,
                      axis;
                  var styles = item.style;
                  var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
                  var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                  switch (ctrl.direction) {
                    case 'up':
                      newPosition = (item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'down':
                      newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                      axis = 'Y';
                      break;
                    case 'left':
                      newPosition = (item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                    case 'right':
                      newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                      axis = 'X';
                      break;
                  }
                  var newTranslate = 'translate' + axis + '(' + newPosition + 'px)';
                  styles.transform = styles.webkitTransform = newTranslate;
                });
              }
            }
            return {
              addClass: function(element, className, done) {
                if (element.hasClass('md-fling')) {
                  runAnimation(element);
                  delayDone(done);
                } else {
                  done();
                }
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
          function MdFabSpeedDialScaleAnimation($timeout) {
            function delayDone(done) {
              $timeout(done, cssAnimationDuration, false);
            }
            var delay = 65;
            function runAnimation(element) {
              var el = element[0];
              var ctrl = element.controller('mdFabSpeedDial');
              var items = el.querySelectorAll('.md-fab-action-item');
              var variablesElement = el.querySelector('.md-css-variables');
              var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
              angular.forEach(items, function(item, index) {
                var styles = item.style,
                    offsetDelay = index * delay;
                styles.opacity = ctrl.isOpen ? 1 : 0;
                styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';
                styles.transitionDelay = (ctrl.isOpen ? offsetDelay : (items.length - offsetDelay)) + 'ms';
                styles.zIndex = (items.length - index) + startZIndex;
              });
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              },
              removeClass: function(element, className, done) {
                runAnimation(element);
                delayDone(done);
              }
            };
          }
          MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
        })();
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabToolbar', ['material.core', 'material.components.fabShared', 'material.components.fabTrigger', 'material.components.fabActions']).directive('mdFabToolbar', MdFabToolbarDirective).animation('.md-fab-toolbar', MdFabToolbarAnimation).service('mdFabToolbarAnimation', MdFabToolbarAnimation);
          function MdFabToolbarDirective() {
            return {
              restrict: 'E',
              transclude: true,
              template: '<div class="md-fab-toolbar-wrapper">' + '  <div class="md-fab-toolbar-content" ng-transclude></div>' + '</div>',
              scope: {
                direction: '@?mdDirection',
                isOpen: '=?mdOpen'
              },
              bindToController: true,
              controller: 'FabController',
              controllerAs: 'vm',
              link: link
            };
            function link(scope, element, attributes) {
              element.addClass('md-fab-toolbar');
              element.find('md-fab-trigger').find('button').prepend('<div class="md-fab-toolbar-background"></div>');
            }
          }
          function MdFabToolbarAnimation() {
            function runAnimation(element, className, done) {
              if (!className) {
                return;
              }
              var el = element[0];
              var ctrl = element.controller('mdFabToolbar');
              var backgroundElement = el.querySelector('.md-fab-toolbar-background');
              var triggerElement = el.querySelector('md-fab-trigger button');
              var toolbarElement = el.querySelector('md-toolbar');
              var iconElement = el.querySelector('md-fab-trigger button md-icon');
              var actions = element.find('md-fab-actions').children();
              if (triggerElement && backgroundElement) {
                var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');
                var width = el.offsetWidth;
                var height = el.offsetHeight;
                var scale = 2 * (width / triggerElement.offsetWidth);
                backgroundElement.style.backgroundColor = color;
                backgroundElement.style.borderRadius = width + 'px';
                if (ctrl.isOpen) {
                  toolbarElement.style.pointerEvents = 'initial';
                  backgroundElement.style.width = triggerElement.offsetWidth + 'px';
                  backgroundElement.style.height = triggerElement.offsetHeight + 'px';
                  backgroundElement.style.transform = 'scale(' + scale + ')';
                  backgroundElement.style.transitionDelay = '0ms';
                  iconElement && (iconElement.style.transitionDelay = '.3s');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = (actions.length - index) * 25 + 'ms';
                  });
                } else {
                  toolbarElement.style.pointerEvents = 'none';
                  backgroundElement.style.transform = 'scale(1)';
                  backgroundElement.style.top = '0';
                  if (element.hasClass('md-right')) {
                    backgroundElement.style.left = '0';
                    backgroundElement.style.right = null;
                  }
                  if (element.hasClass('md-left')) {
                    backgroundElement.style.right = '0';
                    backgroundElement.style.left = null;
                  }
                  backgroundElement.style.transitionDelay = '200ms';
                  iconElement && (iconElement.style.transitionDelay = '0ms');
                  angular.forEach(actions, function(action, index) {
                    action.style.transitionDelay = 200 + (index * 25) + 'ms';
                  });
                }
              }
            }
            return {
              addClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              },
              removeClass: function(element, className, done) {
                runAnimation(element, className, done);
                done();
              }
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.gridList', ['material.core']).directive('mdGridList', GridListDirective).directive('mdGridTile', GridTileDirective).directive('mdGridTileFooter', GridTileCaptionDirective).directive('mdGridTileHeader', GridTileCaptionDirective).factory('$mdGridLayout', GridLayoutFactory);
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
          return {
            restrict: 'E',
            controller: GridListController,
            scope: {mdOnLayout: '&'},
            link: postLink
          };
          function postLink(scope, element, attrs, ctrl) {
            element.attr('role', 'list');
            ctrl.layoutDelegate = layoutDelegate;
            var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
                unwatchAttrs = watchMedia();
            scope.$on('$destroy', unwatchMedia);
            function watchMedia() {
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia(mediaName);
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
              }
              return $mdMedia.watchResponsiveAttributes(['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);
            }
            function unwatchMedia() {
              ctrl.layoutDelegate = angular.noop;
              unwatchAttrs();
              for (var mediaName in $mdConstant.MEDIA) {
                $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
              }
            }
            function layoutIfMediaMatch(mediaName) {
              if (mediaName == null) {
                ctrl.invalidateLayout();
              } else if ($mdMedia(mediaName)) {
                ctrl.invalidateLayout();
              }
            }
            var lastLayoutProps;
            function layoutDelegate(tilesInvalidated) {
              var tiles = getTileElements();
              var props = {
                tileSpans: getTileSpans(tiles),
                colCount: getColumnCount(),
                rowMode: getRowMode(),
                rowHeight: getRowHeight(),
                gutter: getGutter()
              };
              if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {
                return;
              }
              var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                return {
                  grid: {
                    element: element,
                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                  },
                  tiles: tilePositions.map(function(ps, i) {
                    return {
                      element: angular.element(tiles[i]),
                      style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                    };
                  })
                };
              }).reflow().performance();
              scope.mdOnLayout({$event: {performance: performance}});
              lastLayoutProps = props;
            }
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            function expr(exprStr) {
              return startSymbol + exprStr + endSymbol;
            }
            var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');
            var POSITION = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');
            var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');
            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
              var hShare = (1 / colCount) * 100;
              var hGutterShare = (colCount - 1) / colCount;
              var hUnit = UNIT({
                share: hShare,
                gutterShare: hGutterShare,
                gutter: gutter
              });
              var style = {
                left: POSITION({
                  unit: hUnit,
                  offset: position.col,
                  gutter: gutter
                }),
                width: DIMENSION({
                  unit: hUnit,
                  span: spans.col,
                  gutter: gutter
                }),
                paddingTop: '',
                marginTop: '',
                top: '',
                height: ''
              };
              switch (rowMode) {
                case 'fixed':
                  style.top = POSITION({
                    unit: rowHeight,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
                case 'ratio':
                  var vShare = hShare / rowHeight;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: hGutterShare,
                    gutter: gutter
                  });
                  style.paddingTop = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  style.marginTop = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  var vGutterShare = (rowCount - 1) / rowCount;
                  var vShare = (1 / rowCount) * 100;
                  var vUnit = UNIT({
                    share: vShare,
                    gutterShare: vGutterShare,
                    gutter: gutter
                  });
                  style.top = POSITION({
                    unit: vUnit,
                    offset: position.row,
                    gutter: gutter
                  });
                  style.height = DIMENSION({
                    unit: vUnit,
                    span: spans.row,
                    gutter: gutter
                  });
                  break;
              }
              return style;
            }
            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
              var style = {};
              switch (rowMode) {
                case 'fixed':
                  style.height = DIMENSION({
                    unit: rowHeight,
                    span: rowCount,
                    gutter: gutter
                  });
                  style.paddingBottom = '';
                  break;
                case 'ratio':
                  var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
                      hShare = (1 / colCount) * 100,
                      vShare = hShare * (1 / rowHeight),
                      vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                      });
                  style.height = '';
                  style.paddingBottom = DIMENSION({
                    unit: vUnit,
                    span: rowCount,
                    gutter: gutter
                  });
                  break;
                case 'fit':
                  break;
              }
              return style;
            }
            function getTileElements() {
              return [].filter.call(element.children(), function(ele) {
                return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;
              });
            }
            function getTileSpans(tileElements) {
              return [].map.call(tileElements, function(ele) {
                var ctrl = angular.element(ele).controller('mdGridTile');
                return {
                  row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,
                  col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1
                };
              });
            }
            function getColumnCount() {
              var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);
              if (isNaN(colCount)) {
                throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';
              }
              return colCount;
            }
            function getGutter() {
              return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);
            }
            function getRowHeight() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              switch (getRowMode()) {
                case 'fixed':
                  return applyDefaultUnit(rowHeight);
                case 'ratio':
                  var whRatio = rowHeight.split(':');
                  return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
                case 'fit':
                  return 0;
              }
            }
            function getRowMode() {
              var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
              if (rowHeight == 'fit') {
                return 'fit';
              } else if (rowHeight.indexOf(':') !== -1) {
                return 'ratio';
              } else {
                return 'fixed';
              }
            }
            function applyDefaultUnit(val) {
              return /\D$/.test(val) ? val : val + 'px';
            }
          }
        }
        GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
        function GridListController($mdUtil) {
          this.layoutInvalidated = false;
          this.tilesInvalidated = false;
          this.$timeout_ = $mdUtil.nextTick;
          this.layoutDelegate = angular.noop;
        }
        GridListController.$inject = ["$mdUtil"];
        GridListController.prototype = {
          invalidateTiles: function() {
            this.tilesInvalidated = true;
            this.invalidateLayout();
          },
          invalidateLayout: function() {
            if (this.layoutInvalidated) {
              return;
            }
            this.layoutInvalidated = true;
            this.$timeout_(angular.bind(this, this.layout));
          },
          layout: function() {
            try {
              this.layoutDelegate(this.tilesInvalidated);
            } finally {
              this.layoutInvalidated = false;
              this.tilesInvalidated = false;
            }
          }
        };
        function GridLayoutFactory($mdUtil) {
          var defaultAnimator = GridTileAnimator;
          GridLayout.animateWith = function(customAnimator) {
            defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
          };
          return GridLayout;
          function GridLayout(colCount, tileSpans) {
            var self,
                layoutInfo,
                gridStyles,
                layoutTime,
                mapTime,
                reflowTime;
            layoutTime = $mdUtil.time(function() {
              layoutInfo = calculateGridFor(colCount, tileSpans);
            });
            return self = {
              layoutInfo: function() {
                return layoutInfo;
              },
              map: function(updateFn) {
                mapTime = $mdUtil.time(function() {
                  var info = self.layoutInfo();
                  gridStyles = updateFn(info.positioning, info.rowCount);
                });
                return self;
              },
              reflow: function(animatorFn) {
                reflowTime = $mdUtil.time(function() {
                  var animator = animatorFn || defaultAnimator;
                  animator(gridStyles.grid, gridStyles.tiles);
                });
                return self;
              },
              performance: function() {
                return {
                  tileCount: tileSpans.length,
                  layoutTime: layoutTime,
                  mapTime: mapTime,
                  reflowTime: reflowTime,
                  totalTime: layoutTime + mapTime + reflowTime
                };
              }
            };
          }
          function GridTileAnimator(grid, tiles) {
            grid.element.css(grid.style);
            tiles.forEach(function(t) {
              t.element.css(t.style);
            });
          }
          function calculateGridFor(colCount, tileSpans) {
            var curCol = 0,
                curRow = 0,
                spaceTracker = newSpaceTracker();
            return {
              positioning: tileSpans.map(function(spans, i) {
                return {
                  spans: spans,
                  position: reserveSpace(spans, i)
                };
              }),
              rowCount: curRow + Math.max.apply(Math, spaceTracker)
            };
            function reserveSpace(spans, i) {
              if (spans.col > colCount) {
                throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' + '(' + spans.col + ') that exceeds the column count ' + '(' + colCount + ')';
              }
              var start = 0,
                  end = 0;
              while (end - start < spans.col) {
                if (curCol >= colCount) {
                  nextRow();
                  continue;
                }
                start = spaceTracker.indexOf(0, curCol);
                if (start === -1 || (end = findEnd(start + 1)) === -1) {
                  start = end = 0;
                  nextRow();
                  continue;
                }
                curCol = end + 1;
              }
              adjustRow(start, spans.col, spans.row);
              curCol = start + spans.col;
              return {
                col: start,
                row: curRow
              };
            }
            function nextRow() {
              curCol = 0;
              curRow++;
              adjustRow(0, colCount, -1);
            }
            function adjustRow(from, cols, by) {
              for (var i = from; i < from + cols; i++) {
                spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
              }
            }
            function findEnd(start) {
              var i;
              for (i = start; i < spaceTracker.length; i++) {
                if (spaceTracker[i] !== 0) {
                  return i;
                }
              }
              if (i === spaceTracker.length) {
                return i;
              }
            }
            function newSpaceTracker() {
              var tracker = [];
              for (var i = 0; i < colCount; i++) {
                tracker.push(0);
              }
              return tracker;
            }
          }
        }
        GridLayoutFactory.$inject = ["$mdUtil"];
        function GridTileDirective($mdMedia) {
          return {
            restrict: 'E',
            require: '^mdGridList',
            template: '<figure ng-transclude></figure>',
            transclude: true,
            scope: {},
            controller: ["$attrs", function($attrs) {
              this.$attrs = $attrs;
            }],
            link: postLink
          };
          function postLink(scope, element, attrs, gridCtrl) {
            element.attr('role', 'listitem');
            var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
            gridCtrl.invalidateTiles();
            scope.$on('$destroy', function() {
              element[0].$$mdDestroyed = true;
              unwatchAttrs();
              gridCtrl.invalidateLayout();
            });
            if (angular.isDefined(scope.$parent.$index)) {
              scope.$watch(function() {
                return scope.$parent.$index;
              }, function indexChanged(newIdx, oldIdx) {
                if (newIdx === oldIdx) {
                  return;
                }
                gridCtrl.invalidateTiles();
              });
            }
          }
        }
        GridTileDirective.$inject = ["$mdMedia"];
        function GridTileCaptionDirective() {
          return {
            template: '<figcaption ng-transclude></figcaption>',
            transclude: true
          };
        }
      })();
      (function() {
        "use strict";
        (function() {
          'use strict';
          angular.module('material.components.fabTrigger', ['material.core']).directive('mdFabTrigger', MdFabTriggerDirective);
          function MdFabTriggerDirective() {
            return {
              restrict: 'E',
              require: ['^?mdFabSpeedDial', '^?mdFabToolbar']
            };
          }
        })();
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon', ['material.core']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.input', ['material.core']).directive('mdInputContainer', mdInputContainerDirective).directive('label', labelDirective).directive('input', inputTextareaDirective).directive('textarea', inputTextareaDirective).directive('mdMaxlength', mdMaxlengthDirective).directive('placeholder', placeholderDirective).directive('ngMessages', ngMessagesDirective).directive('ngMessage', ngMessageDirective).directive('ngMessageExp', ngMessageDirective).directive('mdSelectOnFocus', mdSelectOnFocusDirective).animation('.md-input-invalid', mdInputInvalidMessagesAnimation).animation('.md-input-messages-animation', ngMessagesAnimation).animation('.md-input-message-animation', ngMessageAnimation);
        function mdInputContainerDirective($mdTheming, $parse) {
          ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
          return {
            restrict: 'E',
            link: postLink,
            controller: ContainerCtrl
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            if (element.find('md-icon').length)
              element.addClass('md-has-icon');
          }
          function ContainerCtrl($scope, $element, $attrs, $animate) {
            var self = this;
            self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
            self.delegateClick = function() {
              self.input.focus();
            };
            self.element = $element;
            self.setFocused = function(isFocused) {
              $element.toggleClass('md-input-focused', !!isFocused);
            };
            self.setHasValue = function(hasValue) {
              $element.toggleClass('md-input-has-value', !!hasValue);
            };
            self.setHasPlaceholder = function(hasPlaceholder) {
              $element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);
            };
            self.setInvalid = function(isInvalid) {
              if (isInvalid) {
                $animate.addClass($element, 'md-input-invalid');
              } else {
                $animate.removeClass($element, 'md-input-invalid');
              }
            };
            $scope.$watch(function() {
              return self.label && self.input;
            }, function(hasLabelAndInput) {
              if (hasLabelAndInput && !self.label.attr('for')) {
                self.label.attr('for', self.input.attr('id'));
              }
            });
          }
        }
        mdInputContainerDirective.$inject = ["$mdTheming", "$parse"];
        function labelDirective() {
          return {
            restrict: 'E',
            require: '^?mdInputContainer',
            link: function(scope, element, attr, containerCtrl) {
              if (!containerCtrl || attr.mdNoFloat || element.hasClass('md-container-ignore'))
                return;
              containerCtrl.label = element;
              scope.$on('$destroy', function() {
                containerCtrl.label = null;
              });
            }
          };
        }
        function inputTextareaDirective($mdUtil, $window, $mdAria) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', '?ngModel'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var hasNgModel = !!ctrls[1];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            var isReadonly = angular.isDefined(attr.readonly);
            if (!containerCtrl)
              return;
            if (containerCtrl.input) {
              throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
            }
            containerCtrl.input = element;
            var errorsSpacer = angular.element('<div class="md-errors-spacer">');
            element.after(errorsSpacer);
            if (!containerCtrl.label) {
              $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
            }
            element.addClass('md-input');
            if (!element.attr('id')) {
              element.attr('id', 'input_' + $mdUtil.nextUid());
            }
            if (element[0].tagName.toLowerCase() === 'textarea') {
              setupTextarea();
            }
            if (!hasNgModel) {
              inputCheckValue();
            }
            var isErrorGetter = containerCtrl.isErrorGetter || function() {
              return ngModelCtrl.$invalid && (ngModelCtrl.$touched || isParentFormSubmitted());
            };
            var isParentFormSubmitted = function() {
              var parent = $mdUtil.getClosest(element, 'form');
              var form = parent ? angular.element(parent).controller('form') : null;
              return form ? form.$submitted : false;
            };
            scope.$watch(isErrorGetter, containerCtrl.setInvalid);
            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
            ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
            element.on('input', inputCheckValue);
            if (!isReadonly) {
              element.on('focus', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(true);
                });
              }).on('blur', function(ev) {
                $mdUtil.nextTick(function() {
                  containerCtrl.setFocused(false);
                  inputCheckValue();
                });
              });
            }
            scope.$on('$destroy', function() {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            });
            function ngModelPipelineCheckValue(arg) {
              containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
              return arg;
            }
            function inputCheckValue() {
              containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
            }
            function setupTextarea() {
              if (angular.isDefined(element.attr('md-no-autogrow'))) {
                return;
              }
              var node = element[0];
              var container = containerCtrl.element[0];
              var min_rows = NaN;
              var lineHeight = null;
              if (node.hasAttribute('rows')) {
                min_rows = parseInt(node.getAttribute('rows'));
              }
              var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
              function pipelineListener(value) {
                onChangeTextarea();
                return value;
              }
              if (ngModelCtrl) {
                ngModelCtrl.$formatters.push(pipelineListener);
                ngModelCtrl.$viewChangeListeners.push(pipelineListener);
              } else {
                onChangeTextarea();
              }
              element.on('keydown input', onChangeTextarea);
              if (isNaN(min_rows)) {
                element.attr('rows', '1');
                element.on('scroll', onScroll);
              }
              angular.element($window).on('resize', onChangeTextarea);
              scope.$on('$destroy', function() {
                angular.element($window).off('resize', onChangeTextarea);
              });
              function growTextarea() {
                container.style.height = container.offsetHeight + 'px';
                element.addClass('md-no-flex');
                if (isNaN(min_rows)) {
                  node.style.height = "auto";
                  node.scrollTop = 0;
                  var height = getHeight();
                  if (height)
                    node.style.height = height + 'px';
                } else {
                  node.setAttribute("rows", 1);
                  if (!lineHeight) {
                    node.style.minHeight = '0';
                    lineHeight = element.prop('clientHeight');
                    node.style.minHeight = null;
                  }
                  var rows = Math.min(min_rows, Math.round(node.scrollHeight / lineHeight));
                  node.setAttribute("rows", rows);
                  node.style.height = lineHeight * rows + "px";
                }
                element.removeClass('md-no-flex');
                container.style.height = 'auto';
              }
              function getHeight() {
                var line = node.scrollHeight - node.offsetHeight;
                return node.offsetHeight + (line > 0 ? line : 0);
              }
              function onScroll(e) {
                node.scrollTop = 0;
                var line = node.scrollHeight - node.offsetHeight;
                var height = node.offsetHeight + line;
                node.style.height = height + 'px';
              }
              if (angular.isDefined(element.attr('md-detect-hidden'))) {
                var handleHiddenChange = function() {
                  var wasHidden = false;
                  return function() {
                    var isHidden = node.offsetHeight === 0;
                    if (isHidden === false && wasHidden === true) {
                      growTextarea();
                    }
                    wasHidden = isHidden;
                  };
                }();
                scope.$watch(function() {
                  $mdUtil.nextTick(handleHiddenChange, false);
                  return true;
                });
              }
            }
          }
        }
        inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria"];
        function mdMaxlengthDirective($animate, $mdUtil) {
          return {
            restrict: 'A',
            require: ['ngModel', '^mdInputContainer'],
            link: postLink
          };
          function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl,
                errorsSpacer;
            $mdUtil.nextTick(function() {
              errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer'));
              charCountEl = angular.element('<div class="md-char-counter">');
              errorsSpacer.append(charCountEl);
              attr.$set('ngTrim', 'false');
              ngModelCtrl.$formatters.push(renderCharCount);
              ngModelCtrl.$viewChangeListeners.push(renderCharCount);
              element.on('input keydown keyup', function() {
                renderCharCount();
              });
              scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                  if (!charCountEl.parent().length) {
                    $animate.enter(charCountEl, errorsSpacer);
                  }
                  renderCharCount();
                } else {
                  $animate.leave(charCountEl);
                }
              });
              ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                  return true;
                }
                return (modelValue || element.val() || viewValue || '').length <= maxlength;
              };
            });
            function renderCharCount(value) {
              if (!charCountEl.parent) {
                return value;
              }
              charCountEl.text(String(element.val() || value || '').length + '/' + maxlength);
              return value;
            }
          }
        }
        mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
        function placeholderDirective($log) {
          return {
            restrict: 'A',
            require: '^^?mdInputContainer',
            priority: 200,
            link: postLink
          };
          function postLink(scope, element, attr, inputContainer) {
            if (!inputContainer)
              return;
            var label = inputContainer.element.find('label');
            var hasNoFloat = angular.isDefined(inputContainer.element.attr('md-no-float'));
            if ((label && label.length) || hasNoFloat) {
              inputContainer.setHasPlaceholder(true);
              return;
            }
            var placeholderText = attr.placeholder;
            element.removeAttr('placeholder');
            if (inputContainer.input && inputContainer.input[0].nodeName != 'MD-SELECT') {
              var placeholder = '<label ng-click="delegateClick()">' + placeholderText + '</label>';
              inputContainer.element.addClass('md-icon-float');
              inputContainer.element.prepend(placeholder);
            }
          }
        }
        placeholderDirective.$inject = ["$log"];
        function mdSelectOnFocusDirective() {
          return {
            restrict: 'A',
            link: postLink
          };
          function postLink(scope, element, attr) {
            if (element[0].nodeName !== 'INPUT' && element[0].nodeName !== "TEXTAREA")
              return;
            element.on('focus', onFocus);
            scope.$on('$destroy', function() {
              element.off('focus', onFocus);
            });
            function onFocus() {
              element[0].select();
            }
          }
        }
        var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault'];
        function ngMessagesDirective() {
          return {
            restrict: 'EA',
            link: postLink,
            require: '^^?mdInputContainer'
          };
          function postLink(scope, element, attrs, inputContainer) {
            if (!inputContainer)
              return;
            element.toggleClass('md-input-messages-animation', true);
            element.toggleClass('md-auto-hide', true);
            if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {
              element.toggleClass('md-auto-hide', false);
            }
          }
          function hasVisibiltyDirective(attrs) {
            return visibilityDirectives.some(function(attr) {
              return attrs[attr];
            });
          }
        }
        function ngMessageDirective($mdUtil) {
          return {
            restrict: 'EA',
            compile: compile,
            priority: 100
          };
          function compile(element) {
            var inputContainer = $mdUtil.getClosest(element, "md-input-container");
            if (!inputContainer)
              return;
            element.toggleClass('md-input-message-animation', true);
            return {};
          }
        }
        ngMessageDirective.$inject = ["$mdUtil"];
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
          return {addClass: function(element, className, done) {
              var messages = getMessagesElement(element);
              if (className == "md-input-invalid" && messages.hasClass('md-auto-hide')) {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }};
        }
        mdInputInvalidMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessagesAnimation($q, $animateCss) {
          return {
            enter: function(element, done) {
              showInputMessages(element, $animateCss, $q).finally(done);
            },
            leave: function(element, done) {
              hideInputMessages(element, $animateCss, $q).finally(done);
            },
            addClass: function(element, className, done) {
              if (className == "ng-hide") {
                hideInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            },
            removeClass: function(element, className, done) {
              if (className == "ng-hide") {
                showInputMessages(element, $animateCss, $q).finally(done);
              } else {
                done();
              }
            }
          };
        }
        ngMessagesAnimation.$inject = ["$q", "$animateCss"];
        function ngMessageAnimation($animateCss) {
          return {
            enter: function(element, done) {
              var messages = getMessagesElement(element);
              if (messages.hasClass('md-auto-hide')) {
                done();
                return;
              }
              return showMessage(element, $animateCss);
            },
            leave: function(element, done) {
              return hideMessage(element, $animateCss);
            }
          };
        }
        ngMessageAnimation.$inject = ["$animateCss"];
        function showInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = showMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
          var animators = [],
              animator;
          var messages = getMessagesElement(element);
          angular.forEach(messages.children(), function(child) {
            animator = hideMessage(angular.element(child), $animateCss);
            animators.push(animator.start());
          });
          return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          return $animateCss(element, {
            event: 'enter',
            structural: true,
            from: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            to: {
              "opacity": 1,
              "margin-top": "0"
            },
            duration: 0.3
          });
        }
        function hideMessage(element, $animateCss) {
          var height = element[0].offsetHeight;
          var styles = window.getComputedStyle(element[0]);
          if (styles.opacity == 0) {
            return $animateCss(element, {});
          }
          return $animateCss(element, {
            event: 'leave',
            structural: true,
            from: {
              "opacity": 1,
              "margin-top": 0
            },
            to: {
              "opacity": 0,
              "margin-top": -height + "px"
            },
            duration: 0.3
          });
        }
        function getInputElement(element) {
          var inputContainer = element.controller('mdInputContainer');
          return inputContainer.element;
        }
        function getMessagesElement(element) {
          var input = getInputElement(element);
          var selector = 'ng-messages,data-ng-messages,x-ng-messages,' + '[ng-messages],[data-ng-messages],[x-ng-messages]';
          return angular.element(input[0].querySelector(selector));
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar', ['material.core', 'material.components.menu']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.list', ['material.core']).controller('MdListController', MdListController).directive('mdList', mdListDirective).directive('mdListItem', mdListItemDirective);
        function mdListDirective($mdTheming) {
          return {
            restrict: 'E',
            compile: function(tEl) {
              tEl[0].setAttribute('role', 'list');
              return $mdTheming;
            }
          };
        }
        mdListDirective.$inject = ["$mdTheming"];
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
          var proxiedTypes = ['md-checkbox', 'md-switch'];
          return {
            restrict: 'E',
            controller: 'MdListController',
            compile: function(tEl, tAttrs) {
              var secondaryItem = tEl[0].querySelector('.md-secondary');
              var hasProxiedElement;
              var proxyElement;
              tEl[0].setAttribute('role', 'listitem');
              if (tAttrs.ngClick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {
                wrapIn('button');
              } else {
                for (var i = 0,
                    type; type = proxiedTypes[i]; ++i) {
                  if (proxyElement = tEl[0].querySelector(type)) {
                    hasProxiedElement = true;
                    break;
                  }
                }
                if (hasProxiedElement) {
                  wrapIn('div');
                } else if (!tEl[0].querySelector('md-button:not(.md-secondary):not(.md-exclude)')) {
                  tEl.addClass('md-no-proxy');
                }
              }
              wrapSecondary();
              setupToggleAria();
              function setupToggleAria() {
                var toggleTypes = ['md-switch', 'md-checkbox'];
                var toggle;
                for (var i = 0,
                    toggleType; toggleType = toggleTypes[i]; ++i) {
                  if (toggle = tEl.find(toggleType)[0]) {
                    if (!toggle.hasAttribute('aria-label')) {
                      var p = tEl.find('p')[0];
                      if (!p)
                        return;
                      toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);
                    }
                  }
                }
              }
              function wrapIn(type) {
                var container;
                if (type == 'div') {
                  container = angular.element('<div class="md-no-style md-list-item-inner">');
                  container.append(tEl.contents());
                  tEl.addClass('md-proxy-focus');
                } else {
                  container = angular.element('<md-button class="md-no-style"><div class="md-list-item-inner"></div></md-button>');
                  copyAttributes(tEl[0], container[0]);
                  container.children().eq(0).append(tEl.contents());
                }
                tEl[0].setAttribute('tabindex', '-1');
                tEl.append(container);
              }
              function wrapSecondary() {
                if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {
                  $mdAria.expect(secondaryItem, 'aria-label');
                  var buttonWrapper = angular.element('<md-button class="md-secondary-container md-icon-button">');
                  copyAttributes(secondaryItem, buttonWrapper[0]);
                  secondaryItem.setAttribute('tabindex', '-1');
                  secondaryItem.classList.remove('md-secondary');
                  buttonWrapper.append(secondaryItem);
                  secondaryItem = buttonWrapper[0];
                }
                if (secondaryItem && (secondaryItem.hasAttribute('ng-click') || (tAttrs.ngClick && isProxiedElement(secondaryItem)))) {
                  tEl.addClass('md-with-secondary');
                  tEl.append(secondaryItem);
                }
              }
              function copyAttributes(item, wrapper) {
                var copiedAttrs = ['ng-if', 'ng-click', 'aria-label', 'ng-disabled', 'ui-sref', 'href', 'ng-href', 'ng-attr-ui-sref'];
                angular.forEach(copiedAttrs, function(attr) {
                  if (item.hasAttribute(attr)) {
                    wrapper.setAttribute(attr, item.getAttribute(attr));
                    item.removeAttribute(attr);
                  }
                });
              }
              function isProxiedElement(el) {
                return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
              }
              function isButton(el) {
                var nodeName = el.nodeName.toUpperCase();
                return nodeName == "MD-BUTTON" || nodeName == "BUTTON";
              }
              return postLink;
              function postLink($scope, $element, $attr, ctrl) {
                var proxies = [],
                    firstChild = $element[0].firstElementChild,
                    hasClick = firstChild && hasClickEvent(firstChild);
                computeProxies();
                computeClickable();
                if ($element.hasClass('md-proxy-focus') && proxies.length) {
                  angular.forEach(proxies, function(proxy) {
                    proxy = angular.element(proxy);
                    $scope.mouseActive = false;
                    proxy.on('mousedown', function() {
                      $scope.mouseActive = true;
                      $timeout(function() {
                        $scope.mouseActive = false;
                      }, 100);
                    }).on('focus', function() {
                      if ($scope.mouseActive === false) {
                        $element.addClass('md-focused');
                      }
                      proxy.on('blur', function proxyOnBlur() {
                        $element.removeClass('md-focused');
                        proxy.off('blur', proxyOnBlur);
                      });
                    });
                  });
                }
                function hasClickEvent(element) {
                  var attr = element.attributes;
                  for (var i = 0; i < attr.length; i++) {
                    if ($attr.$normalize(attr[i].name) === 'ngClick')
                      return true;
                  }
                  return false;
                }
                function computeProxies() {
                  var children = $element.children();
                  if (children.length && !children[0].hasAttribute('ng-click')) {
                    angular.forEach(proxiedTypes, function(type) {
                      angular.forEach(firstChild.querySelectorAll(type), function(child) {
                        proxies.push(child);
                      });
                    });
                  }
                }
                function computeClickable() {
                  if (proxies.length == 1 || hasClick) {
                    $element.addClass('md-clickable');
                    if (!hasClick) {
                      ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));
                    }
                  }
                }
                if (!hasClick && !proxies.length) {
                  firstChild && firstChild.addEventListener('keypress', function(e) {
                    if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA' && !e.target.isContentEditable) {
                      var keyCode = e.which || e.keyCode;
                      if (keyCode == $mdConstant.KEY_CODE.SPACE) {
                        if (firstChild) {
                          firstChild.click();
                          e.preventDefault();
                          e.stopPropagation();
                        }
                      }
                    }
                  });
                }
                $element.off('click');
                $element.off('keypress');
                if (proxies.length == 1 && firstChild) {
                  $element.children().eq(0).on('click', function(e) {
                    var parentButton = $mdUtil.getClosest(e.target, 'BUTTON');
                    if (!parentButton && firstChild.contains(e.target)) {
                      angular.forEach(proxies, function(proxy) {
                        if (e.target !== proxy && !proxy.contains(e.target)) {
                          angular.element(proxy).triggerHandler('click');
                        }
                      });
                    }
                  });
                }
              }
            }
          };
        }
        mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
        function MdListController($scope, $element, $mdListInkRipple) {
          var ctrl = this;
          ctrl.attachRipple = attachRipple;
          function attachRipple(scope, element) {
            var options = {};
            $mdListInkRipple.attach(scope, element, options);
          }
        }
        MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu', ['material.core', 'material.components.backdrop']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressCircular', ['material.core']).directive('mdProgressCircular', MdProgressCircularDirective);
        function MdProgressCircularDirective($mdTheming, $mdUtil, $log) {
          var DEFAULT_PROGRESS_SIZE = 100;
          var DEFAULT_SCALING = 0.5;
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate";
          return {
            restrict: 'E',
            scope: true,
            template: '<div class="md-scale-wrapper">' + '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + '</div>' + '<div class="md-right">' + '<div class="md-half-circle"></div>' + '</div>' + '</div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var circle = element;
            var spinnerWrapper = angular.element(element.children()[0]);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            element.attr('md-mode', mode());
            updateScale();
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() == MODE_DETERMINATE) {
                  animateIndicator(percentValue);
                }
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    spinnerWrapper.removeClass('ng-hide');
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      spinnerWrapper.removeClass(lastMode);
                    spinnerWrapper.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function updateScale() {
              circle.css({
                width: (100 * getDiameterRatio()) + 'px',
                height: (100 * getDiameterRatio()) + 'px'
              });
              circle.children().eq(0).css(toVendorCSS({transform: $mdUtil.supplant('translate(-50%, -50%) scale( {0} )', [getDiameterRatio()])}));
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            var leftC,
                rightC,
                gap;
            function animateIndicator(value) {
              if (!mode())
                return;
              leftC = leftC || angular.element(element[0].querySelector('.md-left > .md-half-circle'));
              rightC = rightC || angular.element(element[0].querySelector('.md-right > .md-half-circle'));
              gap = gap || angular.element(element[0].querySelector('.md-gap'));
              var gapStyles = removeEmptyValues({
                borderBottomColor: (value <= 50) ? "transparent !important" : "",
                transition: (value <= 50) ? "" : "borderBottomColor 0.1s linear"
              }),
                  leftStyles = removeEmptyValues({
                    transition: (value <= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value <= 50 ? 135 : (((value - 50) / 50 * 180) + 135)])
                  }),
                  rightStyles = removeEmptyValues({
                    transition: (value >= 50) ? "transform 0.1s linear" : "",
                    transform: $mdUtil.supplant("rotate({0}deg)", [value >= 50 ? 45 : (value / 50 * 180 - 135)])
                  });
              leftC.css(toVendorCSS(leftStyles));
              rightC.css(toVendorCSS(rightStyles));
              gap.css(toVendorCSS(gapStyles));
            }
            function getDiameterRatio() {
              if (!attr.mdDiameter)
                return DEFAULT_SCALING;
              var match = /([0-9]*)%/.exec(attr.mdDiameter);
              var value = Math.max(0, (match && match[1] / 100) || parseFloat(attr.mdDiameter));
              return (value > 1) ? value / DEFAULT_PROGRESS_SIZE : value;
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
          function removeEmptyValues(target) {
            for (var key in target) {
              if (target.hasOwnProperty(key)) {
                if (target[key] == "")
                  delete target[key];
              }
            }
            return target;
          }
        }
        MdProgressCircularDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.progressLinear', ['material.core']).directive('mdProgressLinear', MdProgressLinearDirective);
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
          var MODE_DETERMINATE = "determinate",
              MODE_INDETERMINATE = "indeterminate",
              MODE_BUFFER = "buffer",
              MODE_QUERY = "query";
          return {
            restrict: 'E',
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs, transclude) {
            tElement.attr('aria-valuemin', 0);
            tElement.attr('aria-valuemax', 100);
            tElement.attr('role', 'progressbar');
            return postLink;
          }
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var lastMode,
                toVendorCSS = $mdUtil.dom.animator.toCss;
            var bar1 = angular.element(element[0].querySelector('.md-bar1')),
                bar2 = angular.element(element[0].querySelector('.md-bar2')),
                container = angular.element(element[0].querySelector('.md-container'));
            element.attr('md-mode', mode());
            validateMode();
            watchAttributes();
            function watchAttributes() {
              attr.$observe('value', function(value) {
                var percentValue = clamp(value);
                element.attr('aria-valuenow', percentValue);
                if (mode() != MODE_QUERY)
                  animateIndicator(bar2, percentValue);
              });
              attr.$observe('mdBufferValue', function(value) {
                animateIndicator(bar1, clamp(value));
              });
              attr.$observe('mdMode', function(mode) {
                switch (mode) {
                  case MODE_QUERY:
                  case MODE_BUFFER:
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                    container.removeClass('ng-hide' + ' ' + lastMode);
                    container.addClass(lastMode = "md-mode-" + mode);
                    break;
                  default:
                    if (lastMode)
                      container.removeClass(lastMode);
                    container.addClass('ng-hide');
                    lastMode = undefined;
                    break;
                }
              });
            }
            function validateMode() {
              if (angular.isUndefined(attr.mdMode)) {
                var hasValue = angular.isDefined(attr.value);
                var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
                var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                $log.debug($mdUtil.supplant(info, [mode]));
                element.attr("md-mode", mode);
                attr['mdMode'] = mode;
              }
            }
            function mode() {
              var value = (attr.mdMode || "").trim();
              if (value) {
                switch (value) {
                  case MODE_DETERMINATE:
                  case MODE_INDETERMINATE:
                  case MODE_BUFFER:
                  case MODE_QUERY:
                    break;
                  default:
                    value = undefined;
                    break;
                }
              }
              return value;
            }
            function animateIndicator(target, value) {
              if (!mode())
                return;
              var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value - 100) / 2, value / 100]);
              var styles = toVendorCSS({transform: to});
              angular.element(target).css(styles);
            }
          }
          function clamp(value) {
            return Math.max(0, Math.min(value || 0, 100));
          }
        }
        MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.radioButton', ['material.core']).directive('mdRadioGroup', mdRadioGroupDirective).directive('mdRadioButton', mdRadioButtonDirective);
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
          RadioGroupController.prototype = createRadioGroupControllerProto();
          return {
            restrict: 'E',
            controller: ['$element', RadioGroupController],
            require: ['mdRadioGroup', '?ngModel'],
            link: {pre: linkRadioGroup}
          };
          function linkRadioGroup(scope, element, attr, ctrls) {
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            rgCtrl.init(ngModelCtrl);
            scope.mouseActive = false;
            element.attr({
              'role': 'radiogroup',
              'tabIndex': element.attr('tabindex') || '0'
            }).on('keydown', keydownListener).on('mousedown', function(event) {
              scope.mouseActive = true;
              $timeout(function() {
                scope.mouseActive = false;
              }, 100);
            }).on('focus', function() {
              if (scope.mouseActive === false) {
                rgCtrl.$element.addClass('md-focused');
              }
            }).on('blur', function() {
              rgCtrl.$element.removeClass('md-focused');
            });
            function setFocus() {
              if (!element.hasClass('md-focused')) {
                element.addClass('md-focused');
              }
            }
            function keydownListener(ev) {
              var keyCode = ev.which || ev.keyCode;
              if (keyCode != $mdConstant.KEY_CODE.ENTER && ev.currentTarget != ev.target) {
                return;
              }
              switch (keyCode) {
                case $mdConstant.KEY_CODE.LEFT_ARROW:
                case $mdConstant.KEY_CODE.UP_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectPrevious();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.RIGHT_ARROW:
                case $mdConstant.KEY_CODE.DOWN_ARROW:
                  ev.preventDefault();
                  rgCtrl.selectNext();
                  setFocus();
                  break;
                case $mdConstant.KEY_CODE.ENTER:
                  var form = angular.element($mdUtil.getClosest(element[0], 'form'));
                  if (form.length > 0) {
                    form.triggerHandler('submit');
                  }
                  break;
              }
            }
          }
          function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
          }
          function createRadioGroupControllerProto() {
            return {
              init: function(ngModelCtrl) {
                this._ngModelCtrl = ngModelCtrl;
                this._ngModelCtrl.$render = angular.bind(this, this.render);
              },
              add: function(rbRender) {
                this._radioButtonRenderFns.push(rbRender);
              },
              remove: function(rbRender) {
                var index = this._radioButtonRenderFns.indexOf(rbRender);
                if (index !== -1) {
                  this._radioButtonRenderFns.splice(index, 1);
                }
              },
              render: function() {
                this._radioButtonRenderFns.forEach(function(rbRender) {
                  rbRender();
                });
              },
              setViewValue: function(value, eventType) {
                this._ngModelCtrl.$setViewValue(value, eventType);
                this.render();
              },
              getViewValue: function() {
                return this._ngModelCtrl.$viewValue;
              },
              selectNext: function() {
                return changeSelectedButton(this.$element, 1);
              },
              selectPrevious: function() {
                return changeSelectedButton(this.$element, -1);
              },
              setActiveDescendant: function(radioId) {
                this.$element.attr('aria-activedescendant', radioId);
              }
            };
          }
          function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);
            if (buttons.count()) {
              var validate = function(button) {
                return !angular.element(button).attr("disabled");
              };
              var selected = parent[0].querySelector('md-radio-button.md-checked');
              var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();
              angular.element(target).triggerHandler('click');
            }
          }
        }
        mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
          var CHECKED_CSS = 'md-checked';
          return {
            restrict: 'E',
            require: '^mdRadioGroup',
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            link: link
          };
          function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            initialize();
            function initialize(controller) {
              if (!rgCtrl) {
                throw 'RadioGroupController not found.';
              }
              rgCtrl.add(render);
              attr.$observe('value', render);
              element.on('click', listener).on('$destroy', function() {
                rgCtrl.remove(render);
              });
            }
            function listener(ev) {
              if (element[0].hasAttribute('disabled'))
                return;
              scope.$apply(function() {
                rgCtrl.setViewValue(attr.value, ev && ev.type);
              });
            }
            function render() {
              var checked = (rgCtrl.getViewValue() == attr.value);
              if (checked === lastChecked) {
                return;
              }
              lastChecked = checked;
              element.attr('aria-checked', checked);
              if (checked) {
                markParentAsChecked(true);
                element.addClass(CHECKED_CSS);
                rgCtrl.setActiveDescendant(element.attr('id'));
              } else {
                markParentAsChecked(false);
                element.removeClass(CHECKED_CSS);
              }
              function markParentAsChecked(addClass) {
                if (element.parent()[0].nodeName != "MD-RADIO-GROUP") {
                  element.parent()[!!addClass ? 'addClass' : 'removeClass'](CHECKED_CSS);
                }
              }
            }
            function configureAria(element, scope) {
              scope.ariaId = buildAriaID();
              element.attr({
                'id': scope.ariaId,
                'role': 'radio',
                'aria-checked': 'false'
              });
              $mdAria.expectWithText(element, 'aria-label');
              function buildAriaID() {
                return attr.id || ('radio' + "_" + $mdUtil.nextUid());
              }
            }
          }
        }
        mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        var SELECT_EDGE_MARGIN = 8;
        var selectNextId = 0;
        angular.module('material.components.select', ['material.core', 'material.components.backdrop']).directive('mdSelect', SelectDirective).directive('mdSelectMenu', SelectMenuDirective).directive('mdOption', OptionDirective).directive('mdOptgroup', OptgroupDirective).provider('$mdSelect', SelectProvider);
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
          return {
            restrict: 'E',
            require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'],
            compile: compile,
            controller: function() {}
          };
          function compile(element, attr) {
            var valueEl = angular.element('<md-select-value><span></span></md-select-value>');
            valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
            valueEl.addClass('md-select-value');
            if (!valueEl[0].hasAttribute('id')) {
              valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());
            }
            if (!element.find('md-content').length) {
              element.append(angular.element('<md-content>').append(element.contents()));
            }
            if (attr.mdOnOpen) {
              element.find('md-content').prepend(angular.element('<div>' + ' <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone"></md-progress-circular>' + '</div>'));
              element.find('md-option').attr('ng-show', '$$loadingAsyncDone');
            }
            if (attr.name) {
              var autofillClone = angular.element('<select class="md-visually-hidden">');
              autofillClone.attr({
                'name': '.' + attr.name,
                'ng-model': attr.ngModel,
                'aria-hidden': 'true',
                'tabindex': '-1'
              });
              var opts = element.find('md-option');
              angular.forEach(opts, function(el) {
                var newEl = angular.element('<option>' + el.innerHTML + '</option>');
                if (el.hasAttribute('ng-value'))
                  newEl.attr('ng-value', el.getAttribute('ng-value'));
                else if (el.hasAttribute('value'))
                  newEl.attr('value', el.getAttribute('value'));
                autofillClone.append(newEl);
              });
              element.parent().append(autofillClone);
            }
            var multiple = angular.isDefined(attr.multiple) ? 'multiple' : '';
            var selectTemplate = '' + '<div class="md-select-menu-container" aria-hidden="true">' + '<md-select-menu {0}>{1}</md-select-menu>' + '</div>';
            selectTemplate = $mdUtil.supplant(selectTemplate, [multiple, element.html()]);
            element.empty().append(valueEl);
            element.append(selectTemplate);
            attr.tabindex = attr.tabindex || '0';
            return function postLink(scope, element, attr, ctrls) {
              var untouched = true;
              var isDisabled,
                  ariaLabelBase;
              var containerCtrl = ctrls[0];
              var mdSelectCtrl = ctrls[1];
              var ngModelCtrl = ctrls[2];
              var formCtrl = ctrls[3];
              var valueEl = element.find('md-select-value');
              var isReadonly = angular.isDefined(attr.readonly);
              if (containerCtrl) {
                var isErrorGetter = containerCtrl.isErrorGetter || function() {
                  return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                };
                if (containerCtrl.input) {
                  throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                }
                containerCtrl.input = element;
                if (!containerCtrl.label) {
                  $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
                }
                scope.$watch(isErrorGetter, containerCtrl.setInvalid);
              }
              var selectContainer,
                  selectScope,
                  selectMenuCtrl;
              findSelectContainer();
              $mdTheming(element);
              if (attr.name && formCtrl) {
                var selectEl = element.parent()[0].querySelector('select[name=".' + attr.name + '"]');
                $mdUtil.nextTick(function() {
                  var controller = angular.element(selectEl).controller('ngModel');
                  if (controller) {
                    formCtrl.$removeControl(controller);
                  }
                });
              }
              if (formCtrl && angular.isDefined(attr.multiple)) {
                $mdUtil.nextTick(function() {
                  var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
                  if (hasModelValue) {
                    formCtrl.$setPristine();
                  }
                });
              }
              var originalRender = ngModelCtrl.$render;
              ngModelCtrl.$render = function() {
                originalRender();
                syncLabelText();
                syncAriaLabel();
                inputCheckValue();
              };
              attr.$observe('placeholder', ngModelCtrl.$render);
              mdSelectCtrl.setLabelText = function(text) {
                mdSelectCtrl.setIsPlaceholder(!text);
                var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : '');
                text = text || tmpPlaceholder || '';
                var target = valueEl.children().eq(0);
                target.html(text);
              };
              mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                if (isPlaceholder) {
                  valueEl.addClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.addClass('md-placeholder');
                  }
                } else {
                  valueEl.removeClass('md-select-placeholder');
                  if (containerCtrl && containerCtrl.label) {
                    containerCtrl.label.removeClass('md-placeholder');
                  }
                }
              };
              if (!isReadonly) {
                element.on('focus', function(ev) {
                  if (containerCtrl && containerCtrl.element.hasClass('md-input-has-value')) {
                    containerCtrl.setFocused(true);
                  }
                });
                $mdUtil.nextTick(function() {
                  element.on('blur', function() {
                    if (untouched) {
                      untouched = false;
                      ngModelCtrl.$setUntouched();
                    }
                    if (selectScope.isOpen)
                      return;
                    containerCtrl && containerCtrl.setFocused(false);
                    inputCheckValue();
                  });
                });
              }
              mdSelectCtrl.triggerClose = function() {
                $parse(attr.mdOnClose)(scope);
              };
              scope.$$postDigest(function() {
                initAriaLabel();
                syncLabelText();
                syncAriaLabel();
              });
              function initAriaLabel() {
                var labelText = element.attr('aria-label') || element.attr('placeholder');
                if (!labelText && containerCtrl && containerCtrl.label) {
                  labelText = containerCtrl.label.text();
                }
                ariaLabelBase = labelText;
                $mdAria.expect(element, 'aria-label', labelText);
              }
              scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);
              function syncLabelText() {
                if (selectContainer) {
                  selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');
                  mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                }
              }
              function syncAriaLabel() {
                if (!ariaLabelBase)
                  return;
                var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria'});
                element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);
              }
              var deregisterWatcher;
              attr.$observe('ngMultiple', function(val) {
                if (deregisterWatcher)
                  deregisterWatcher();
                var parser = $parse(val);
                deregisterWatcher = scope.$watch(function() {
                  return parser(scope);
                }, function(multiple, prevVal) {
                  if (multiple === undefined && prevVal === undefined)
                    return;
                  if (multiple) {
                    element.attr('multiple', 'multiple');
                  } else {
                    element.removeAttr('multiple');
                  }
                  element.attr('aria-multiselectable', multiple ? 'true' : 'false');
                  if (selectContainer) {
                    selectMenuCtrl.setMultiple(multiple);
                    originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                      originalRender();
                      syncLabelText();
                      syncAriaLabel();
                      inputCheckValue();
                    };
                    ngModelCtrl.$render();
                  }
                });
              });
              attr.$observe('disabled', function(disabled) {
                if (angular.isString(disabled)) {
                  disabled = true;
                }
                if (isDisabled !== undefined && isDisabled === disabled) {
                  return;
                }
                isDisabled = disabled;
                if (disabled) {
                  element.attr({
                    'tabindex': -1,
                    'aria-disabled': 'true'
                  });
                  element.off('click', openSelect);
                  element.off('keydown', handleKeypress);
                } else {
                  element.attr({
                    'tabindex': attr.tabindex,
                    'aria-disabled': 'false'
                  });
                  element.on('click', openSelect);
                  element.on('keydown', handleKeypress);
                }
              });
              if (!attr.disabled && !attr.ngDisabled) {
                element.attr({
                  'tabindex': attr.tabindex,
                  'aria-disabled': 'false'
                });
                element.on('click', openSelect);
                element.on('keydown', handleKeypress);
              }
              var ariaAttrs = {
                role: 'listbox',
                'aria-expanded': 'false',
                'aria-multiselectable': attr.multiple !== undefined && !attr.ngMultiple ? 'true' : 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_' + $mdUtil.nextUid();
              }
              var containerId = 'select_container_' + $mdUtil.nextUid();
              selectContainer.attr('id', containerId);
              ariaAttrs['aria-owns'] = containerId;
              element.attr(ariaAttrs);
              scope.$on('$destroy', function() {
                $mdSelect.destroy().finally(function() {
                  if (containerCtrl) {
                    containerCtrl.setFocused(false);
                    containerCtrl.setHasValue(false);
                    containerCtrl.input = null;
                  }
                  ngModelCtrl.$setTouched();
                });
              });
              function inputCheckValue() {
                containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
              }
              function findSelectContainer() {
                selectContainer = angular.element(element[0].querySelector('.md-select-menu-container'));
                selectScope = scope;
                if (attr.mdContainerClass) {
                  var value = selectContainer[0].getAttribute('class') + ' ' + attr.mdContainerClass;
                  selectContainer[0].setAttribute('class', value);
                }
                selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');
                selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                element.on('$destroy', function() {
                  selectContainer.remove();
                });
              }
              function handleKeypress(e) {
                var allowedCodes = [32, 13, 38, 40];
                if (allowedCodes.indexOf(e.keyCode) != -1) {
                  e.preventDefault();
                  openSelect(e);
                } else {
                  if (e.keyCode <= 90 && e.keyCode >= 31) {
                    e.preventDefault();
                    var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                    if (!node)
                      return;
                    var optionCtrl = angular.element(node).controller('mdOption');
                    if (!selectMenuCtrl.isMultiple) {
                      selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                    }
                    selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                    selectMenuCtrl.refreshViewValue();
                  }
                }
              }
              function openSelect() {
                selectScope.isOpen = true;
                element.attr('aria-expanded', 'true');
                $mdSelect.show({
                  scope: selectScope,
                  preserveScope: true,
                  skipCompile: true,
                  element: selectContainer,
                  target: element[0],
                  selectCtrl: mdSelectCtrl,
                  preserveElement: true,
                  hasBackdrop: true,
                  loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
                }).finally(function() {
                  selectScope.isOpen = false;
                  element.focus();
                  element.attr('aria-expanded', 'false');
                  ngModelCtrl.$setTouched();
                });
              }
            };
          }
        }
        SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse"];
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
          SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
          return {
            restrict: 'E',
            require: ['mdSelectMenu'],
            scope: true,
            controller: SelectMenuController,
            link: {pre: preLink}
          };
          function preLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            $mdTheming(element);
            element.on('click', clickListener);
            element.on('keypress', keyListener);
            function keyListener(e) {
              if (e.keyCode == 13 || e.keyCode == 32) {
                clickListener(e);
              }
            }
            function clickListener(ev) {
              var option = $mdUtil.getClosest(ev.target, 'md-option');
              var optionCtrl = option && angular.element(option).data('$mdOptionController');
              if (!option || !optionCtrl)
                return;
              if (option.hasAttribute('disabled')) {
                ev.stopImmediatePropagation();
                return false;
              }
              var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
              var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
              scope.$apply(function() {
                if (selectCtrl.isMultiple) {
                  if (isSelected) {
                    selectCtrl.deselect(optionHashKey);
                  } else {
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                } else {
                  if (!isSelected) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                    selectCtrl.select(optionHashKey, optionCtrl.value);
                  }
                }
                selectCtrl.refreshViewValue();
              });
            }
          }
          function SelectMenuController($scope, $attrs, $element) {
            var self = this;
            self.isMultiple = angular.isDefined($attrs.multiple);
            self.selected = {};
            self.options = {};
            $scope.$watchCollection(function() {
              return self.options;
            }, function() {
              self.ngModel.$render();
            });
            var deregisterCollectionWatch;
            var defaultIsEmpty;
            self.setMultiple = function(isMultiple) {
              var ngModel = self.ngModel;
              defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
              self.isMultiple = isMultiple;
              if (deregisterCollectionWatch)
                deregisterCollectionWatch();
              if (self.isMultiple) {
                ngModel.$validators['md-multiple'] = validateArray;
                ngModel.$render = renderMultiple;
                $scope.$watchCollection(self.modelBinding, function(value) {
                  if (validateArray(value))
                    renderMultiple(value);
                  self.ngModel.$setPristine();
                });
                ngModel.$isEmpty = function(value) {
                  return !value || value.length === 0;
                };
              } else {
                delete ngModel.$validators['md-multiple'];
                ngModel.$render = renderSingular;
              }
              function validateArray(modelValue, viewValue) {
                return angular.isArray(modelValue || viewValue || []);
              }
            };
            var searchStr = '';
            var clearSearchTimeout,
                optNodes,
                optText;
            var CLEAR_SEARCH_AFTER = 300;
            self.optNodeForKeyboardSearch = function(e) {
              clearSearchTimeout && clearTimeout(clearSearchTimeout);
              clearSearchTimeout = setTimeout(function() {
                clearSearchTimeout = undefined;
                searchStr = '';
                optText = undefined;
                optNodes = undefined;
              }, CLEAR_SEARCH_AFTER);
              searchStr += String.fromCharCode(e.keyCode);
              var search = new RegExp('^' + searchStr, 'i');
              if (!optNodes) {
                optNodes = $element.find('md-option');
                optText = new Array(optNodes.length);
                angular.forEach(optNodes, function(el, i) {
                  optText[i] = el.textContent.trim();
                });
              }
              for (var i = 0; i < optText.length; ++i) {
                if (search.test(optText[i])) {
                  return optNodes[i];
                }
              }
            };
            self.init = function(ngModel, binding) {
              self.ngModel = ngModel;
              self.modelBinding = binding;
              if (ngModel.$options && ngModel.$options.trackBy) {
                var trackByLocals = {};
                var trackByParsed = $parse(ngModel.$options.trackBy);
                self.hashGetter = function(value, valueScope) {
                  trackByLocals.$value = value;
                  return trackByParsed(valueScope || $scope, trackByLocals);
                };
              } else {
                self.hashGetter = function getHashValue(value) {
                  if (angular.isObject(value)) {
                    return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
                  }
                  return value;
                };
              }
              self.setMultiple(self.isMultiple);
            };
            self.selectedLabels = function(opts) {
              opts = opts || {};
              var mode = opts.mode || 'html';
              var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));
              if (selectedOptionEls.length) {
                var mapFn;
                if (mode == 'html') {
                  mapFn = function(el) {
                    var html = el.innerHTML;
                    var rippleContainer = el.querySelector('.md-ripple-container');
                    return rippleContainer ? html.replace(rippleContainer.outerHTML, '') : html;
                  };
                } else if (mode == 'aria') {
                  mapFn = function(el) {
                    return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent;
                  };
                }
                return selectedOptionEls.map(mapFn).join(', ');
              } else {
                return '';
              }
            };
            self.select = function(hashKey, hashedValue) {
              var option = self.options[hashKey];
              option && option.setSelected(true);
              self.selected[hashKey] = hashedValue;
            };
            self.deselect = function(hashKey) {
              var option = self.options[hashKey];
              option && option.setSelected(false);
              delete self.selected[hashKey];
            };
            self.addOption = function(hashKey, optionCtrl) {
              if (angular.isDefined(self.options[hashKey])) {
                throw new Error('Duplicate md-option values are not allowed in a select. ' + 'Duplicate value "' + optionCtrl.value + '" found.');
              }
              self.options[hashKey] = optionCtrl;
              if (angular.isDefined(self.selected[hashKey])) {
                self.select(hashKey, optionCtrl.value);
                self.refreshViewValue();
              }
            };
            self.removeOption = function(hashKey) {
              delete self.options[hashKey];
            };
            self.refreshViewValue = function() {
              var values = [];
              var option;
              for (var hashKey in self.selected) {
                if ((option = self.options[hashKey])) {
                  values.push(option.value);
                } else {
                  values.push(self.selected[hashKey]);
                }
              }
              var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy;
              var newVal = self.isMultiple ? values : values[0];
              var prevVal = self.ngModel.$modelValue;
              if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                self.ngModel.$setViewValue(newVal);
                self.ngModel.$render();
              }
            };
            function renderMultiple() {
              var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
              if (!angular.isArray(newSelectedValues))
                return;
              var oldSelected = Object.keys(self.selected);
              var newSelectedHashes = newSelectedValues.map(self.hashGetter);
              var deselected = oldSelected.filter(function(hash) {
                return newSelectedHashes.indexOf(hash) === -1;
              });
              deselected.forEach(self.deselect);
              newSelectedHashes.forEach(function(hashKey, i) {
                self.select(hashKey, newSelectedValues[i]);
              });
            }
            function renderSingular() {
              var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
              Object.keys(self.selected).forEach(self.deselect);
              self.select(self.hashGetter(value), value);
            }
          }
        }
        SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdTheming"];
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
          OptionController.$inject = ["$element"];
          return {
            restrict: 'E',
            require: ['mdOption', '^^mdSelectMenu'],
            controller: OptionController,
            compile: compile
          };
          function compile(element, attr) {
            element.append(angular.element('<div class="md-text">').append(element.contents()));
            element.attr('tabindex', attr.tabindex || '0');
            return postLink;
          }
          function postLink(scope, element, attr, ctrls) {
            var optionCtrl = ctrls[0];
            var selectCtrl = ctrls[1];
            if (angular.isDefined(attr.ngValue)) {
              scope.$watch(attr.ngValue, setOptionValue);
            } else if (angular.isDefined(attr.value)) {
              setOptionValue(attr.value);
            } else {
              scope.$watch(function() {
                return element.text().trim();
              }, setOptionValue);
            }
            attr.$observe('disabled', function(disabled) {
              if (disabled) {
                element.attr('tabindex', '-1');
              } else {
                element.attr('tabindex', '0');
              }
            });
            scope.$$postDigest(function() {
              attr.$observe('selected', function(selected) {
                if (!angular.isDefined(selected))
                  return;
                if (typeof selected == 'string')
                  selected = true;
                if (selected) {
                  if (!selectCtrl.isMultiple) {
                    selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                  }
                  selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                } else {
                  selectCtrl.deselect(optionCtrl.hashKey);
                }
                selectCtrl.refreshViewValue();
              });
            });
            $mdButtonInkRipple.attach(scope, element);
            configureAria();
            function setOptionValue(newValue, oldValue, prevAttempt) {
              if (!selectCtrl.hashGetter) {
                if (!prevAttempt) {
                  scope.$$postDigest(function() {
                    setOptionValue(newValue, oldValue, true);
                  });
                }
                return;
              }
              var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
              var newHashKey = selectCtrl.hashGetter(newValue, scope);
              optionCtrl.hashKey = newHashKey;
              optionCtrl.value = newValue;
              selectCtrl.removeOption(oldHashKey, optionCtrl);
              selectCtrl.addOption(newHashKey, optionCtrl);
            }
            scope.$on('$destroy', function() {
              selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
            });
            function configureAria() {
              var ariaAttrs = {
                'role': 'option',
                'aria-selected': 'false'
              };
              if (!element[0].hasAttribute('id')) {
                ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();
              }
              element.attr(ariaAttrs);
            }
          }
          function OptionController($element) {
            this.selected = false;
            this.setSelected = function(isSelected) {
              if (isSelected && !this.selected) {
                $element.attr({
                  'selected': 'selected',
                  'aria-selected': 'true'
                });
              } else if (!isSelected && this.selected) {
                $element.removeAttr('selected');
                $element.attr('aria-selected', 'false');
              }
              this.selected = isSelected;
            };
          }
        }
        OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil"];
        function OptgroupDirective() {
          return {
            restrict: 'E',
            compile: compile
          };
          function compile(el, attrs) {
            var labelElement = el.find('label');
            if (!labelElement.length) {
              labelElement = angular.element('<label>');
              el.prepend(labelElement);
            }
            labelElement.addClass('md-container-ignore');
            if (attrs.label)
              labelElement.text(attrs.label);
          }
        }
        function SelectProvider($$interimElementProvider) {
          selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
          return $$interimElementProvider('$mdSelect').setDefaults({
            methods: ['target'],
            options: selectDefaultOptions
          });
          function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
            var ERRROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              themable: true,
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true
            };
            function onRemove(scope, element, opts) {
              opts = opts || {};
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? cleanElement() : animateRemoval().then(cleanElement);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function cleanElement() {
                element.removeClass('md-active');
                element.attr('aria-hidden', 'true');
                element[0].style.display = 'none';
                announceClosed(opts);
                if (!opts.$destroy && opts.restoreFocus) {
                  opts.target.focus();
                }
              }
            }
            function onShow(scope, element, opts) {
              watchAsyncLoad();
              sanitizeAndConfigure(scope, opts);
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showDropDown(scope, element, opts).then(function(response) {
                element.attr('aria-hidden', 'false');
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                opts.cleanupResizing = activateResizing();
                return response;
              }, opts.hideBackdrop);
              function showDropDown(scope, element, opts) {
                opts.parent.append(element);
                return $q(function(resolve, reject) {
                  try {
                    $animateCss(element, {
                      removeClass: 'md-leave',
                      duration: 0
                    }).start().then(positionAndFocusMenu).then(resolve);
                  } catch (e) {
                    reject(e);
                  }
                });
              }
              function positionAndFocusMenu() {
                return $q(function(resolve) {
                  if (opts.isRemoved)
                    return $q.reject(false);
                  var info = calculateMenuPositions(scope, element, opts);
                  info.container.element.css(animator.toCss(info.container.styles));
                  info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                  $$rAF(function() {
                    element.addClass('md-active');
                    info.dropDown.element.css(animator.toCss({transform: ''}));
                    autoFocus(opts.focusedNode);
                    resolve();
                  });
                });
              }
              function showBackdrop(scope, element, options) {
                if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                  options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
                } else {
                  options.disableParentScroll = false;
                }
                if (options.hasBackdrop) {
                  options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
                  $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
                }
                return function hideBackdrop() {
                  if (options.backdrop)
                    options.backdrop.remove();
                  if (options.disableParentScroll)
                    options.restoreScroll();
                  delete options.restoreScroll;
                };
              }
              function autoFocus(focusedNode) {
                if (focusedNode && !focusedNode.hasAttribute('disabled')) {
                  focusedNode.focus();
                }
              }
              function sanitizeAndConfigure(scope, options) {
                var selectEl = element.find('md-select-menu');
                if (!options.target) {
                  throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [options.target]));
                }
                angular.extend(options, {
                  isRemoved: false,
                  target: angular.element(options.target),
                  parent: angular.element(options.parent),
                  selectEl: selectEl,
                  contentEl: element.find('md-content'),
                  optionNodes: selectEl[0].getElementsByTagName('md-option')
                });
              }
              function activateResizing() {
                var debouncedOnResize = (function(scope, target, options) {
                  return function() {
                    if (options.isRemoved)
                      return;
                    var updates = calculateMenuPositions(scope, target, options);
                    var container = updates.container;
                    var dropDown = updates.dropDown;
                    container.element.css(animator.toCss(container.styles));
                    dropDown.element.css(animator.toCss(dropDown.styles));
                  };
                })(scope, element, opts);
                var window = angular.element($window);
                window.on('resize', debouncedOnResize);
                window.on('orientationchange', debouncedOnResize);
                return function deactivateResizing() {
                  window.off('resize', debouncedOnResize);
                  window.off('orientationchange', debouncedOnResize);
                };
              }
              function watchAsyncLoad() {
                if (opts.loadingAsync && !opts.isRemoved) {
                  scope.$$loadingAsyncDone = false;
                  scope.progressMode = 'indeterminate';
                  $q.when(opts.loadingAsync).then(function() {
                    scope.$$loadingAsyncDone = true;
                    scope.progressMode = '';
                    delete opts.loadingAsync;
                  }).then(function() {
                    $$rAF(positionAndFocusMenu);
                  });
                }
              }
              function activateInteraction() {
                if (opts.isRemoved)
                  return;
                var dropDown = opts.selectEl;
                var selectCtrl = dropDown.controller('mdSelectMenu') || {};
                element.addClass('md-clickable');
                opts.backdrop && opts.backdrop.on('click', onBackdropClick);
                dropDown.on('keydown', onMenuKeyDown);
                dropDown.on('click', checkCloseMenu);
                return function cleanupInteraction() {
                  opts.backdrop && opts.backdrop.off('click', onBackdropClick);
                  dropDown.off('keydown', onMenuKeyDown);
                  dropDown.off('click', checkCloseMenu);
                  element.removeClass('md-clickable');
                  opts.isRemoved = true;
                };
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  opts.restoreFocus = false;
                  $mdUtil.nextTick($mdSelect.hide, true);
                }
                function onMenuKeyDown(ev) {
                  var keyCodes = $mdConstant.KEY_CODE;
                  ev.preventDefault();
                  ev.stopPropagation();
                  switch (ev.keyCode) {
                    case keyCodes.UP_ARROW:
                      return focusPrevOption();
                    case keyCodes.DOWN_ARROW:
                      return focusNextOption();
                    case keyCodes.SPACE:
                    case keyCodes.ENTER:
                      var option = $mdUtil.getClosest(ev.target, 'md-option');
                      if (option) {
                        dropDown.triggerHandler({
                          type: 'click',
                          target: option
                        });
                        ev.preventDefault();
                      }
                      checkCloseMenu(ev);
                      break;
                    case keyCodes.TAB:
                    case keyCodes.ESCAPE:
                      ev.stopPropagation();
                      ev.preventDefault();
                      opts.restoreFocus = true;
                      $mdUtil.nextTick($mdSelect.hide, true);
                      break;
                    default:
                      if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                        var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);
                        opts.focusedNode = optNode || opts.focusedNode;
                        optNode && optNode.focus();
                      }
                  }
                }
                function focusOption(direction) {
                  var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
                  var index = optionsArray.indexOf(opts.focusedNode);
                  var newOption;
                  do {
                    if (index === -1) {
                      index = 0;
                    } else if (direction === 'next' && index < optionsArray.length - 1) {
                      index++;
                    } else if (direction === 'prev' && index > 0) {
                      index--;
                    }
                    newOption = optionsArray[index];
                    if (newOption.hasAttribute('disabled'))
                      newOption = undefined;
                  } while (!newOption && index < optionsArray.length - 1 && index > 0);
                  newOption && newOption.focus();
                  opts.focusedNode = newOption;
                }
                function focusNextOption() {
                  focusOption('next');
                }
                function focusPrevOption() {
                  focusOption('prev');
                }
                function checkCloseMenu(ev) {
                  if (ev && (ev.type == 'click') && (ev.currentTarget != dropDown[0]))
                    return;
                  if (mouseOnScrollbar())
                    return;
                  var option = $mdUtil.getClosest(ev.target, 'md-option');
                  if (option && option.hasAttribute && !option.hasAttribute('disabled')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (!selectCtrl.isMultiple) {
                      opts.restoreFocus = true;
                      $mdUtil.nextTick(function() {
                        $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                      }, true);
                    }
                  }
                  function mouseOnScrollbar() {
                    var clickOnScrollbar = false;
                    if (ev && (ev.currentTarget.children.length > 0)) {
                      var child = ev.currentTarget.children[0];
                      var hasScrollbar = child.scrollHeight > child.clientHeight;
                      if (hasScrollbar && child.children.length > 0) {
                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                        if (relPosX > child.querySelector('md-option').offsetWidth)
                          clickOnScrollbar = true;
                      }
                    }
                    return clickOnScrollbar;
                  }
                }
              }
            }
            function announceClosed(opts) {
              var mdSelect = opts.selectCtrl;
              if (mdSelect) {
                var menuController = opts.selectEl.controller('mdSelectMenu');
                mdSelect.setLabelText(menuController.selectedLabels());
                mdSelect.triggerClose();
              }
            }
            function calculateMenuPositions(scope, element, opts) {
              var containerNode = element[0],
                  targetNode = opts.target[0].children[0],
                  parentNode = $document[0].body,
                  selectNode = opts.selectEl[0],
                  contentNode = opts.contentEl[0],
                  parentRect = parentNode.getBoundingClientRect(),
                  targetRect = targetNode.getBoundingClientRect(),
                  shouldOpenAroundTarget = false,
                  bounds = {
                    left: parentRect.left + SELECT_EDGE_MARGIN,
                    top: SELECT_EDGE_MARGIN,
                    bottom: parentRect.height - SELECT_EDGE_MARGIN,
                    right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                  },
                  spaceAvailable = {
                    top: targetRect.top - bounds.top,
                    left: targetRect.left - bounds.left,
                    right: bounds.right - (targetRect.left + targetRect.width),
                    bottom: bounds.bottom - (targetRect.top + targetRect.height)
                  },
                  maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
                  selectedNode = selectNode.querySelector('md-option[selected]'),
                  optionNodes = selectNode.getElementsByTagName('md-option'),
                  optgroupNodes = selectNode.getElementsByTagName('md-optgroup'),
                  isScrollable = calculateScrollable(element, contentNode),
                  centeredNode;
              var loading = isPromiseLike(opts.loadingAsync);
              if (!loading) {
                if (selectedNode) {
                  centeredNode = selectedNode;
                } else if (optgroupNodes.length) {
                  centeredNode = optgroupNodes[0];
                } else if (optionNodes.length) {
                  centeredNode = optionNodes[0];
                } else {
                  centeredNode = contentNode.firstElementChild || contentNode;
                }
              } else {
                centeredNode = contentNode.firstElementChild || contentNode;
              }
              if (contentNode.offsetWidth > maxWidth) {
                contentNode.style['max-width'] = maxWidth + 'px';
              } else {
                contentNode.style.maxWidth = null;
              }
              if (shouldOpenAroundTarget) {
                contentNode.style['min-width'] = targetRect.width + 'px';
              }
              if (isScrollable) {
                selectNode.classList.add('md-overflow');
              }
              var focusedNode = centeredNode;
              if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {
                focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                centeredNode = focusedNode;
              }
              opts.focusedNode = focusedNode;
              containerNode.style.display = 'block';
              var selectMenuRect = selectNode.getBoundingClientRect();
              var centeredRect = getOffsetRect(centeredNode);
              if (centeredNode) {
                var centeredStyle = $window.getComputedStyle(centeredNode);
                centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
              }
              if (isScrollable) {
                var scrollBuffer = contentNode.offsetHeight / 2;
                contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                if (spaceAvailable.top < scrollBuffer) {
                  contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);
                } else if (spaceAvailable.bottom < scrollBuffer) {
                  contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom);
                }
              }
              var left,
                  top,
                  transformOrigin,
                  minWidth;
              if (shouldOpenAroundTarget) {
                left = targetRect.left;
                top = targetRect.top + targetRect.height;
                transformOrigin = '50% 0';
                if (top + selectMenuRect.height > bounds.bottom) {
                  top = targetRect.top - selectMenuRect.height;
                  transformOrigin = '50% 100%';
                }
              } else {
                left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
                top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';
                minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
              }
              var containerRect = containerNode.getBoundingClientRect();
              var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;
              return {
                container: {
                  element: angular.element(containerNode),
                  styles: {
                    left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                    top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                    'min-width': minWidth
                  }
                },
                dropDown: {
                  element: angular.element(selectNode),
                  styles: {
                    transformOrigin: transformOrigin,
                    transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : ""
                  }
                }
              };
            }
          }
          function isPromiseLike(obj) {
            return obj && angular.isFunction(obj.then);
          }
          function clamp(min, n, max) {
            return Math.max(min, Math.min(n, max));
          }
          function getOffsetRect(node) {
            return node ? {
              left: node.offsetLeft,
              top: node.offsetTop,
              width: node.offsetWidth,
              height: node.offsetHeight
            } : {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
          }
          function calculateScrollable(element, contentNode) {
            var isScrollable = false;
            try {
              var oldDisplay = element[0].style.display;
              element[0].style.display = 'block';
              isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
              element[0].style.display = oldDisplay;
            } finally {}
            return isScrollable;
          }
        }
        SelectProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.showHide', ['material.core']).directive('ngShow', createDirective('ngShow', true)).directive('ngHide', createDirective('ngHide', false));
        function createDirective(name, targetValue) {
          return ['$mdUtil', function($mdUtil) {
            return {
              restrict: 'A',
              multiElement: true,
              link: function($scope, $element, $attr) {
                var unregister = $scope.$on('$md-resize-enable', function() {
                  unregister();
                  $scope.$watch($attr[name], function(value) {
                    if (!!value === targetValue) {
                      $mdUtil.nextTick(function() {
                        $scope.$broadcast('$md-resize');
                      });
                      $mdUtil.dom.animator.waitTransitionEnd($element).then(function() {
                        $scope.$broadcast('$md-resize');
                      });
                    }
                  });
                });
              }
            };
          }];
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.sidenav', ['material.core', 'material.components.backdrop']).factory('$mdSidenav', SidenavService).directive('mdSidenav', SidenavDirective).directive('mdSidenavFocus', SidenavFocusDirective).controller('$mdSidenavController', SidenavController);
        function SidenavService($mdComponentRegistry, $q) {
          return function(handle) {
            var self;
            var errorMsg = "SideNav '" + handle + "' is not available!";
            var instance = $mdComponentRegistry.get(handle);
            if (!instance) {
              $mdComponentRegistry.notFoundError(handle);
            }
            return self = {
              isOpen: function() {
                return instance && instance.isOpen();
              },
              isLockedOpen: function() {
                return instance && instance.isLockedOpen();
              },
              toggle: function() {
                return instance ? instance.toggle() : $q.reject(errorMsg);
              },
              open: function() {
                return instance ? instance.open() : $q.reject(errorMsg);
              },
              close: function() {
                return instance ? instance.close() : $q.reject(errorMsg);
              },
              then: function(callbackFn) {
                var promise = instance ? $q.when(instance) : waitForInstance();
                return promise.then(callbackFn || angular.noop);
              }
            };
            function waitForInstance() {
              return $mdComponentRegistry.when(handle).then(function(it) {
                instance = it;
                return it;
              });
            }
          };
        }
        SidenavService.$inject = ["$mdComponentRegistry", "$q"];
        function SidenavFocusDirective() {
          return {
            restrict: 'A',
            require: '^mdSidenav',
            link: function(scope, element, attr, sidenavCtrl) {}
          };
        }
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
          return {
            restrict: 'E',
            scope: {isOpen: '=?mdIsOpen'},
            controller: '$mdSidenavController',
            compile: function(element) {
              element.addClass('md-closed');
              element.attr('tabIndex', '-1');
              return postLink;
            }
          };
          function postLink(scope, element, attr, sidenavCtrl) {
            var lastParentOverFlow;
            var triggeringElement = null;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
              return isLockedOpenParsed(scope.$parent, {
                $media: function(arg) {
                  $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                  return $mdMedia(arg);
                },
                $mdMedia: $mdMedia
              });
            };
            var backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
            $mdTheming.inherit(backdrop, element);
            element.on('$destroy', function() {
              backdrop.remove();
              sidenavCtrl.destroy();
            });
            scope.$on('$destroy', function() {
              backdrop.remove();
            });
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch('isOpen', updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
              scope.isLockedOpen = isLocked;
              if (isLocked === oldValue) {
                element.toggleClass('md-locked-open', !!isLocked);
              } else {
                $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');
              }
              backdrop.toggleClass('md-locked-open', !!isLocked);
            }
            function updateIsOpen(isOpen) {
              var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, '[md-sidenav-focus]') || element;
              var parent = element.parent();
              parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);
              backdrop[isOpen ? 'on' : 'off']('click', close);
              if (isOpen) {
                triggeringElement = $document[0].activeElement;
              }
              disableParentScroll(isOpen);
              return promise = $q.all([isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop), $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')]).then(function() {
                if (scope.isOpen) {
                  focusEl && focusEl.focus();
                }
              });
            }
            function disableParentScroll(disabled) {
              var parent = element.parent();
              if (disabled && !lastParentOverFlow) {
                lastParentOverFlow = parent.css('overflow');
                parent.css('overflow', 'hidden');
              } else if (angular.isDefined(lastParentOverFlow)) {
                parent.css('overflow', lastParentOverFlow);
                lastParentOverFlow = undefined;
              }
            }
            function toggleOpen(isOpen) {
              if (scope.isOpen == isOpen) {
                return $q.when(true);
              } else {
                return $q(function(resolve) {
                  scope.isOpen = isOpen;
                  $mdUtil.nextTick(function() {
                    promise.then(function(result) {
                      if (!scope.isOpen) {
                        triggeringElement && triggeringElement.focus();
                        triggeringElement = null;
                      }
                      resolve(result);
                    });
                  });
                });
              }
            }
            function onKeyDown(ev) {
              var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);
              return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
              ev.preventDefault();
              return sidenavCtrl.close();
            }
          }
        }
        SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document"];
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
          var self = this;
          self.isOpen = function() {
            return !!$scope.isOpen;
          };
          self.isLockedOpen = function() {
            return !!$scope.isLockedOpen;
          };
          self.open = function() {
            return self.$toggleOpen(true);
          };
          self.close = function() {
            return self.$toggleOpen(false);
          };
          self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
          };
          self.$toggleOpen = function(value) {
            return $q.when($scope.isOpen = value);
          };
          self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        SidenavController.$inject = ["$scope", "$element", "$attrs", "$mdComponentRegistry", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.slider', ['material.core']).directive('mdSlider', SliderDirective);
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log) {
          return {
            scope: {},
            require: '?ngModel',
            template: '<div class="md-slider-wrapper">' + '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + '</div>' + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + '</div>' + '<div class="md-disabled-thumb"></div>' + '</div>' + '</div>',
            compile: compile
          };
          function compile(tElement, tAttrs) {
            if (!tAttrs.tabindex)
              tElement.attr('tabindex', 0);
            tElement.attr('role', 'slider');
            $mdAria.expect(tElement, 'aria-label');
            return postLink;
          }
          function postLink(scope, element, attr, ngModelCtrl) {
            $mdTheming(element);
            ngModelCtrl = ngModelCtrl || {
              $setViewValue: function(val) {
                this.$viewValue = val;
                this.$viewChangeListeners.forEach(function(cb) {
                  cb();
                });
              },
              $parsers: [],
              $formatters: [],
              $viewChangeListeners: []
            };
            var isDisabledGetter = angular.noop;
            if (attr.disabled != null) {
              isDisabledGetter = function() {
                return true;
              };
            } else if (attr.ngDisabled) {
              isDisabledGetter = angular.bind(null, $parse(attr.ngDisabled), scope.$parent);
            }
            var thumb = angular.element(element[0].querySelector('.md-thumb'));
            var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element(element[0].querySelector('.md-track-container'));
            var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));
            var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);
            angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);
            angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);
            angular.isDefined(attr.step) ? attr.$observe('step', updateStep) : updateStep(1);
            var stopDisabledWatch = angular.noop;
            if (attr.ngDisabled) {
              stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
            }
            $mdGesture.register(element, 'drag');
            element.on('keydown', keydownListener).on('$md.pressdown', onPressDown).on('$md.pressup', onPressUp).on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
            function updateAll() {
              refreshSliderDimensions();
              ngModelRender();
              redrawTicks();
            }
            setTimeout(updateAll, 0);
            var debouncedUpdateAll = $$rAF.throttle(updateAll);
            angular.element($window).on('resize', debouncedUpdateAll);
            scope.$on('$destroy', function() {
              angular.element($window).off('resize', debouncedUpdateAll);
              stopDisabledWatch();
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            function updateMin(value) {
              min = parseFloat(value);
              element.attr('aria-valuemin', value);
              updateAll();
            }
            function updateMax(value) {
              max = parseFloat(value);
              element.attr('aria-valuemax', value);
              updateAll();
            }
            function updateStep(value) {
              step = parseFloat(value);
              redrawTicks();
            }
            function updateAriaDisabled(isDisabled) {
              element.attr('aria-disabled', !!isDisabled);
            }
            var tickCanvas,
                tickCtx;
            function redrawTicks() {
              if (!angular.isDefined(attr.mdDiscrete))
                return;
              if (angular.isUndefined(step))
                return;
              if (step <= 0) {
                var msg = 'Slider step value must be greater than zero when in discrete mode';
                $log.error(msg);
                throw new Error(msg);
              }
              var numSteps = Math.floor((max - min) / step);
              if (!tickCanvas) {
                tickCanvas = angular.element('<canvas>').css('position', 'absolute');
                tickContainer.append(tickCanvas);
                var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                tickCtx = tickCanvas[0].getContext('2d');
                tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';
              }
              var dimensions = getSliderDimensions();
              tickCanvas[0].width = dimensions.width;
              tickCanvas[0].height = dimensions.height;
              var distance;
              for (var i = 0; i <= numSteps; i++) {
                distance = Math.floor(dimensions.width * (i / numSteps));
                tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
              }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
              sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
              throttledRefreshDimensions();
              return sliderDimensions;
            }
            function keydownListener(ev) {
              if (element[0].hasAttribute('disabled')) {
                return;
              }
              var changeAmount;
              if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                changeAmount = -step;
              } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                changeAmount = step;
              }
              if (changeAmount) {
                if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                  changeAmount *= 4;
                }
                ev.preventDefault();
                ev.stopPropagation();
                scope.$evalAsync(function() {
                  setModelValue(ngModelCtrl.$viewValue + changeAmount);
                });
              }
            }
            function setModelValue(value) {
              ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
              if (isNaN(ngModelCtrl.$viewValue)) {
                ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
              }
              var percent = (ngModelCtrl.$viewValue - min) / (max - min);
              scope.modelValue = ngModelCtrl.$viewValue;
              element.attr('aria-valuenow', ngModelCtrl.$viewValue);
              setSliderPercent(percent);
              thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value) {
              if (angular.isNumber(value)) {
                return Math.max(min, Math.min(max, value));
              }
            }
            function stepValidator(value) {
              if (angular.isNumber(value)) {
                var formattedValue = (Math.round((value - min) / step) * step + min);
                return (Math.round(formattedValue * 1000) / 1000);
              }
            }
            function setSliderPercent(percent) {
              percent = clamp(percent);
              var percentStr = (percent * 100) + '%';
              activeTrack.css('width', percentStr);
              thumbContainer.css('left', percentStr);
              element.toggleClass('md-min', percent === 0);
              element.toggleClass('md-max', percent === 1);
            }
            var isDragging = false;
            var isDiscrete = angular.isDefined(attr.mdDiscrete);
            function onPressDown(ev) {
              if (isDisabledGetter())
                return;
              element.addClass('md-active');
              element[0].focus();
              refreshSliderDimensions();
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                setSliderPercent(valueToPercent(closestVal));
              });
            }
            function onPressUp(ev) {
              if (isDisabledGetter())
                return;
              element.removeClass('md-dragging md-active');
              var exactVal = percentToValue(positionToPercent(ev.pointer.x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              scope.$apply(function() {
                setModelValue(closestVal);
                ngModelRender();
              });
            }
            function onDragStart(ev) {
              if (isDisabledGetter())
                return;
              isDragging = true;
              ev.stopPropagation();
              element.addClass('md-dragging');
              setSliderFromEvent(ev);
            }
            function onDrag(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              setSliderFromEvent(ev);
            }
            function onDragEnd(ev) {
              if (!isDragging)
                return;
              ev.stopPropagation();
              isDragging = false;
            }
            function setSliderFromEvent(ev) {
              if (isDiscrete)
                adjustThumbPosition(ev.pointer.x);
              else
                doSlide(ev.pointer.x);
            }
            function doSlide(x) {
              scope.$evalAsync(function() {
                setModelValue(percentToValue(positionToPercent(x)));
              });
            }
            function adjustThumbPosition(x) {
              var exactVal = percentToValue(positionToPercent(x));
              var closestVal = minMaxValidator(stepValidator(exactVal));
              setSliderPercent(positionToPercent(x));
              thumbText.text(closestVal);
            }
            function clamp(value) {
              return Math.max(0, Math.min(value || 0, 1));
            }
            function positionToPercent(x) {
              return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));
            }
            function percentToValue(percent) {
              return (min + percent * (max - min));
            }
            function valueToPercent(val) {
              return (val - min) / (max - min);
            }
          }
        }
        SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.sticky', ['material.core', 'material.components.content']).factory('$mdSticky', MdSticky);
        function MdSticky($document, $mdConstant, $$rAF, $mdUtil, $compile) {
          var browserStickySupport = checkStickySupport();
          return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller('mdContent');
            if (!contentCtrl)
              return;
            if (browserStickySupport) {
              element.css({
                position: browserStickySupport,
                top: 0,
                'z-index': 2
              });
            } else {
              var $$sticky = contentCtrl.$element.data('$$sticky');
              if (!$$sticky) {
                $$sticky = setupSticky(contentCtrl);
                contentCtrl.$element.data('$$sticky', $$sticky);
              }
              var cloneElement = stickyClone || $compile(element.clone())(scope);
              var deregister = $$sticky.add(element, cloneElement);
              scope.$on('$destroy', deregister);
            }
          };
          function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.throttle(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on('$scrollstart', debouncedRefreshElements);
            contentEl.on('$scroll', onScroll);
            var self;
            return self = {
              prev: null,
              current: null,
              next: null,
              items: [],
              add: add,
              refreshElements: refreshElements
            };
            function add(element, stickyClone) {
              stickyClone.addClass('md-sticky-clone');
              var item = {
                element: element,
                clone: stickyClone
              };
              self.items.push(item);
              $mdUtil.nextTick(function() {
                contentEl.prepend(item.clone);
              });
              debouncedRefreshElements();
              return function remove() {
                self.items.forEach(function(item, index) {
                  if (item.element[0] === element[0]) {
                    self.items.splice(index, 1);
                    item.clone.remove();
                  }
                });
                debouncedRefreshElements();
              };
            }
            function refreshElements() {
              self.items.forEach(refreshPosition);
              self.items = self.items.sort(function(a, b) {
                return a.top < b.top ? -1 : 1;
              });
              var item;
              var currentScrollTop = contentEl.prop('scrollTop');
              for (var i = self.items.length - 1; i >= 0; i--) {
                if (currentScrollTop > self.items[i].top) {
                  item = self.items[i];
                  break;
                }
              }
              setCurrentItem(item);
            }
            function refreshPosition(item) {
              var current = item.element[0];
              item.top = 0;
              item.left = 0;
              while (current && current !== contentEl[0]) {
                item.top += current.offsetTop;
                item.left += current.offsetLeft;
                if (current.offsetParent) {
                  item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft;
                }
                current = current.offsetParent;
              }
              item.height = item.element.prop('offsetHeight');
              item.clone.css('margin-left', item.left + 'px');
              if ($mdUtil.floatingScrollbars()) {
                item.clone.css('margin-right', '0');
              }
            }
            function onScroll() {
              var scrollTop = contentEl.prop('scrollTop');
              var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
              onScroll.prevScrollTop = scrollTop;
              if (scrollTop === 0) {
                setCurrentItem(null);
                return;
              }
              if (isScrollingDown) {
                if (self.next && self.next.top <= scrollTop) {
                  setCurrentItem(self.next);
                  return;
                }
                if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                  translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                  return;
                }
              }
              if (!isScrollingDown) {
                if (self.current && self.prev && scrollTop < self.current.top) {
                  setCurrentItem(self.prev);
                  return;
                }
                if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {
                  translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                  return;
                }
              }
              if (self.current) {
                translate(self.current, scrollTop);
              }
            }
            function setCurrentItem(item) {
              if (self.current === item)
                return;
              if (self.current) {
                translate(self.current, null);
                setStickyState(self.current, null);
              }
              if (item) {
                setStickyState(item, 'active');
              }
              self.current = item;
              var index = self.items.indexOf(item);
              self.next = self.items[index + 1];
              self.prev = self.items[index - 1];
              setStickyState(self.next, 'next');
              setStickyState(self.prev, 'prev');
            }
            function setStickyState(item, state) {
              if (!item || item.state === state)
                return;
              if (item.state) {
                item.clone.attr('sticky-prev-state', item.state);
                item.element.attr('sticky-prev-state', item.state);
              }
              item.clone.attr('sticky-state', state);
              item.element.attr('sticky-state', state);
              item.state = state;
            }
            function translate(item, amount) {
              if (!item)
                return;
              if (amount === null || amount === undefined) {
                if (item.translateY) {
                  item.translateY = null;
                  item.clone.css($mdConstant.CSS.TRANSFORM, '');
                }
              } else {
                item.translateY = amount;
                item.clone.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)');
              }
            }
          }
          function checkStickySupport($el) {
            var stickyProp;
            var testEl = angular.element('<div>');
            $document[0].body.appendChild(testEl[0]);
            var stickyProps = ['sticky', '-webkit-sticky'];
            for (var i = 0; i < stickyProps.length; ++i) {
              testEl.css({
                position: stickyProps[i],
                top: 0,
                'z-index': 2
              });
              if (testEl.css('position') == stickyProps[i]) {
                stickyProp = stickyProps[i];
                break;
              }
            }
            testEl.remove();
            return stickyProp;
          }
          function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on('scroll touchmove', function() {
              if (!isScrolling) {
                isScrolling = true;
                $$rAF.throttle(loopScrollEvent);
                element.triggerHandler('$scrollstart');
              }
              element.triggerHandler('$scroll');
              lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
              if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                isScrolling = false;
                element.triggerHandler('$scrollend');
              } else {
                element.triggerHandler('$scroll');
                $$rAF.throttle(loopScrollEvent);
              }
            }
          }
        }
        MdSticky.$inject = ["$document", "$mdConstant", "$$rAF", "$mdUtil", "$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.subheader', ['material.core', 'material.components.sticky']).directive('mdSubheader', MdSubheaderDirective);
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
          return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: ('<div class="md-subheader">' + '  <div class="md-subheader-inner">' + '    <span class="md-subheader-content"></span>' + '  </div>' + '</div>'),
            link: function postLink(scope, element, attr, controllers, transclude) {
              $mdTheming(element);
              var outerHTML = element[0].outerHTML;
              function getContent(el) {
                return angular.element(el[0].querySelector('.md-subheader-content'));
              }
              transclude(scope, function(clone) {
                getContent(element).append(clone);
              });
              if (!element.hasClass('md-no-sticky')) {
                transclude(scope, function(clone) {
                  var wrapperHtml = '<div class="md-subheader-wrapper">' + outerHTML + '</div>';
                  var stickyClone = $compile(wrapperHtml)(scope);
                  $mdSticky(scope, element, stickyClone);
                  $mdUtil.nextTick(function() {
                    getContent(stickyClone).append(clone);
                  });
                });
              }
            }
          };
        }
        MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.swipe', ['material.core']).directive('mdSwipeLeft', getDirective('SwipeLeft')).directive('mdSwipeRight', getDirective('SwipeRight')).directive('mdSwipeUp', getDirective('SwipeUp')).directive('mdSwipeDown', getDirective('SwipeDown'));
        function getDirective(name) {
          var directiveName = 'md' + name;
          var eventName = '$md.' + name.toLowerCase();
          DirectiveFactory.$inject = ["$parse"];
          return DirectiveFactory;
          function DirectiveFactory($parse) {
            return {
              restrict: 'A',
              link: postLink
            };
            function postLink(scope, element, attr) {
              var fn = $parse(attr[directiveName]);
              element.on(eventName, function(ev) {
                scope.$apply(function() {
                  fn(scope, {$event: ev});
                });
              });
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.switch', ['material.core', 'material.components.checkbox']).directive('mdSwitch', MdSwitch);
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture) {
          var checkboxDirective = mdCheckboxDirective[0];
          return {
            restrict: 'E',
            priority: 210,
            transclude: true,
            template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + '</div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            require: '?ngModel',
            compile: mdSwitchCompile
          };
          function mdSwitchCompile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass('md-dragging');
            return function(scope, element, attr, ngModel) {
              ngModel = ngModel || $mdUtil.fakeNgModel();
              var disabledGetter = null;
              if (attr.disabled != null) {
                disabledGetter = function() {
                  return true;
                };
              } else if (attr.ngDisabled) {
                disabledGetter = $parse(attr.ngDisabled);
              }
              var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));
              var switchContainer = angular.element(element[0].querySelector('.md-container'));
              $$rAF(function() {
                element.removeClass('md-dragging');
              });
              checkboxLink(scope, element, attr, ngModel);
              if (disabledGetter) {
                scope.$watch(disabledGetter, function(isDisabled) {
                  element.attr('tabindex', isDisabled ? -1 : 0);
                });
              }
              $mdGesture.register(switchContainer, 'drag');
              switchContainer.on('$md.dragstart', onDragStart).on('$md.drag', onDrag).on('$md.dragend', onDragEnd);
              var drag;
              function onDragStart(ev) {
                if (disabledGetter && disabledGetter(scope))
                  return;
                ev.stopPropagation();
                element.addClass('md-dragging');
                drag = {width: thumbContainer.prop('offsetWidth')};
                element.removeClass('transition');
              }
              function onDrag(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                ev.srcEvent && ev.srcEvent.preventDefault();
                var percent = ev.pointer.distanceX / drag.width;
                var translate = ngModel.$viewValue ? 1 + percent : percent;
                translate = Math.max(0, Math.min(1, translate));
                thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100 * translate) + '%,0,0)');
                drag.translate = translate;
              }
              function onDragEnd(ev) {
                if (!drag)
                  return;
                ev.stopPropagation();
                element.removeClass('md-dragging');
                thumbContainer.css($mdConstant.CSS.TRANSFORM, '');
                var isChanged = ngModel.$viewValue ? drag.translate > 0.5 : drag.translate < 0.5;
                if (isChanged) {
                  applyModelValue(!ngModel.$viewValue);
                }
                drag = null;
              }
              function applyModelValue(newValue) {
                scope.$apply(function() {
                  ngModel.$setViewValue(newValue);
                  ngModel.$render();
                });
              }
            };
          }
        }
        MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.toast', ['material.core', 'material.components.button']).directive('mdToast', MdToastDirective).provider('$mdToast', MdToastProvider);
        function MdToastDirective($mdToast) {
          return {
            restrict: 'E',
            link: function postLink(scope, element, attr) {
              scope.$on('$destroy', function() {
                $mdToast.destroy();
              });
            }
          };
        }
        MdToastDirective.$inject = ["$mdToast"];
        function MdToastProvider($$interimElementProvider) {
          var ACTION_RESOLVE = 'ok';
          var activeToastContent;
          var $mdToast = $$interimElementProvider('$mdToast').setDefaults({
            methods: ['position', 'hideDelay', 'capsule', 'parent'],
            options: toastDefaultOptions
          }).addPreset('simple', {
            argOption: 'textContent',
            methods: ['textContent', 'content', 'action', 'highlightAction', 'theme', 'parent'],
            options: ["$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
              var opts = {
                template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' + '  <div class="md-toast-content">' + '    <span flex role="alert" aria-relevant="all" aria-atomic="true">' + '      {{ toast.content }}' + '    </span>' + '    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">' + '      {{ toast.action }}' + '    </md-button>' + '  </div>' + '</md-toast>',
                controller: ["$scope", function mdToastCtrl($scope) {
                  var self = this;
                  $scope.$watch(function() {
                    return activeToastContent;
                  }, function() {
                    self.content = activeToastContent;
                  });
                  this.resolve = function() {
                    $mdToast.hide(ACTION_RESOLVE);
                  };
                }],
                theme: $mdTheming.defaultTheme(),
                controllerAs: 'toast',
                bindToController: true
              };
              return opts;
            }]
          }).addMethod('updateTextContent', updateTextContent).addMethod('updateContent', updateTextContent);
          function updateTextContent(newContent) {
            activeToastContent = newContent;
          }
          toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"];
          return $mdToast;
          function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
            var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown';
            return {
              onShow: onShow,
              onRemove: onRemove,
              position: 'bottom left',
              themable: true,
              hideDelay: 3000,
              autoWrap: true,
              transformTemplate: function(template, options) {
                var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                if (shouldAddWrapper) {
                  var parsedTemplate = angular.element(template);
                  var wrappedContent = '<div class="md-toast-content">' + parsedTemplate.html() + '</div>';
                  parsedTemplate.empty().append(wrappedContent);
                  return parsedTemplate[0].outerHTML;
                }
                return shouldAddWrapper ? '<div class="md-toast-content">' + template + '</div>' : template || '';
              }
            };
            function onShow(scope, element, options) {
              activeToastContent = options.textContent || options.content;
              var isSmScreen = !$mdMedia('gt-sm');
              element = $mdUtil.extractElementByName(element, 'md-toast', true);
              options.onSwipe = function(ev, gesture) {
                var swipe = ev.type.replace('$md.', '');
                var direction = swipe.replace('swipe', '');
                if ((direction === 'down' && options.position.indexOf('top') != -1 && !isSmScreen) || (direction === 'up' && (options.position.indexOf('bottom') != -1 || isSmScreen))) {
                  return;
                }
                if ((direction === 'left' || direction === 'right') && isSmScreen) {
                  return;
                }
                element.addClass('md-' + swipe);
                $mdUtil.nextTick($mdToast.cancel);
              };
              options.openClass = toastOpenClass(options.position);
              options.parent.addClass(options.openClass);
              if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                options.parent.css('position', 'relative');
              }
              element.on(SWIPE_EVENTS, options.onSwipe);
              element.addClass(isSmScreen ? 'md-bottom' : options.position.split(' ').map(function(pos) {
                return 'md-' + pos;
              }).join(' '));
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              return $animate.enter(element, options.parent).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
              });
            }
            function onRemove(scope, element, options) {
              element.off(SWIPE_EVENTS, options.onSwipe);
              if (options.parent)
                options.parent.addClass('md-toast-animating');
              if (options.openClass)
                options.parent.removeClass(options.openClass);
              return ((options.$destroy == true) ? element.remove() : $animate.leave(element)).then(function() {
                if (options.parent)
                  options.parent.removeClass('md-toast-animating');
                if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
                  options.parent.css('position', '');
                }
              });
            }
            function toastOpenClass(position) {
              if (!$mdMedia('gt-sm')) {
                return 'md-toast-open-bottom';
              }
              return 'md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');
            }
          }
        }
        MdToastProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs', ['material.core', 'material.components.icon']);
      })();
      (function() {
        "use strict";
        angular.module('material.components.toolbar', ['material.core', 'material.components.content']).directive('mdToolbar', mdToolbarDirective);
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
          var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)');
          return {
            template: '',
            restrict: 'E',
            link: function(scope, element, attr) {
              $mdTheming(element);
              if (angular.isDefined(attr.mdScrollShrink)) {
                setupScrollShrink();
              }
              function setupScrollShrink() {
                var toolbarHeight;
                var contentElement;
                var disableScrollShrink = angular.noop;
                var y = 0;
                var prevScrollTop = 0;
                var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;
                var debouncedContentScroll = $$rAF.throttle(onContentScroll);
                var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);
                scope.$on('$mdContentLoaded', onMdContentLoad);
                attr.$observe('mdScrollShrink', onChangeScrollShrink);
                if (attr.ngShow) {
                  scope.$watch(attr.ngShow, updateToolbarHeight);
                }
                if (attr.ngHide) {
                  scope.$watch(attr.ngHide, updateToolbarHeight);
                }
                scope.$on('$destroy', disableScrollShrink);
                function onChangeScrollShrink(shrinkWithScroll) {
                  var closestContent = element.parent().find('md-content');
                  if (!contentElement && closestContent.length) {
                    onMdContentLoad(null, closestContent);
                  }
                  shrinkWithScroll = scope.$eval(shrinkWithScroll);
                  if (shrinkWithScroll === false) {
                    disableScrollShrink();
                  } else {
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onMdContentLoad($event, newContentEl) {
                  if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                    if (contentElement) {
                      contentElement.off('scroll', debouncedContentScroll);
                    }
                    contentElement = newContentEl;
                    disableScrollShrink = enableScrollShrink();
                  }
                }
                function onContentScroll(e) {
                  var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                  debouncedUpdateHeight();
                  y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                  element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
                  contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));
                  prevScrollTop = scrollTop;
                  $mdUtil.nextTick(function() {
                    var hasWhiteFrame = element.hasClass('md-whiteframe-z1');
                    if (hasWhiteFrame && !y) {
                      $animate.removeClass(element, 'md-whiteframe-z1');
                    } else if (!hasWhiteFrame && y) {
                      $animate.addClass(element, 'md-whiteframe-z1');
                    }
                  });
                }
                function enableScrollShrink() {
                  if (!contentElement)
                    return angular.noop;
                  contentElement.on('scroll', debouncedContentScroll);
                  contentElement.attr('scroll-shrink', 'true');
                  $$rAF(updateToolbarHeight);
                  return function disableScrollShrink() {
                    contentElement.off('scroll', debouncedContentScroll);
                    contentElement.attr('scroll-shrink', 'false');
                    $$rAF(updateToolbarHeight);
                  };
                }
                function updateToolbarHeight() {
                  toolbarHeight = element.prop('offsetHeight');
                  var margin = (-toolbarHeight * shrinkSpeedFactor) + 'px';
                  contentElement.css({
                    "margin-top": margin,
                    "margin-bottom": margin
                  });
                  onContentScroll();
                }
              }
            }
          };
        }
        mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tooltip', ['material.core']).directive('mdTooltip', MdTooltipDirective);
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
          var TOOLTIP_SHOW_DELAY = 0;
          var TOOLTIP_WINDOW_EDGE_SPACE = 8;
          return {
            restrict: 'E',
            transclude: true,
            priority: 210,
            template: '<div class="md-content" ng-transclude></div>',
            scope: {
              delay: '=?mdDelay',
              visible: '=?mdVisible',
              autohide: '=?mdAutohide',
              direction: '@?mdDirection'
            },
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            var parent = $mdUtil.getParentWithPointerEvents(element),
                content = angular.element(element[0].getElementsByClassName('md-content')[0]),
                tooltipParent = angular.element(document.body),
                debouncedOnResize = $$rAF.throttle(function() {
                  updatePosition();
                });
            if ($animate.pin)
              $animate.pin(element, parent);
            setDefaults();
            manipulateElement();
            bindEvents();
            updateContentOrigin();
            configureWatchers();
            addAriaLabel();
            function setDefaults() {
              if (!angular.isDefined(attr.mdDelay))
                scope.delay = TOOLTIP_SHOW_DELAY;
            }
            function updateContentOrigin() {
              var origin = 'center top';
              switch (scope.direction) {
                case 'left':
                  origin = 'right center';
                  break;
                case 'right':
                  origin = 'left center';
                  break;
                case 'top':
                  origin = 'center bottom';
                  break;
                case 'bottom':
                  origin = 'center top';
                  break;
              }
              content.css('transform-origin', origin);
            }
            function configureWatchers() {
              scope.$on('$destroy', function() {
                scope.visible = false;
                element.remove();
                angular.element($window).off('resize', debouncedOnResize);
              });
              scope.$watch('visible', function(isVisible) {
                if (isVisible)
                  showTooltip();
                else
                  hideTooltip();
              });
              scope.$watch('direction', updatePosition);
            }
            function addAriaLabel() {
              if (!parent.attr('aria-label') && !parent.text().trim()) {
                parent.attr('aria-label', element.text().trim());
              }
            }
            function manipulateElement() {
              element.detach();
              element.attr('role', 'tooltip');
            }
            function bindEvents() {
              var mouseActive = false;
              var ngWindow = angular.element($window);
              if (parent[0] && 'MutationObserver' in $window) {
                var attributeObserver = new MutationObserver(function(mutations) {
                  mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'disabled' && parent[0].disabled) {
                      setVisible(false);
                      scope.$digest();
                    }
                  });
                });
                attributeObserver.observe(parent[0], {attributes: true});
              }
              var windowBlurHandler = function() {
                elementFocusedOnWindowBlur = document.activeElement === parent[0];
              };
              var elementFocusedOnWindowBlur = false;
              function windowScrollHandler() {
                setVisible(false);
              }
              ngWindow.on('blur', windowBlurHandler);
              ngWindow.on('resize', debouncedOnResize);
              document.addEventListener('scroll', windowScrollHandler, true);
              scope.$on('$destroy', function() {
                ngWindow.off('blur', windowBlurHandler);
                ngWindow.off('resize', debouncedOnResize);
                document.removeEventListener('scroll', windowScrollHandler, true);
                attributeObserver && attributeObserver.disconnect();
              });
              var enterHandler = function(e) {
                if (e.type === 'focus' && elementFocusedOnWindowBlur) {
                  elementFocusedOnWindowBlur = false;
                  return;
                }
                parent.on('blur mouseleave touchend touchcancel', leaveHandler);
                setVisible(true);
              };
              var leaveHandler = function() {
                var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');
                if (autohide || mouseActive || ($document[0].activeElement !== parent[0])) {
                  parent.off('blur mouseleave touchend touchcancel', leaveHandler);
                  parent.triggerHandler("blur");
                  setVisible(false);
                }
                mouseActive = false;
              };
              parent.on('mousedown', function() {
                mouseActive = true;
              });
              parent.on('focus mouseenter touchstart', enterHandler);
            }
            function setVisible(value) {
              setVisible.value = !!value;
              if (!setVisible.queued) {
                if (value) {
                  setVisible.queued = true;
                  $timeout(function() {
                    scope.visible = setVisible.value;
                    setVisible.queued = false;
                  }, scope.delay);
                } else {
                  $mdUtil.nextTick(function() {
                    scope.visible = false;
                  });
                }
              }
            }
            function showTooltip() {
              tooltipParent.append(element);
              if ($mdUtil.hasComputedStyle(element, 'display', 'none')) {
                scope.visible = false;
                element.detach();
                return;
              }
              updatePosition();
              angular.forEach([element, content], function(element) {
                $animate.addClass(element, 'md-show');
              });
            }
            function hideTooltip() {
              var promises = [];
              angular.forEach([element, content], function(it) {
                if (it.parent() && it.hasClass('md-show')) {
                  promises.push($animate.removeClass(it, 'md-show'));
                }
              });
              $q.all(promises).then(function() {
                if (!scope.visible)
                  element.detach();
              });
            }
            function updatePosition() {
              if (!scope.visible)
                return;
              updateContentOrigin();
              positionTooltip();
            }
            function positionTooltip() {
              var tipRect = $mdUtil.offsetRect(element, tooltipParent);
              var parentRect = $mdUtil.offsetRect(parent, tooltipParent);
              var newPosition = getPosition(scope.direction);
              var offsetParent = element.prop('offsetParent');
              if (scope.direction) {
                newPosition = fitInParent(newPosition);
              } else if (offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {
                newPosition = fitInParent(getPosition('top'));
              }
              element.css({
                left: newPosition.left + 'px',
                top: newPosition.top + 'px'
              });
              function fitInParent(pos) {
                var newPosition = {
                  left: pos.left,
                  top: pos.top
                };
                newPosition.left = Math.min(newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.min(newPosition.top, tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                return newPosition;
              }
              function getPosition(dir) {
                return dir === 'left' ? {
                  left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'right' ? {
                  left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                  top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                } : dir === 'top' ? {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                } : {
                  left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                  top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                };
              }
            }
          }
        }
        MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.virtualRepeat', ['material.core', 'material.components.showHide']).directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective).directive('mdVirtualRepeat', VirtualRepeatDirective);
        function VirtualRepeatContainerDirective() {
          return {
            controller: VirtualRepeatContainerController,
            template: virtualRepeatContainerTemplate,
            compile: function virtualRepeatContainerCompile($element, $attrs) {
              $element.addClass('md-virtual-repeat-container').addClass($attrs.hasOwnProperty('mdOrientHorizontal') ? 'md-orient-horizontal' : 'md-orient-vertical');
            }
          };
        }
        function virtualRepeatContainerTemplate($element) {
          return '<div class="md-virtual-repeat-scroller">' + '<div class="md-virtual-repeat-sizer"></div>' + '<div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + '</div></div>';
        }
        var MAX_ELEMENT_SIZE = 1533917;
        var NUM_EXTRA = 3;
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
          this.$rootScope = $rootScope;
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.size = 0;
          this.scrollSize = 0;
          this.scrollOffset = 0;
          this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
          this.repeater = null;
          this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
          this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
          this.originalSize = null;
          this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
          this.oldElementSize = null;
          if (this.$attrs.mdTopIndex) {
            this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
            this.topIndex = this.bindTopIndex(this.$scope);
            if (!angular.isDefined(this.topIndex)) {
              this.topIndex = 0;
              this.bindTopIndex.assign(this.$scope, 0);
            }
            this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
              if (newIndex !== this.topIndex) {
                this.scrollToIndex(newIndex);
              }
            }));
          } else {
            this.topIndex = 0;
          }
          this.scroller = $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0];
          this.sizer = this.scroller.getElementsByClassName('md-virtual-repeat-sizer')[0];
          this.offsetter = this.scroller.getElementsByClassName('md-virtual-repeat-offsetter')[0];
          var boundUpdateSize = angular.bind(this, this.updateSize);
          $$rAF(angular.bind(this, function() {
            boundUpdateSize();
            var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
            var jWindow = angular.element($window);
            if (!this.size) {
              debouncedUpdateSize();
            }
            jWindow.on('resize', debouncedUpdateSize);
            $scope.$on('$destroy', function() {
              jWindow.off('resize', debouncedUpdateSize);
            });
            $scope.$emit('$md-resize-enable');
            $scope.$on('$md-resize', boundUpdateSize);
          }));
        }
        VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
          this.repeater = repeaterCtrl;
          angular.element(this.scroller).on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
        };
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        VirtualRepeatContainerController.prototype.getSize = function() {
          return this.size;
        };
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
          var dimension = this.getDimensionName_();
          this.size = size;
          this.$element[0].style[dimension] = size + 'px';
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
          this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
          this.oldElementSize = null;
        };
        VirtualRepeatContainerController.prototype.updateSize = function() {
          if (this.originalSize)
            return;
          this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
          this.handleScroll_();
          this.repeater && this.repeater.containerUpdated();
        };
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
          return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
          return this.isHorizontal() ? 'width' : 'height';
        };
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
          var dimension = this.getDimensionName_();
          var crossDimension = this.isHorizontal() ? 'height' : 'width';
          this.sizer.innerHTML = '';
          if (size < MAX_ELEMENT_SIZE) {
            this.sizer.style[dimension] = size + 'px';
          } else {
            this.sizer.style[dimension] = 'auto';
            this.sizer.style[crossDimension] = 'auto';
            var numChildren = Math.floor(size / MAX_ELEMENT_SIZE);
            var sizerChild = document.createElement('div');
            sizerChild.style[dimension] = MAX_ELEMENT_SIZE + 'px';
            sizerChild.style[crossDimension] = '1px';
            for (var i = 0; i < numChildren; i++) {
              this.sizer.appendChild(sizerChild.cloneNode(false));
            }
            sizerChild.style[dimension] = (size - (numChildren * MAX_ELEMENT_SIZE)) + 'px';
            this.sizer.appendChild(sizerChild);
          }
        };
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
          var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
          if (this.autoShrink && shrinkSize !== this.size) {
            if (this.oldElementSize === null) {
              this.oldElementSize = this.$element[0].style[this.getDimensionName_()];
            }
            var currentSize = this.originalSize || this.size;
            if (!currentSize || shrinkSize < currentSize) {
              if (!this.originalSize) {
                this.originalSize = this.size;
              }
              this.setSize_(shrinkSize);
            } else if (this.originalSize !== null) {
              this.unsetSize_();
              this.originalSize = null;
              this.updateSize();
            }
            this.repeater.containerUpdated();
          }
        };
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
          var size = itemsSize + this.offsetSize;
          if (this.scrollSize === size)
            return;
          this.sizeScroller_(size);
          this.autoShrink_(size);
          this.scrollSize = size;
        };
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
          return this.scrollOffset;
        };
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
          this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
          this.handleScroll_();
        };
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
          var itemSize = this.repeater.getItemSize();
          var itemsLength = this.repeater.itemsLength;
          if (index > itemsLength) {
            index = itemsLength - 1;
          }
          this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
          this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
          var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
          if (offset === this.scrollOffset || offset > this.scrollSize - this.size)
            return;
          var itemSize = this.repeater.getItemSize();
          if (!itemSize)
            return;
          var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);
          var transform = (this.isHorizontal() ? 'translateX(' : 'translateY(') + (numItems * itemSize) + 'px)';
          this.scrollOffset = offset;
          this.offsetter.style.webkitTransform = transform;
          this.offsetter.style.transform = transform;
          if (this.bindTopIndex) {
            var topIndex = Math.floor(offset / itemSize);
            if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
              this.topIndex = topIndex;
              this.bindTopIndex.assign(this.$scope, topIndex);
              if (!this.$rootScope.$$phase)
                this.$scope.$digest();
            }
          }
          this.repeater.containerUpdated();
        };
        function VirtualRepeatDirective($parse) {
          return {
            controller: VirtualRepeatController,
            priority: 1000,
            require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
            restrict: 'A',
            terminal: true,
            transclude: 'element',
            compile: function VirtualRepeatCompile($element, $attrs) {
              var expression = $attrs.mdVirtualRepeat;
              var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
              var repeatName = match[1];
              var repeatListExpression = $parse(match[2]);
              var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
              return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
                ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
              };
            }
          };
        }
        VirtualRepeatDirective.$inject = ["$parse"];
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF) {
          this.$scope = $scope;
          this.$element = $element;
          this.$attrs = $attrs;
          this.$browser = $browser;
          this.$document = $document;
          this.$rootScope = $rootScope;
          this.$$rAF = $$rAF;
          this.onDemand = $attrs.hasOwnProperty('mdOnDemand');
          this.browserCheckUrlChange = $browser.$$checkUrlChange;
          this.newStartIndex = 0;
          this.newEndIndex = 0;
          this.newVisibleEnd = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
          this.isFirstRender = true;
          this.isVirtualRepeatUpdating_ = false;
          this.itemsLength = 0;
          this.unwatchItemSize_ = angular.noop;
          this.blocks = {};
          this.pooledBlocks = [];
        }
        VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF"];
        VirtualRepeatController.Block;
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
          this.container = container;
          this.transclude = transclude;
          this.repeatName = repeatName;
          this.rawRepeatListExpression = repeatListExpression;
          this.extraName = extraName;
          this.sized = false;
          this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
          this.container.register(this);
        };
        VirtualRepeatController.prototype.readItemSize_ = function() {
          if (this.itemSize) {
            return;
          }
          this.items = this.repeatListExpression(this.$scope);
          this.parentNode = this.$element[0].parentNode;
          var block = this.getBlock_(0);
          if (!block.element[0].parentNode) {
            this.parentNode.appendChild(block.element[0]);
          }
          this.itemSize = block.element[0][this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;
          this.blocks[0] = block;
          this.poolBlock_(0);
          if (this.itemSize) {
            this.containerUpdated();
          }
        };
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
          var repeatList = this.rawRepeatListExpression(scope);
          if (this.onDemand && repeatList) {
            var virtualList = new VirtualRepeatModelArrayLike(repeatList);
            virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
            return virtualList;
          } else {
            return repeatList;
          }
        };
        VirtualRepeatController.prototype.containerUpdated = function() {
          if (!this.itemSize) {
            this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
              if (items && items.length) {
                this.$$rAF(angular.bind(this, this.readItemSize_));
              }
            }));
            if (!this.$rootScope.$$phase)
              this.$scope.$digest();
            return;
          } else if (!this.sized) {
            this.items = this.repeatListExpression(this.$scope);
          }
          if (!this.sized) {
            this.unwatchItemSize_();
            this.sized = true;
            this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
              if (!this.isVirtualRepeatUpdating_) {
                this.virtualRepeatUpdate_(items, oldItems);
              }
            }));
          }
          this.updateIndexes_();
          if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
            if (this.items instanceof VirtualRepeatModelArrayLike) {
              this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
            }
            this.virtualRepeatUpdate_(this.items, this.items);
          }
        };
        VirtualRepeatController.prototype.getItemSize = function() {
          return this.itemSize;
        };
        VirtualRepeatController.prototype.getItemCount = function() {
          return this.itemsLength;
        };
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
          this.isVirtualRepeatUpdating_ = true;
          var itemsLength = items && items.length || 0;
          var lengthChanged = false;
          if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
            this.items = items;
            this.container.resetScroll();
            return;
          }
          if (itemsLength !== this.itemsLength) {
            lengthChanged = true;
            this.itemsLength = itemsLength;
          }
          this.items = items;
          if (items !== oldItems || lengthChanged) {
            this.updateIndexes_();
          }
          this.parentNode = this.$element[0].parentNode;
          if (lengthChanged) {
            this.container.setScrollSize(itemsLength * this.itemSize);
          }
          if (this.isFirstRender) {
            this.isFirstRender = false;
            var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
            this.container.scrollToIndex(startIndex);
          }
          Object.keys(this.blocks).forEach(function(blockIndex) {
            var index = parseInt(blockIndex, 10);
            if (index < this.newStartIndex || index >= this.newEndIndex) {
              this.poolBlock_(index);
            }
          }, this);
          this.$browser.$$checkUrlChange = angular.noop;
          var i,
              block,
              newStartBlocks = [],
              newEndBlocks = [];
          for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newStartBlocks.push(block);
          }
          for (; this.blocks[i] != null; i++) {
            this.updateBlock_(this.blocks[i], i);
          }
          var maxIndex = i - 1;
          for (; i < this.newEndIndex; i++) {
            block = this.getBlock_(i);
            this.updateBlock_(block, i);
            newEndBlocks.push(block);
          }
          if (newStartBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
          }
          if (newEndBlocks.length) {
            this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
          }
          this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
          this.startIndex = this.newStartIndex;
          this.endIndex = this.newEndIndex;
          this.isVirtualRepeatUpdating_ = false;
        };
        VirtualRepeatController.prototype.getBlock_ = function(index) {
          if (this.pooledBlocks.length) {
            return this.pooledBlocks.pop();
          }
          var block;
          this.transclude(angular.bind(this, function(clone, scope) {
            block = {
              element: clone,
              new: true,
              scope: scope
            };
            this.updateScope_(scope, index);
            this.parentNode.appendChild(clone[0]);
          }));
          return block;
        };
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
          this.blocks[index] = block;
          if (!block.new && (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
            return;
          }
          block.new = false;
          this.updateScope_(block.scope, index);
          if (!this.$rootScope.$$phase) {
            block.scope.$digest();
          }
        };
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
          scope.$index = index;
          scope[this.repeatName] = this.items && this.items[index];
          if (this.extraName)
            scope[this.extraName(this.$scope)] = this.items[index];
        };
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
          this.pooledBlocks.push(this.blocks[index]);
          this.parentNode.removeChild(this.blocks[index].element[0]);
          delete this.blocks[index];
        };
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
          var fragment = this.$document[0].createDocumentFragment();
          blocks.forEach(function(block) {
            fragment.appendChild(block.element[0]);
          });
          return fragment;
        };
        VirtualRepeatController.prototype.updateIndexes_ = function() {
          var itemsLength = this.items ? this.items.length : 0;
          var containerLength = Math.ceil(this.container.getSize() / this.itemSize);
          this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
          this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
          this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
          this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        function VirtualRepeatModelArrayLike(model) {
          if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) {
            throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ');
          }
          this.model = model;
        }
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
          for (var i = start; i < end; i++) {
            if (!this.hasOwnProperty(i)) {
              this[i] = this.model.getItemAtIndex(i);
            }
          }
          this.length = this.model.getLength();
        };
        function abstractMethod() {
          throw Error('Non-overridden abstract method called.');
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.whiteframe', ['material.core']).directive('mdWhiteframe', MdWhiteframeDirective);
        function MdWhiteframeDirective($log) {
          var MIN_DP = 1;
          var MAX_DP = 24;
          var DEFAULT_DP = 4;
          return {
            restrict: 'A',
            link: postLink
          };
          function postLink(scope, element, attr) {
            var elevation = parseInt(attr.mdWhiteframe, 10) || DEFAULT_DP;
            if (elevation > MAX_DP || elevation < MIN_DP) {
              $log.warn('md-whiteframe attribute value is invalid. It should be a number between ' + MIN_DP + ' and ' + MAX_DP, element[0]);
              elevation = DEFAULT_DP;
            }
            element.addClass('md-whiteframe-' + elevation + 'dp');
          }
        }
        MdWhiteframeDirective.$inject = ["$log"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdAutocompleteCtrl', MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41,
            MAX_HEIGHT = 5.5 * ITEM_HEIGHT,
            MENU_PADDING = 8,
            INPUT_PADDING = 2;
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
          var ctrl = this,
              itemParts = $scope.itemsExpr.split(/ in /i),
              itemExpr = itemParts[1],
              elements = null,
              cache = {},
              noBlur = false,
              selectedItemWatchers = [],
              hasFocus = false,
              lastCount = 0,
              promiseFetch = false;
          defineProperty('hidden', handleHiddenChange, true);
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.itemName = itemParts[0];
          ctrl.matches = [];
          ctrl.loading = false;
          ctrl.hidden = true;
          ctrl.index = null;
          ctrl.messages = [];
          ctrl.id = $mdUtil.nextUid();
          ctrl.isDisabled = null;
          ctrl.isRequired = null;
          ctrl.hasNotFound = false;
          ctrl.keydown = keydown;
          ctrl.blur = blur;
          ctrl.focus = focus;
          ctrl.clear = clearValue;
          ctrl.select = select;
          ctrl.listEnter = onListEnter;
          ctrl.listLeave = onListLeave;
          ctrl.mouseUp = onMouseup;
          ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
          ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
          ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
          ctrl.notFoundVisible = notFoundVisible;
          ctrl.loadingIsVisible = loadingIsVisible;
          return init();
          function init() {
            $mdUtil.initOptionalProperties($scope, $attrs, {
              searchText: null,
              selectedItem: null
            });
            $mdTheming($element);
            configureWatchers();
            $mdUtil.nextTick(function() {
              gatherElements();
              moveDropdown();
              focusElement();
              $element.on('focus', focusElement);
            });
          }
          function positionDropdown() {
            if (!elements)
              return $mdUtil.nextTick(positionDropdown, false, $scope);
            var hrect = elements.wrap.getBoundingClientRect(),
                vrect = elements.snap.getBoundingClientRect(),
                root = elements.root.getBoundingClientRect(),
                top = vrect.bottom - root.top,
                bot = root.bottom - vrect.top,
                left = hrect.left - root.left,
                width = hrect.width,
                offset = getVerticalOffset(),
                styles;
            if ($attrs.mdFloatingLabel) {
              left += INPUT_PADDING;
              width -= INPUT_PADDING * 2;
            }
            styles = {
              left: left + 'px',
              minWidth: width + 'px',
              maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'
            };
            if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
              styles.top = 'auto';
              styles.bottom = bot + 'px';
              styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';
            } else {
              styles.top = (top - offset) + 'px';
              styles.bottom = 'auto';
              styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + 'px';
            }
            elements.$.scrollContainer.css(styles);
            $mdUtil.nextTick(correctHorizontalAlignment, false);
            function getVerticalOffset() {
              var offset = 0;
              var inputContainer = $element.find('md-input-container');
              if (inputContainer.length) {
                var input = inputContainer.find('input');
                offset = inputContainer.prop('offsetHeight');
                offset -= input.prop('offsetTop');
                offset -= input.prop('offsetHeight');
                offset += inputContainer.prop('offsetTop');
              }
              return offset;
            }
            function correctHorizontalAlignment() {
              var dropdown = elements.scrollContainer.getBoundingClientRect(),
                  styles = {};
              if (dropdown.right > root.right - MENU_PADDING) {
                styles.left = (hrect.right - dropdown.width) + 'px';
              }
              elements.$.scrollContainer.css(styles);
            }
          }
          function moveDropdown() {
            if (!elements.$.root.length)
              return;
            $mdTheming(elements.$.scrollContainer);
            elements.$.scrollContainer.detach();
            elements.$.root.append(elements.$.scrollContainer);
            if ($animate.pin)
              $animate.pin(elements.$.scrollContainer, $rootElement);
          }
          function focusElement() {
            if ($scope.autofocus)
              elements.input.focus();
          }
          function configureWatchers() {
            var wait = parseInt($scope.delay, 10) || 0;
            $attrs.$observe('disabled', function(value) {
              ctrl.isDisabled = !!value;
            });
            $attrs.$observe('required', function(value) {
              ctrl.isRequired = !!value;
            });
            $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
            $scope.$watch('selectedItem', selectedItemChange);
            angular.element($window).on('resize', positionDropdown);
            $scope.$on('$destroy', cleanup);
          }
          function cleanup() {
            if (!ctrl.hidden) {
              $mdUtil.enableScrolling();
            }
            angular.element($window).off('resize', positionDropdown);
            if (elements) {
              var items = 'ul scroller scrollContainer input'.split(' ');
              angular.forEach(items, function(key) {
                elements.$[key].remove();
              });
            }
          }
          function gatherElements() {
            elements = {
              main: $element[0],
              scrollContainer: $element[0].getElementsByClassName('md-virtual-repeat-container')[0],
              scroller: $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0],
              ul: $element.find('ul')[0],
              input: $element.find('input')[0],
              wrap: $element.find('md-autocomplete-wrap')[0],
              root: document.body
            };
            elements.li = elements.ul.getElementsByTagName('li');
            elements.snap = getSnapTarget();
            elements.$ = getAngularElements(elements);
          }
          function getSnapTarget() {
            for (var element = $element; element.length; element = element.parent()) {
              if (angular.isDefined(element.attr('md-autocomplete-snap')))
                return element[0];
            }
            return elements.wrap;
          }
          function getAngularElements(elements) {
            var obj = {};
            for (var key in elements) {
              if (elements.hasOwnProperty(key))
                obj[key] = angular.element(elements[key]);
            }
            return obj;
          }
          function handleHiddenChange(hidden, oldHidden) {
            if (!hidden && oldHidden) {
              positionDropdown();
              if (elements) {
                $mdUtil.nextTick(function() {
                  $mdUtil.disableScrollAround(elements.ul);
                }, false, $scope);
              }
            } else if (hidden && !oldHidden) {
              $mdUtil.nextTick(function() {
                $mdUtil.enableScrolling();
              }, false, $scope);
            }
          }
          function onListEnter() {
            noBlur = true;
          }
          function onListLeave() {
            if (!hasFocus)
              elements.input.focus();
            noBlur = false;
            ctrl.hidden = shouldHide();
          }
          function onMouseup() {
            elements.input.focus();
          }
          function selectedItemChange(selectedItem, previousSelectedItem) {
            if (selectedItem) {
              getDisplayValue(selectedItem).then(function(val) {
                $scope.searchText = val;
                handleSelectedItemChange(selectedItem, previousSelectedItem);
              });
            }
            if (selectedItem !== previousSelectedItem)
              announceItemChange();
          }
          function announceItemChange() {
            angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
          }
          function announceTextChange() {
            angular.isFunction($scope.textChange) && $scope.textChange();
          }
          function handleSelectedItemChange(selectedItem, previousSelectedItem) {
            selectedItemWatchers.forEach(function(watcher) {
              watcher(selectedItem, previousSelectedItem);
            });
          }
          function registerSelectedItemWatcher(cb) {
            if (selectedItemWatchers.indexOf(cb) == -1) {
              selectedItemWatchers.push(cb);
            }
          }
          function unregisterSelectedItemWatcher(cb) {
            var i = selectedItemWatchers.indexOf(cb);
            if (i != -1) {
              selectedItemWatchers.splice(i, 1);
            }
          }
          function handleSearchText(searchText, previousSearchText) {
            ctrl.index = getDefaultIndex();
            if (searchText === previousSearchText)
              return;
            getDisplayValue($scope.selectedItem).then(function(val) {
              if (searchText !== val) {
                $scope.selectedItem = null;
                if (searchText !== previousSearchText)
                  announceTextChange();
                if (!isMinLengthMet()) {
                  ctrl.matches = [];
                  setLoading(false);
                  updateMessages();
                } else {
                  handleQuery();
                }
              }
            });
          }
          function blur() {
            hasFocus = false;
            if (!noBlur) {
              ctrl.hidden = shouldHide();
            }
          }
          function doBlur(forceBlur) {
            if (forceBlur) {
              noBlur = false;
              hasFocus = false;
            }
            elements.input.blur();
          }
          function focus() {
            hasFocus = true;
            if (!angular.isString($scope.searchText))
              $scope.searchText = '';
            ctrl.hidden = shouldHide();
            if (!ctrl.hidden)
              handleQuery();
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.DOWN_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.UP_ARROW:
                if (ctrl.loading)
                  return;
                event.stopPropagation();
                event.preventDefault();
                ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                updateScroll();
                updateMessages();
                break;
              case $mdConstant.KEY_CODE.TAB:
                onListLeave();
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ENTER:
                if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1)
                  return;
                if (hasSelection())
                  return;
                event.stopPropagation();
                event.preventDefault();
                select(ctrl.index);
                break;
              case $mdConstant.KEY_CODE.ESCAPE:
                event.stopPropagation();
                event.preventDefault();
                clearValue();
                doBlur(true);
                break;
              default:
            }
          }
          function getMinLength() {
            return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
          }
          function getDisplayValue(item) {
            return $q.when(getItemText(item) || item);
            function getItemText(item) {
              return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
            }
          }
          function getItemAsNameVal(item) {
            if (!item)
              return undefined;
            var locals = {};
            if (ctrl.itemName)
              locals[ctrl.itemName] = item;
            return locals;
          }
          function getDefaultIndex() {
            return $scope.autoselect ? 0 : -1;
          }
          function setLoading(value) {
            if (ctrl.loading != value) {
              ctrl.loading = value;
            }
            ctrl.hidden = shouldHide();
          }
          function shouldHide() {
            if (ctrl.loading && !hasMatches())
              return true;
            else if (hasSelection())
              return true;
            else if (!hasFocus)
              return true;
            else
              return !shouldShow();
          }
          function shouldShow() {
            return (isMinLengthMet() && hasMatches()) || notFoundVisible();
          }
          function hasMatches() {
            return ctrl.matches.length ? true : false;
          }
          function hasSelection() {
            return ctrl.scope.selectedItem ? true : false;
          }
          function loadingIsVisible() {
            return ctrl.loading && !hasSelection();
          }
          function getCurrentDisplayValue() {
            return getDisplayValue(ctrl.matches[ctrl.index]);
          }
          function isMinLengthMet() {
            return ($scope.searchText || '').length >= getMinLength();
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler(newValue, oldValue);
              }
            });
          }
          function select(index) {
            $mdUtil.nextTick(function() {
              getDisplayValue(ctrl.matches[index]).then(function(val) {
                var ngModel = elements.$.input.controller('ngModel');
                ngModel.$setViewValue(val);
                ngModel.$render();
              }).finally(function() {
                $scope.selectedItem = ctrl.matches[index];
                setLoading(false);
              });
            }, false);
          }
          function clearValue() {
            setLoading(true);
            ctrl.index = 0;
            ctrl.matches = [];
            $scope.searchText = '';
            select(-1);
            var eventObj = document.createEvent('CustomEvent');
            eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});
            elements.input.dispatchEvent(eventObj);
            elements.input.focus();
          }
          function fetchResults(searchText) {
            var items = $scope.$parent.$eval(itemExpr),
                term = searchText.toLowerCase();
            if (angular.isArray(items)) {
              handleResults(items);
            } else if (items) {
              setLoading(true);
              promiseFetch = true;
              $mdUtil.nextTick(function() {
                if (items.success)
                  items.success(handleResults);
                if (items.then)
                  items.then(handleResults);
                if (items.finally)
                  items.finally(function() {
                    setLoading(false);
                    promiseFetch = false;
                  });
              }, true, $scope);
            }
            function handleResults(matches) {
              cache[term] = matches;
              if ((searchText || '') !== ($scope.searchText || ''))
                return;
              ctrl.matches = matches;
              ctrl.hidden = shouldHide();
              if ($scope.selectOnMatch)
                selectItemOnMatch();
              updateMessages();
              positionDropdown();
            }
          }
          function updateMessages() {
            getCurrentDisplayValue().then(function(msg) {
              ctrl.messages = [getCountMessage(), msg];
            });
          }
          function getCountMessage() {
            if (lastCount === ctrl.matches.length)
              return '';
            lastCount = ctrl.matches.length;
            switch (ctrl.matches.length) {
              case 0:
                return 'There are no matches available.';
              case 1:
                return 'There is 1 match available.';
              default:
                return 'There are ' + ctrl.matches.length + ' matches available.';
            }
          }
          function updateScroll() {
            if (!elements.li[0])
              return;
            var height = elements.li[0].offsetHeight,
                top = height * ctrl.index,
                bot = top + height,
                hgt = elements.scroller.clientHeight,
                scrollTop = elements.scroller.scrollTop;
            if (top < scrollTop) {
              scrollTo(top);
            } else if (bot > scrollTop + hgt) {
              scrollTo(bot - hgt);
            }
          }
          function scrollTo(offset) {
            elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);
          }
          function notFoundVisible() {
            var textLength = (ctrl.scope.searchText || '').length;
            return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || promiseFetch) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
          }
          function handleQuery() {
            var searchText = $scope.searchText || '',
                term = searchText.toLowerCase();
            if (!$scope.noCache && cache[term]) {
              ctrl.matches = cache[term];
              updateMessages();
            } else {
              fetchResults(searchText);
            }
            ctrl.hidden = shouldHide();
          }
          function selectItemOnMatch() {
            var searchText = $scope.searchText,
                matches = ctrl.matches,
                item = matches[0];
            if (matches.length === 1)
              getDisplayValue(item).then(function(displayValue) {
                if (searchText == displayValue)
                  select(0);
              });
          }
        }
        MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocomplete', MdAutocomplete);
        function MdAutocomplete() {
          return {
            controller: 'MdAutocompleteCtrl',
            controllerAs: '$mdAutocompleteCtrl',
            scope: {
              inputName: '@mdInputName',
              inputMinlength: '@mdInputMinlength',
              inputMaxlength: '@mdInputMaxlength',
              searchText: '=?mdSearchText',
              selectedItem: '=?mdSelectedItem',
              itemsExpr: '@mdItems',
              itemText: '&mdItemText',
              placeholder: '@placeholder',
              noCache: '=?mdNoCache',
              selectOnMatch: '=?mdSelectOnMatch',
              itemChange: '&?mdSelectedItemChange',
              textChange: '&?mdSearchTextChange',
              minLength: '=?mdMinLength',
              delay: '=?mdDelay',
              autofocus: '=?mdAutofocus',
              floatingLabel: '@?mdFloatingLabel',
              autoselect: '=?mdAutoselect',
              menuClass: '@?mdMenuClass',
              inputId: '@?mdInputId'
            },
            link: function(scope, element, attrs, controller) {
              controller.hasNotFound = !!element.attr('md-has-not-found');
            },
            template: function(element, attr) {
              var noItemsTemplate = getNoItemsTemplate(),
                  itemTemplate = getItemTemplate(),
                  leftover = element.html(),
                  tabindex = attr.tabindex;
              if (noItemsTemplate)
                element.attr('md-has-not-found', true);
              if (!attr.hasOwnProperty('tabindex'))
                element.attr('tabindex', '-1');
              return '\
        <md-autocomplete-wrap\
            layout="row"\
            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"\
            role="listbox">\
          ' + getInputElement() + '\
          <md-progress-linear\
              class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\
              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\
              md-mode="indeterminate"></md-progress-linear>\
          <md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min="1"\
              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\
              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\
              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\
              ng-hide="$mdAutocompleteCtrl.hidden"\
              class="md-autocomplete-suggestions-container md-whiteframe-z1"\
              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
              role="presentation">\
            <ul class="md-autocomplete-suggestions"\
                ng-class="::menuClass"\
                id="ul-{{$mdAutocompleteCtrl.id}}">\
              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"\
                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"\
                  ng-click="$mdAutocompleteCtrl.select($index)"\
                  md-extra-name="$mdAutocompleteCtrl.itemName">\
                  ' + itemTemplate + '\
                  </li>' + noItemsTemplate + '\
            </ul>\
          </md-virtual-repeat-container>\
        </md-autocomplete-wrap>\
        <aria-status\
            class="md-visually-hidden"\
            role="status"\
            aria-live="assertive">\
          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>\
        </aria-status>';
              function getItemTemplate() {
                var templateTag = element.find('md-item-template').detach(),
                    html = templateTag.length ? templateTag.html() : element.html();
                if (!templateTag.length)
                  element.empty();
                return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html + '</md-autocomplete-parent-scope>';
              }
              function getNoItemsTemplate() {
                var templateTag = element.find('md-not-found').detach(),
                    template = templateTag.length ? templateTag.html() : '';
                return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\
                         md-autocomplete-parent-scope>' + template + '</li>' : '';
              }
              function getInputElement() {
                if (attr.mdFloatingLabel) {
                  return '\
            <md-input-container flex ng-if="floatingLabel">\
              <label>{{floatingLabel}}</label>\
              <input type="search"\
                  ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\
                  name="{{inputName}}"\
                  autocomplete="off"\
                  ng-required="$mdAutocompleteCtrl.isRequired"\
                  ng-minlength="inputMinlength"\
                  ng-maxlength="inputMaxlength"\
                  ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                  ng-model="$mdAutocompleteCtrl.scope.searchText"\
                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                  ng-blur="$mdAutocompleteCtrl.blur()"\
                  ng-focus="$mdAutocompleteCtrl.focus()"\
                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                  aria-label="{{floatingLabel}}"\
                  aria-autocomplete="list"\
                  aria-haspopup="true"\
                  aria-activedescendant=""\
                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\
            </md-input-container>';
                } else {
                  return '\
            <input flex type="search"\
                ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\
                name="{{inputName}}"\
                ng-if="!floatingLabel"\
                autocomplete="off"\
                ng-required="$mdAutocompleteCtrl.isRequired"\
                ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                ng-model="$mdAutocompleteCtrl.scope.searchText"\
                ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                ng-blur="$mdAutocompleteCtrl.blur()"\
                ng-focus="$mdAutocompleteCtrl.focus()"\
                placeholder="{{placeholder}}"\
                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                aria-label="{{placeholder}}"\
                aria-autocomplete="list"\
                aria-haspopup="true"\
                aria-activedescendant=""\
                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>\
            <button\
                type="button"\
                tabindex="-1"\
                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"\
                ng-click="$mdAutocompleteCtrl.clear()">\
              <md-icon md-svg-icon="md-close"></md-icon>\
              <span class="md-visually-hidden">Clear</span>\
            </button>\
                ';
                }
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective);
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
          return {
            restrict: 'AE',
            compile: compile,
            terminal: true,
            transclude: 'element'
          };
          function compile(tElement, tAttr, transclude) {
            return function postLink(scope, element, attr) {
              var ctrl = scope.$mdAutocompleteCtrl;
              var newScope = ctrl.parent.$new();
              var itemName = ctrl.itemName;
              watchVariable('$index', '$index');
              watchVariable('item', itemName);
              connectScopes();
              transclude(newScope, function(clone) {
                element.after(clone);
              });
              function watchVariable(variable, alias) {
                newScope[alias] = scope[variable];
                scope.$watch(variable, function(value) {
                  $mdUtil.nextTick(function() {
                    newScope[alias] = value;
                  });
                });
              }
              function connectScopes() {
                var scopeDigesting = false;
                var newScopeDigesting = false;
                scope.$watch(function() {
                  if (newScopeDigesting || scopeDigesting) {
                    return;
                  }
                  scopeDigesting = true;
                  scope.$$postDigest(function() {
                    if (!newScopeDigesting) {
                      newScope.$digest();
                    }
                    scopeDigesting = newScopeDigesting = false;
                  });
                });
                newScope.$watch(function() {
                  newScopeDigesting = true;
                });
              }
            };
          }
        }
        MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').controller('MdHighlightCtrl', MdHighlightCtrl);
        function MdHighlightCtrl($scope, $element, $attrs) {
          this.init = init;
          function init(termExpr, unsafeTextExpr) {
            var text = null,
                regex = null,
                flags = $attrs.mdHighlightFlags || '',
                watcher = $scope.$watch(function($scope) {
                  return {
                    term: termExpr($scope),
                    unsafeText: unsafeTextExpr($scope)
                  };
                }, function(state, prevState) {
                  if (text === null || state.unsafeText !== prevState.unsafeText) {
                    text = angular.element('<div>').text(state.unsafeText).html();
                  }
                  if (regex === null || state.term !== prevState.term) {
                    regex = getRegExp(state.term, flags);
                  }
                  $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, true);
            $element.on('$destroy', watcher);
          }
          function sanitize(term) {
            return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, '\\$&');
          }
          function getRegExp(text, flags) {
            var str = '';
            if (flags.indexOf('^') >= 1)
              str += '^';
            str += text;
            if (flags.indexOf('$') >= 1)
              str += '$';
            return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, ''));
          }
        }
        MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.autocomplete').directive('mdHighlightText', MdHighlight);
        function MdHighlight($interpolate, $parse) {
          return {
            terminal: true,
            controller: 'MdHighlightCtrl',
            compile: function mdHighlightCompile(tElement, tAttr) {
              var termExpr = $parse(tAttr.mdHighlightText);
              var unsafeTextExpr = $interpolate(tElement.html());
              return function mdHighlightLink(scope, element, attr, ctrl) {
                ctrl.init(termExpr, unsafeTextExpr);
              };
            }
          };
        }
        MdHighlight.$inject = ["$interpolate", "$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChip', MdChip);
        var DELETE_HINT_TEMPLATE = '\
    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">\
      {{$mdChipsCtrl.deleteHint}}\
    </span>';
        function MdChip($mdTheming, $mdUtil) {
          var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
          return {
            restrict: 'E',
            require: '^?mdChips',
            compile: compile
          };
          function compile(element, attr) {
            element.append($mdUtil.processTemplate(hintTemplate));
            return function postLink(scope, element, attr, ctrl) {
              element.addClass('md-chip');
              $mdTheming(element);
              if (ctrl)
                angular.element(element[0].querySelector('.md-chip-content')).on('blur', function() {
                  ctrl.selectedChip = -1;
                });
            };
          }
        }
        MdChip.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipRemove', MdChipRemove);
        function MdChipRemove($timeout) {
          return {
            restrict: 'A',
            require: '^mdChips',
            scope: false,
            link: postLink
          };
          function postLink(scope, element, attr, ctrl) {
            element.on('click', function(event) {
              scope.$apply(function() {
                ctrl.removeChip(scope.$$replacedScope.$index);
              });
            });
            $timeout(function() {
              element.attr({
                tabindex: -1,
                'aria-hidden': true
              });
              element.find('button').attr('tabindex', '-1');
            });
          }
        }
        MdChipRemove.$inject = ["$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChipTransclude', MdChipTransclude);
        function MdChipTransclude($compile) {
          return {
            restrict: 'EA',
            terminal: true,
            link: link,
            scope: false
          };
          function link(scope, element, attr) {
            var ctrl = scope.$parent.$mdChipsCtrl,
                newScope = ctrl.parent.$new(false, ctrl.parent);
            newScope.$$replacedScope = scope;
            newScope.$chip = scope.$chip;
            newScope.$index = scope.$index;
            newScope.$mdChipsCtrl = ctrl;
            var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
            element.html(newHtml);
            $compile(element.contents())(newScope);
          }
        }
        MdChipTransclude.$inject = ["$compile"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdChipsCtrl', MdChipsCtrl);
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout) {
          this.$timeout = $timeout;
          this.$mdConstant = $mdConstant;
          this.$scope = $scope;
          this.parent = $scope.$parent;
          this.$log = $log;
          this.$element = $element;
          this.ngModelCtrl = null;
          this.userInputNgModelCtrl = null;
          this.userInputElement = null;
          this.items = [];
          this.selectedChip = -1;
          this.hasAutocomplete = false;
          this.deleteHint = 'Press delete to remove this chip.';
          this.deleteButtonLabel = 'Remove';
          this.chipBuffer = '';
          this.useOnAppend = false;
          this.useTransformChip = false;
          this.useOnAdd = false;
          this.useOnRemove = false;
          this.useOnSelect = false;
        }
        MdChipsCtrl.$inject = ["$scope", "$mdConstant", "$log", "$element", "$timeout"];
        MdChipsCtrl.prototype.inputKeydown = function(event) {
          var chipBuffer = this.getChipBuffer();
          if (this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented()) {
            return;
          }
          if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
            if (chipBuffer)
              return;
            event.preventDefault();
            event.stopPropagation();
            if (this.items.length)
              this.selectAndFocusChipSafe(this.items.length - 1);
            return;
          }
          if (!this.separatorKeys || this.separatorKeys.length < 1) {
            this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
          }
          if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
            if ((this.hasAutocomplete && this.requireMatch) || !chipBuffer)
              return;
            event.preventDefault();
            this.appendChip(chipBuffer);
            this.resetChipBuffer();
          }
        };
        MdChipsCtrl.prototype.chipKeydown = function(event) {
          if (this.getChipBuffer())
            return;
          switch (event.keyCode) {
            case this.$mdConstant.KEY_CODE.BACKSPACE:
            case this.$mdConstant.KEY_CODE.DELETE:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.removeAndSelectAdjacentChip(this.selectedChip);
              break;
            case this.$mdConstant.KEY_CODE.LEFT_ARROW:
              event.preventDefault();
              if (this.selectedChip < 0)
                this.selectedChip = this.items.length;
              if (this.items.length)
                this.selectAndFocusChipSafe(this.selectedChip - 1);
              break;
            case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
              event.preventDefault();
              this.selectAndFocusChipSafe(this.selectedChip + 1);
              break;
            case this.$mdConstant.KEY_CODE.ESCAPE:
            case this.$mdConstant.KEY_CODE.TAB:
              if (this.selectedChip < 0)
                return;
              event.preventDefault();
              this.onFocus();
              break;
          }
        };
        MdChipsCtrl.prototype.getPlaceholder = function() {
          var useSecondary = (this.items.length && (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));
          return useSecondary ? this.secondaryPlaceholder : this.placeholder;
        };
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
          var selIndex = this.getAdjacentChipIndex(index);
          this.removeChip(index);
          this.$timeout(angular.bind(this, function() {
            this.selectAndFocusChipSafe(selIndex);
          }));
        };
        MdChipsCtrl.prototype.resetSelectedChip = function() {
          this.selectedChip = -1;
        };
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
          var len = this.items.length - 1;
          return (len == 0) ? -1 : (index == len) ? index - 1 : index;
        };
        MdChipsCtrl.prototype.appendChip = function(newChip) {
          if (this.useTransformChip && this.transformChip) {
            var transformedChip = this.transformChip({'$chip': newChip});
            if (angular.isDefined(transformedChip)) {
              newChip = transformedChip;
            }
          }
          if (angular.isObject(newChip)) {
            var identical = this.items.some(function(item) {
              return angular.equals(newChip, item);
            });
            if (identical)
              return;
          }
          if (newChip == null || this.items.indexOf(newChip) + 1)
            return;
          var index = this.items.push(newChip);
          if (this.useOnAdd && this.onAdd) {
            this.onAdd({
              '$chip': newChip,
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.useOnAppendExpression = function() {
          this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");
          if (!this.useTransformChip || !this.transformChip) {
            this.useTransformChip = true;
            this.transformChip = this.onAppend;
          }
        };
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
          this.useTransformChip = true;
        };
        MdChipsCtrl.prototype.useOnAddExpression = function() {
          this.useOnAdd = true;
        };
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
          this.useOnRemove = true;
        };
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
          this.useOnSelect = true;
        };
        MdChipsCtrl.prototype.getChipBuffer = function() {
          return !this.userInputElement ? this.chipBuffer : this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value;
        };
        MdChipsCtrl.prototype.resetChipBuffer = function() {
          if (this.userInputElement) {
            if (this.userInputNgModelCtrl) {
              this.userInputNgModelCtrl.$setViewValue('');
              this.userInputNgModelCtrl.$render();
            } else {
              this.userInputElement[0].value = '';
            }
          } else {
            this.chipBuffer = '';
          }
        };
        MdChipsCtrl.prototype.removeChip = function(index) {
          var removed = this.items.splice(index, 1);
          if (removed && removed.length && this.useOnRemove && this.onRemove) {
            this.onRemove({
              '$chip': removed[0],
              '$index': index
            });
          }
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
          this.removeChip(index);
          this.onFocus();
        };
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
          if (!this.items.length) {
            this.selectChip(-1);
            this.onFocus();
            return;
          }
          if (index === this.items.length)
            return this.onFocus();
          index = Math.max(index, 0);
          index = Math.min(index, this.items.length - 1);
          this.selectChip(index);
          this.focusChip(index);
        };
        MdChipsCtrl.prototype.selectChip = function(index) {
          if (index >= -1 && index <= this.items.length) {
            this.selectedChip = index;
            if (this.useOnSelect && this.onSelect) {
              this.onSelect({'$chip': this.items[this.selectedChip]});
            }
          } else {
            this.$log.warn('Selected Chip index out of bounds; ignoring.');
          }
        };
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
          this.selectChip(index);
          if (index != -1) {
            this.focusChip(index);
          }
        };
        MdChipsCtrl.prototype.focusChip = function(index) {
          this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content').focus();
        };
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
          this.ngModelCtrl = ngModelCtrl;
          var self = this;
          ngModelCtrl.$render = function() {
            self.items = self.ngModelCtrl.$viewValue;
          };
        };
        MdChipsCtrl.prototype.onFocus = function() {
          var input = this.$element[0].querySelector('input');
          input && input.focus();
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
          this.inputHasFocus = true;
          this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
          this.inputHasFocus = false;
        };
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
          this.userInputElement = inputElement;
          var ngModelCtrl = inputElement.controller('ngModel');
          if (ngModelCtrl != this.ngModelCtrl) {
            this.userInputNgModelCtrl = ngModelCtrl;
          }
          var scope = this.$scope;
          var ctrl = this;
          var scopeApplyFn = function(event, fn) {
            scope.$evalAsync(angular.bind(ctrl, fn, event));
          };
          inputElement.attr({tabindex: 0}).on('keydown', function(event) {
            scopeApplyFn(event, ctrl.inputKeydown);
          }).on('focus', function(event) {
            scopeApplyFn(event, ctrl.onInputFocus);
          }).on('blur', function(event) {
            scopeApplyFn(event, ctrl.onInputBlur);
          });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
          if (ctrl) {
            this.hasAutocomplete = true;
            ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
              if (item) {
                this.appendChip(item);
                this.resetChipBuffer();
              }
            }));
            this.$element.find('input').on('focus', angular.bind(this, this.onInputFocus)).on('blur', angular.bind(this, this.onInputBlur));
          }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
          return this.inputHasFocus || this.selectedChip >= 0;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdChips', MdChips);
        var MD_CHIPS_TEMPLATE = '\
      <md-chips-wrap\
          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"\
          ng-keydown="$mdChipsCtrl.chipKeydown($event)"\
          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"\
          class="md-chips">\
        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\
            index="{{$index}}"\
            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">\
          <div class="md-chip-content"\
              tabindex="-1"\
              aria-hidden="true"\
              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\
              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\
          <div ng-if="!$mdChipsCtrl.readonly"\
               class="md-chip-remove-container"\
               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\
        </md-chip>\
        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"\
            class="md-chip-input-container"\
            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\
        </div>\
      </md-chips-wrap>';
        var CHIP_INPUT_TEMPLATE = '\
        <input\
            class="md-input"\
            tabindex="0"\
            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\
            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"\
            ng-model="$mdChipsCtrl.chipBuffer"\
            ng-focus="$mdChipsCtrl.onInputFocus()"\
            ng-blur="$mdChipsCtrl.onInputBlur()"\
            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';
        var CHIP_DEFAULT_TEMPLATE = '\
      <span>{{$chip}}</span>';
        var CHIP_REMOVE_TEMPLATE = '\
      <button\
          class="md-chip-remove"\
          ng-if="!$mdChipsCtrl.readonly"\
          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"\
          type="button"\
          aria-hidden="true"\
          tabindex="-1">\
        <md-icon md-svg-icon="md-close"></md-icon>\
        <span class="md-visually-hidden">\
          {{$mdChipsCtrl.deleteButtonLabel}}\
        </span>\
      </button>';
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout) {
          var templates = getTemplates();
          return {
            template: function(element, attrs) {
              attrs['$mdUserTemplate'] = element.clone();
              return templates.chips;
            },
            require: ['mdChips'],
            restrict: 'E',
            controller: 'MdChipsCtrl',
            controllerAs: '$mdChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              readonly: '=readonly',
              placeholder: '@',
              secondaryPlaceholder: '@',
              transformChip: '&mdTransformChip',
              onAppend: '&mdOnAppend',
              onAdd: '&mdOnAdd',
              onRemove: '&mdOnRemove',
              onSelect: '&mdOnSelect',
              deleteHint: '@',
              deleteButtonLabel: '@',
              separatorKeys: '=?mdSeparatorKeys',
              requireMatch: '=?mdRequireMatch'
            }
          };
          function compile(element, attr) {
            var userTemplate = attr['$mdUserTemplate'];
            attr['$mdUserTemplate'] = null;
            var chipRemoveTemplate = getTemplateByQuery('md-chips>*[md-chip-remove]') || templates.remove,
                chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || templates.default,
                chipInputTemplate = getTemplateByQuery('md-chips>md-autocomplete') || getTemplateByQuery('md-chips>input') || templates.input,
                staticChips = userTemplate.find('md-chip');
            if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {
              $log.warn('invalid placement of md-chip-remove within md-chip-template.');
            }
            function getTemplateByQuery(query) {
              if (!attr.ngModel)
                return;
              var element = userTemplate[0].querySelector(query);
              return element && element.outerHTML;
            }
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              var mdChipsCtrl = controllers[0];
              mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
              mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
              mdChipsCtrl.chipInputTemplate = chipInputTemplate;
              element.attr({
                'aria-hidden': true,
                tabindex: -1
              }).on('focus', function() {
                mdChipsCtrl.onFocus();
              });
              if (attr.ngModel) {
                mdChipsCtrl.configureNgModel(element.controller('ngModel'));
                if (attrs.mdTransformChip)
                  mdChipsCtrl.useTransformChipExpression();
                if (attrs.mdOnAppend)
                  mdChipsCtrl.useOnAppendExpression();
                if (attrs.mdOnAdd)
                  mdChipsCtrl.useOnAddExpression();
                if (attrs.mdOnRemove)
                  mdChipsCtrl.useOnRemoveExpression();
                if (attrs.mdOnSelect)
                  mdChipsCtrl.useOnSelectExpression();
                if (chipInputTemplate != templates.input) {
                  scope.$watch('$mdChipsCtrl.readonly', function(readonly) {
                    if (!readonly) {
                      $mdUtil.nextTick(function() {
                        if (chipInputTemplate.indexOf('<md-autocomplete') === 0)
                          mdChipsCtrl.configureAutocomplete(element.find('md-autocomplete').controller('mdAutocomplete'));
                        mdChipsCtrl.configureUserInput(element.find('input'));
                      });
                    }
                  });
                }
                $mdUtil.nextTick(function() {
                  var input = element.find('input');
                  input && input.toggleClass('md-input', true);
                });
              }
              if (staticChips.length > 0) {
                var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                $timeout(function() {
                  element.find('md-chips-wrap').prepend(compiledStaticChips);
                });
              }
            };
          }
          function getTemplates() {
            return {
              chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
              input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
              default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
              remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
            };
          }
        }
        MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').controller('MdContactChipsCtrl', MdContactChipsCtrl);
        function MdContactChipsCtrl() {
          this.selectedItem = null;
          this.searchText = '';
        }
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
          var results = this.contactQuery({'$query': searchText});
          return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
          return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
          return this.contacts.indexOf(contact) == -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.chips').directive('mdContactChips', MdContactChips);
        var MD_CONTACT_CHIPS_TEMPLATE = '\
      <md-chips class="md-contact-chips"\
          ng-model="$mdContactChipsCtrl.contacts"\
          md-require-match="$mdContactChipsCtrl.requireMatch"\
          md-autocomplete-snap>\
          <md-autocomplete\
              md-menu-class="md-contact-chips-suggestions"\
              md-selected-item="$mdContactChipsCtrl.selectedItem"\
              md-search-text="$mdContactChipsCtrl.searchText"\
              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\
              md-item-text="$mdContactChipsCtrl.itemName(item)"\
              md-no-cache="true"\
              md-autoselect\
              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?\
                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\
            <div class="md-contact-suggestion">\
              <img \
                  ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{item[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="item[$mdContactChipsCtrl.contactImage]" />\
              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\
                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\
                {{item[$mdContactChipsCtrl.contactName]}}\
              </span>\
              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\
            </div>\
          </md-autocomplete>\
          <md-chip-template>\
            <div class="md-contact-avatar">\
              <img \
                  ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\
            </div>\
            <div class="md-contact-name">\
              {{$chip[$mdContactChipsCtrl.contactName]}}\
            </div>\
          </md-chip-template>\
      </md-chips>';
        function MdContactChips($mdTheming, $mdUtil) {
          return {
            template: function(element, attrs) {
              return MD_CONTACT_CHIPS_TEMPLATE;
            },
            restrict: 'E',
            controller: 'MdContactChipsCtrl',
            controllerAs: '$mdContactChipsCtrl',
            bindToController: true,
            compile: compile,
            scope: {
              contactQuery: '&mdContacts',
              placeholder: '@',
              secondaryPlaceholder: '@',
              contactName: '@mdContactName',
              contactImage: '@mdContactImage',
              contactEmail: '@mdContactEmail',
              contacts: '=ngModel',
              requireMatch: '=?mdRequireMatch',
              highlightFlags: '@?mdHighlightFlags'
            }
          };
          function compile(element, attr) {
            return function postLink(scope, element, attrs, controllers) {
              $mdUtil.initOptionalProperties(scope, attr);
              $mdTheming(element);
              element.attr('tabindex', '-1');
            };
          }
        }
        MdContactChips.$inject = ["$mdTheming", "$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', mdIconDirective]);
        function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
          return {
            scope: {
              fontSet: '@mdFontSet',
              fontIcon: '@mdFontIcon',
              svgIcon: '@mdSvgIcon',
              svgSrc: '@mdSvgSrc'
            },
            restrict: 'E',
            link: postLink
          };
          function postLink(scope, element, attr) {
            $mdTheming(element);
            prepareForFontIcon();
            var label = attr.alt || scope.fontIcon || scope.svgIcon || element.text();
            var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');
            if (!attr['aria-label']) {
              if (label != '' && !parentsHaveText()) {
                $mdAria.expect(element, 'aria-label', label);
                $mdAria.expect(element, 'role', 'img');
              } else if (!element.text()) {
                $mdAria.expect(element, 'aria-hidden', 'true');
              }
            }
            if (attrName) {
              attr.$observe(attrName, function(attrVal) {
                element.empty();
                if (attrVal) {
                  $mdIcon(attrVal).then(function(svg) {
                    element.empty();
                    element.append(svg);
                  });
                }
              });
            }
            function parentsHaveText() {
              var parent = element.parent();
              if (parent.attr('aria-label') || parent.text()) {
                return true;
              } else if (parent.parent().attr('aria-label') || parent.parent().text()) {
                return true;
              }
              return false;
            }
            function prepareForFontIcon() {
              if (!scope.svgIcon && !scope.svgSrc) {
                if (scope.fontIcon) {
                  element.addClass('md-font ' + scope.fontIcon);
                }
                element.addClass($mdIcon.fontSet(scope.fontSet));
              }
            }
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.icon').provider('$mdIcon', MdIconProvider);
        var config = {
          defaultViewBoxSize: 24,
          defaultFontSet: 'material-icons',
          fontSets: []
        };
        function MdIconProvider() {}
        MdIconProvider.prototype = {
          icon: function(id, url, viewBoxSize) {
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          iconSet: function(id, url, viewBoxSize) {
            config[id] = new ConfigurationItem(url, viewBoxSize);
            return this;
          },
          defaultIconSet: function(url, viewBoxSize) {
            var setName = '$default';
            if (!config[setName]) {
              config[setName] = new ConfigurationItem(url, viewBoxSize);
            }
            config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
            return this;
          },
          defaultViewBoxSize: function(viewBoxSize) {
            config.defaultViewBoxSize = viewBoxSize;
            return this;
          },
          fontSet: function fontSet(alias, className) {
            config.fontSets.push({
              alias: alias,
              fontSet: className || alias
            });
            return this;
          },
          defaultFontSet: function defaultFontSet(className) {
            config.defaultFontSet = !className ? '' : className;
            return this;
          },
          defaultIconSize: function defaultIconSize(iconSize) {
            config.defaultIconSize = iconSize;
            return this;
          },
          preloadIcons: function($templateCache) {
            var iconProvider = this;
            var svgRegistry = [{
              id: 'md-tabs-arrow',
              url: 'md-tabs-arrow.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
            }, {
              id: 'md-close',
              url: 'md-close.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
            }, {
              id: 'md-cancel',
              url: 'md-cancel.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
            }, {
              id: 'md-menu',
              url: 'md-menu.svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>'
            }, {
              id: 'md-toggle-arrow',
              url: 'md-toggle-arrow-svg',
              svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>'
            }, {
              id: 'md-calendar',
              url: 'md-calendar.svg',
              svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>'
            }];
            svgRegistry.forEach(function(asset) {
              iconProvider.icon(asset.id, asset.url);
              $templateCache.put(asset.url, asset.svg);
            });
          },
          $get: ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {
            this.preloadIcons($templateCache);
            return MdIconService(config, $http, $q, $log, $templateCache);
          }]
        };
        function ConfigurationItem(url, viewBoxSize) {
          this.url = url;
          this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        function MdIconService(config, $http, $q, $log, $templateCache) {
          var iconCache = {};
          var urlRegex = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i;
          Icon.prototype = {
            clone: cloneSVG,
            prepare: prepareAndStyle
          };
          getIcon.fontSet = findRegisteredFontSet;
          return getIcon;
          function getIcon(id) {
            id = id || '';
            if (iconCache[id])
              return $q.when(iconCache[id].clone());
            if (urlRegex.test(id))
              return loadByURL(id).then(cacheIcon(id));
            if (id.indexOf(':') == -1)
              id = '$default:' + id;
            var load = config[id] ? loadByID : loadFromIconSet;
            return load(id).then(cacheIcon(id));
          }
          function findRegisteredFontSet(alias) {
            var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
            if (useDefault)
              return config.defaultFontSet;
            var result = alias;
            angular.forEach(config.fontSets, function(it) {
              if (it.alias == alias)
                result = it.fontSet || result;
            });
            return result;
          }
          function cacheIcon(id) {
            return function updateCache(icon) {
              iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
              return iconCache[id].clone();
            };
          }
          function loadByID(id) {
            var iconConfig = config[id];
            return loadByURL(iconConfig.url).then(function(icon) {
              return new Icon(icon, iconConfig);
            });
          }
          function loadFromIconSet(id) {
            var setName = id.substring(0, id.lastIndexOf(':')) || '$default';
            var iconSetConfig = config[setName];
            return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);
            function extractFromSet(set) {
              var iconName = id.slice(id.lastIndexOf(':') + 1);
              var icon = set.querySelector('#' + iconName);
              return !icon ? announceIdNotFound(id) : new Icon(icon, iconSetConfig);
            }
            function announceIdNotFound(id) {
              var msg = 'icon ' + id + ' not found';
              $log.warn(msg);
              return $q.reject(msg || id);
            }
          }
          function loadByURL(url) {
            return $http.get(url, {cache: $templateCache}).then(function(response) {
              return angular.element('<div>').append(response.data).find('svg')[0];
            }).catch(announceNotFound);
          }
          function announceNotFound(err) {
            var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);
            $log.warn(msg);
            return $q.reject(msg);
          }
          function isIcon(target) {
            return angular.isDefined(target.element) && angular.isDefined(target.config);
          }
          function Icon(el, config) {
            if (el && el.tagName != 'svg') {
              el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0];
            }
            if (!el.getAttribute('xmlns')) {
              el.setAttribute('xmlns', "http://www.w3.org/2000/svg");
            }
            this.element = el;
            this.config = config;
            this.prepare();
          }
          function prepareAndStyle() {
            var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
            angular.forEach({
              'fit': '',
              'height': '100%',
              'width': '100%',
              'preserveAspectRatio': 'xMidYMid meet',
              'viewBox': this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize)
            }, function(val, attr) {
              this.element.setAttribute(attr, val);
            }, this);
          }
          function cloneSVG() {
            return this.element.cloneNode(true);
          }
        }
        MdIconService.$inject = ["config", "$http", "$q", "$log", "$templateCache"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuBarController', MenuBarController);
        var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen'];
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$mdConstant = $mdConstant;
          this.$mdUtil = $mdUtil;
          this.$document = $document;
          this.$scope = $scope;
          this.$rootScope = $rootScope;
          this.$timeout = $timeout;
          var self = this;
          angular.forEach(BOUND_MENU_METHODS, function(methodName) {
            self[methodName] = angular.bind(self, self[methodName]);
          });
        }
        MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
        MenuBarController.prototype.init = function() {
          var $element = this.$element;
          var $mdUtil = this.$mdUtil;
          var $scope = this.$scope;
          var self = this;
          var deregisterFns = [];
          $element.on('keydown', this.handleKeyDown);
          this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR');
          deregisterFns.push(this.$rootScope.$on('$mdMenuOpen', function(event, el) {
            if (self.getMenus().indexOf(el[0]) != -1) {
              $element[0].classList.add('md-open');
              el[0].classList.add('md-open');
              self.currentlyOpenMenu = el.controller('mdMenu');
              self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
              self.enableOpenOnHover();
            }
          }));
          deregisterFns.push(this.$rootScope.$on('$mdMenuClose', function(event, el, opts) {
            var rootMenus = self.getMenus();
            if (rootMenus.indexOf(el[0]) != -1) {
              $element[0].classList.remove('md-open');
              el[0].classList.remove('md-open');
            }
            if ($element[0].contains(el[0])) {
              var parentMenu = el[0];
              while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {
                parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);
              }
              if (parentMenu) {
                if (!opts.skipFocus)
                  parentMenu.querySelector('button:not([disabled])').focus();
                self.currentlyOpenMenu = undefined;
                self.disableOpenOnHover();
                self.setKeyboardMode(true);
              }
            }
          }));
          $scope.$on('$destroy', function() {
            while (deregisterFns.length) {
              deregisterFns.shift()();
            }
          });
          this.setKeyboardMode(true);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
          if (enabled)
            this.$element[0].classList.add('md-keyboard-mode');
          else
            this.$element[0].classList.remove('md-keyboard-mode');
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
          if (this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = true;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute('style');
            parentToolbar.style.position = 'relative';
            parentToolbar.style.zIndex = 100;
          }
          angular.element(this.getMenus()).on('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
          this.setKeyboardMode(false);
          if (this.openOnHoverEnabled) {
            this.scheduleOpenHoveredMenu(e);
          }
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
          if (!this.openOnHoverEnabled)
            return;
          this.openOnHoverEnabled = false;
          var parentToolbar;
          if (parentToolbar = this.parentToolbar) {
            parentToolbar.style.cssText = parentToolbar.dataset.mdRestoreStyle || '';
          }
          angular.element(this.getMenus()).off('mouseenter', this.handleMenuHover);
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
          var menuEl = angular.element(e.currentTarget);
          var menuCtrl = menuEl.controller('mdMenu');
          this.setKeyboardMode(false);
          this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
          var self = this;
          var $timeout = this.$timeout;
          if (menuCtrl != self.currentlyOpenMenu) {
            $timeout.cancel(self.pendingMenuOpen);
            self.pendingMenuOpen = $timeout(function() {
              self.pendingMenuOpen = undefined;
              if (self.currentlyOpenMenu) {
                self.currentlyOpenMenu.close(true, {closeAll: true});
              }
              menuCtrl.open();
            }, 200, false);
          }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
          var keyCodes = this.$mdConstant.KEY_CODE;
          var currentMenu = this.currentlyOpenMenu;
          var wasOpen = currentMenu && currentMenu.isOpen;
          this.setKeyboardMode(true);
          var handled,
              newMenu,
              newMenuCtrl;
          switch (e.keyCode) {
            case keyCodes.DOWN_ARROW:
              if (currentMenu) {
                currentMenu.focusMenuContainer();
              } else {
                this.openFocusedMenu();
              }
              handled = true;
              break;
            case keyCodes.UP_ARROW:
              currentMenu && currentMenu.close();
              handled = true;
              break;
            case keyCodes.LEFT_ARROW:
              newMenu = this.focusMenu(-1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
            case keyCodes.RIGHT_ARROW:
              newMenu = this.focusMenu(+1);
              if (wasOpen) {
                newMenuCtrl = angular.element(newMenu).controller('mdMenu');
                this.scheduleOpenMenu(newMenuCtrl);
              }
              handled = true;
              break;
          }
          if (handled) {
            e && e.preventDefault && e.preventDefault();
            e && e.stopImmediatePropagation && e.stopImmediatePropagation();
          }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
          var menus = this.getMenus();
          var focusedIndex = this.getFocusedMenuIndex();
          if (focusedIndex == -1) {
            focusedIndex = this.getOpenMenuIndex();
          }
          var changed = false;
          if (focusedIndex == -1) {
            focusedIndex = 0;
          } else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
            focusedIndex += direction;
            changed = true;
          }
          if (changed) {
            menus[focusedIndex].querySelector('button').focus();
            return menus[focusedIndex];
          }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
          var menu = this.getFocusedMenu();
          menu && angular.element(menu).controller('mdMenu').open();
        };
        MenuBarController.prototype.getMenus = function() {
          var $element = this.$element;
          return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
            return el.nodeName == 'MD-MENU';
          });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
          return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
          var $mdUtil = this.$mdUtil;
          var focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, 'MD-MENU');
          if (!focusedEl)
            return -1;
          var focusedIndex = this.getMenus().indexOf(focusedEl);
          return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
          var menus = this.getMenus();
          for (var i = 0; i < menus.length; ++i) {
            if (menus[i].classList.contains('md-open'))
              return i;
          }
          return -1;
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuBar', MenuBarDirective);
        function MenuBarDirective($mdUtil, $mdTheming) {
          return {
            restrict: 'E',
            require: 'mdMenuBar',
            controller: 'MenuBarController',
            compile: function compile(templateEl, templateAttrs) {
              if (!templateAttrs.ariaRole) {
                templateEl[0].setAttribute('role', 'menubar');
              }
              angular.forEach(templateEl[0].children, function(menuEl) {
                if (menuEl.nodeName == 'MD-MENU') {
                  if (!menuEl.hasAttribute('md-position-mode')) {
                    menuEl.setAttribute('md-position-mode', 'left bottom');
                    menuEl.querySelector('button,a').setAttribute('role', 'menuitem');
                  }
                  var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content'));
                  angular.forEach(contentEls, function(contentEl) {
                    contentEl.classList.add('md-menu-bar-menu');
                    contentEl.classList.add('md-dense');
                    if (!contentEl.hasAttribute('width')) {
                      contentEl.setAttribute('width', 5);
                    }
                  });
                }
              });
              return function postLink(scope, el, attrs, ctrl) {
                $mdTheming(scope, el);
                ctrl.init();
              };
            }
          };
        }
        MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuDivider', MenuDividerDirective);
        function MenuDividerDirective() {
          return {
            restrict: 'E',
            compile: function(templateEl, templateAttrs) {
              if (!templateAttrs.role) {
                templateEl[0].setAttribute('role', 'separator');
              }
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').controller('MenuItemController', MenuItemController);
        function MenuItemController($scope, $element, $attrs) {
          this.$element = $element;
          this.$attrs = $attrs;
          this.$scope = $scope;
        }
        MenuItemController.$inject = ["$scope", "$element", "$attrs"];
        MenuItemController.prototype.init = function(ngModel) {
          var $element = this.$element;
          var $attrs = this.$attrs;
          this.ngModel = ngModel;
          if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {
            this.mode = $attrs.type;
            this.iconEl = $element[0].children[0];
            this.buttonEl = $element[0].children[1];
            if (ngModel) {
              this.initClickListeners();
            }
          }
        };
        MenuItemController.prototype.clearNgAria = function() {
          var el = this.$element[0];
          var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked'];
          angular.forEach(clearAttrs, function(attr) {
            el.removeAttribute(attr);
          });
        };
        MenuItemController.prototype.initClickListeners = function() {
          var self = this;
          var ngModel = this.ngModel;
          var $scope = this.$scope;
          var $attrs = this.$attrs;
          var $element = this.$element;
          var mode = this.mode;
          this.handleClick = angular.bind(this, this.handleClick);
          var icon = this.iconEl;
          var button = angular.element(this.buttonEl);
          var handleClick = this.handleClick;
          $attrs.$observe('disabled', setDisabled);
          setDisabled($attrs.disabled);
          ngModel.$render = function render() {
            self.clearNgAria();
            if (isSelected()) {
              icon.style.display = '';
              button.attr('aria-checked', 'true');
            } else {
              icon.style.display = 'none';
              button.attr('aria-checked', 'false');
            }
          };
          $scope.$$postDigest(ngModel.$render);
          function isSelected() {
            if (mode == 'radio') {
              var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
              return ngModel.$modelValue == val;
            } else {
              return ngModel.$modelValue;
            }
          }
          function setDisabled(disabled) {
            if (disabled) {
              button.off('click', handleClick);
            } else {
              button.on('click', handleClick);
            }
          }
        };
        MenuItemController.prototype.handleClick = function(e) {
          var mode = this.mode;
          var ngModel = this.ngModel;
          var $attrs = this.$attrs;
          var newVal;
          if (mode == 'checkbox') {
            newVal = !ngModel.$modelValue;
          } else if (mode == 'radio') {
            newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;
          }
          ngModel.$setViewValue(newVal);
          ngModel.$render();
        };
      })();
      (function() {
        "use strict";
        angular.module('material.components.menuBar').directive('mdMenuItem', MenuItemDirective);
        function MenuItemDirective() {
          return {
            require: ['mdMenuItem', '?ngModel'],
            priority: 210,
            compile: function(templateEl, templateAttrs) {
              if (templateAttrs.type == 'checkbox' || templateAttrs.type == 'radio') {
                var text = templateEl[0].textContent;
                var buttonEl = angular.element('<md-button type="button"></md-button>');
                buttonEl.html(text);
                buttonEl.attr('tabindex', '0');
                templateEl.html('');
                templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                templateEl.append(buttonEl);
                templateEl[0].classList.add('md-indent');
                setDefault('role', (templateAttrs.type == 'checkbox') ? 'menuitemcheckbox' : 'menuitemradio', buttonEl);
                angular.forEach(['ng-disabled'], moveAttrToButton);
              } else {
                setDefault('role', 'menuitem', templateEl[0].querySelector('md-button,button,a'));
              }
              return function(scope, el, attrs, ctrls) {
                var ctrl = ctrls[0];
                var ngModel = ctrls[1];
                ctrl.init(ngModel);
              };
              function setDefault(attr, val, el) {
                el = el || templateEl;
                if (el instanceof angular.element) {
                  el = el[0];
                }
                if (!el.hasAttribute(attr)) {
                  el.setAttribute(attr, val);
                }
              }
              function moveAttrToButton(attr) {
                if (templateEl[0].hasAttribute(attr)) {
                  var val = templateEl[0].getAttribute(attr);
                  buttonEl[0].setAttribute(attr, val);
                  templateEl[0].removeAttribute(attr);
                }
              }
            },
            controller: 'MenuItemController'
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').controller('mdMenuCtrl', MenuController);
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
          var menuContainer;
          var self = this;
          var triggerElement;
          this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
          this.init = function init(setMenuContainer, opts) {
            opts = opts || {};
            menuContainer = setMenuContainer;
            triggerElement = $element[0].querySelector('[ng-click],[ng-mouseenter]');
            triggerElement.setAttribute('aria-expanded', 'false');
            this.isInMenuBar = opts.isInMenuBar;
            this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu'));
            menuContainer.on('$mdInterimElementRemove', function() {
              self.isOpen = false;
            });
            var menuContainerId = 'menu_container_' + $mdUtil.nextUid();
            menuContainer.attr('id', menuContainerId);
            angular.element(triggerElement).attr({
              'aria-owns': menuContainerId,
              'aria-haspopup': 'true'
            });
            $scope.$on('$destroy', this.disableHoverListener);
            menuContainer.on('$destroy', function() {
              $mdMenu.destroy();
            });
          };
          var openMenuTimeout,
              menuItems,
              deregisterScopeListeners = [];
          this.enableHoverListener = function() {
            deregisterScopeListeners.push($rootScope.$on('$mdMenuOpen', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = el.controller('mdMenu');
                self.isAlreadyOpening = false;
                self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
              }
            }));
            deregisterScopeListeners.push($rootScope.$on('$mdMenuClose', function(event, el) {
              if (menuContainer[0].contains(el[0])) {
                self.currentlyOpenMenu = undefined;
              }
            }));
            menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
            menuItems.on('mouseenter', self.handleMenuItemHover);
            menuItems.on('mouseleave', self.handleMenuItemMouseLeave);
          };
          this.disableHoverListener = function() {
            while (deregisterScopeListeners.length) {
              deregisterScopeListeners.shift()();
            }
            menuItems && menuItems.off('mouseenter', self.handleMenuItemHover);
            menuItems && menuItems.off('mouseleave', self.handleMenuMouseLeave);
          };
          this.handleMenuItemHover = function(event) {
            if (self.isAlreadyOpening)
              return;
            var nestedMenu = (event.target.querySelector('md-menu') || $mdUtil.getClosest(event.target, 'MD-MENU'));
            openMenuTimeout = $timeout(function() {
              if (nestedMenu) {
                nestedMenu = angular.element(nestedMenu).controller('mdMenu');
              }
              if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                var closeTo = self.nestLevel + 1;
                self.currentlyOpenMenu.close(true, {closeTo: closeTo});
              } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                self.isAlreadyOpening = true;
                nestedMenu.open();
              }
            }, nestedMenu ? 100 : 250);
            var focusableTarget = event.currentTarget.querySelector('.md-button:not([disabled])');
            focusableTarget && focusableTarget.focus();
          };
          this.handleMenuItemMouseLeave = function() {
            if (openMenuTimeout) {
              $timeout.cancel(openMenuTimeout);
              openMenuTimeout = undefined;
            }
          };
          this.open = function openMenu(ev) {
            ev && ev.stopPropagation();
            ev && ev.preventDefault();
            if (self.isOpen)
              return;
            self.enableHoverListener();
            self.isOpen = true;
            triggerElement = triggerElement || (ev ? ev.target : $element[0]);
            triggerElement.setAttribute('aria-expanded', 'true');
            $scope.$emit('$mdMenuOpen', $element);
            $mdMenu.show({
              scope: $scope,
              mdMenuCtrl: self,
              nestLevel: self.nestLevel,
              element: menuContainer,
              target: triggerElement,
              preserveElement: true,
              parent: 'body'
            }).finally(function() {
              triggerElement.setAttribute('aria-expanded', 'false');
              self.disableHoverListener();
            });
          };
          $scope.$mdOpenMenu = this.open;
          $scope.$watch(function() {
            return self.isOpen;
          }, function(isOpen) {
            if (isOpen) {
              menuContainer.attr('aria-hidden', 'false');
              $element[0].classList.add('md-open');
              angular.forEach(self.nestedMenus, function(el) {
                el.classList.remove('md-open');
              });
            } else {
              menuContainer.attr('aria-hidden', 'true');
              $element[0].classList.remove('md-open');
            }
            $scope.$mdMenuIsOpen = self.isOpen;
          });
          this.focusMenuContainer = function focusMenuContainer() {
            var focusTarget = menuContainer[0].querySelector('[md-menu-focus-target]');
            if (!focusTarget)
              focusTarget = menuContainer[0].querySelector('.md-button');
            focusTarget.focus();
          };
          this.registerContainerProxy = function registerContainerProxy(handler) {
            this.containerProxy = handler;
          };
          this.triggerContainerProxy = function triggerContainerProxy(ev) {
            this.containerProxy && this.containerProxy(ev);
          };
          this.destroy = function() {
            return self.isOpen ? $mdMenu.destroy() : $q.when(false);
          };
          this.close = function closeMenu(skipFocus, closeOpts) {
            if (!self.isOpen)
              return;
            self.isOpen = false;
            var eventDetails = angular.extend({}, closeOpts, {skipFocus: skipFocus});
            $scope.$emit('$mdMenuClose', $element, eventDetails);
            $mdMenu.hide(null, closeOpts);
            if (!skipFocus) {
              var el = self.restoreFocusTo || $element.find('button')[0];
              if (el instanceof angular.element)
                el = el[0];
              if (el)
                el.focus();
            }
          };
          this.positionMode = function positionMode() {
            var attachment = ($attrs.mdPositionMode || 'target').split(' ');
            if (attachment.length == 1) {
              attachment.push(attachment[0]);
            }
            return {
              left: attachment[0],
              top: attachment[1]
            };
          };
          this.offsets = function offsets() {
            var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);
            if (position.length == 2) {
              return {
                left: position[0],
                top: position[1]
              };
            } else if (position.length == 1) {
              return {
                top: position[0],
                left: position[0]
              };
            } else {
              throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');
            }
          };
        }
        MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').directive('mdMenu', MenuDirective);
        function MenuDirective($mdUtil) {
          var INVALID_PREFIX = 'Invalid HTML for md-menu: ';
          return {
            restrict: 'E',
            require: ['mdMenu', '?^mdMenuBar'],
            controller: 'mdMenuCtrl',
            scope: true,
            compile: compile
          };
          function compile(templateElement) {
            templateElement.addClass('md-menu');
            var triggerElement = templateElement.children()[0];
            if (!triggerElement.hasAttribute('ng-click')) {
              triggerElement = triggerElement.querySelector('[ng-click],[ng-mouseenter]') || triggerElement;
            }
            if (triggerElement && (triggerElement.nodeName == 'MD-BUTTON' || triggerElement.nodeName == 'BUTTON') && !triggerElement.hasAttribute('type')) {
              triggerElement.setAttribute('type', 'button');
            }
            if (templateElement.children().length != 2) {
              throw Error(INVALID_PREFIX + 'Expected two children elements.');
            }
            triggerElement && triggerElement.setAttribute('aria-haspopup', 'true');
            var nestedMenus = templateElement[0].querySelectorAll('md-menu');
            var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0;
            if (nestedMenus) {
              angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                if (!menuEl.hasAttribute('md-position-mode')) {
                  menuEl.setAttribute('md-position-mode', 'cascade');
                }
                menuEl.classList.add('md-nested-menu');
                menuEl.setAttribute('md-nest-level', nestingDepth + 1);
              });
            }
            return link;
          }
          function link(scope, element, attrs, ctrls) {
            var mdMenuCtrl = ctrls[0];
            var isInMenuBar = ctrls[1] != undefined;
            var menuContainer = angular.element('<div class="md-open-menu-container md-whiteframe-z2"></div>');
            var menuContents = element.children()[1];
            if (!menuContents.hasAttribute('role')) {
              menuContents.setAttribute('role', 'menu');
            }
            menuContainer.append(menuContents);
            element.on('$destroy', function() {
              menuContainer.remove();
            });
            element.append(menuContainer);
            menuContainer[0].style.display = 'none';
            mdMenuCtrl.init(menuContainer, {isInMenuBar: isInMenuBar});
          }
        }
        MenuDirective.$inject = ["$mdUtil"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.menu').provider('$mdMenu', MenuProvider);
        function MenuProvider($$interimElementProvider) {
          var MENU_EDGE_MARGIN = 8;
          menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"];
          return $$interimElementProvider('$mdMenu').setDefaults({
            methods: ['target'],
            options: menuDefaultOptions
          });
          function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
            var animator = $mdUtil.dom.animator;
            return {
              parent: 'body',
              onShow: onShow,
              onRemove: onRemove,
              hasBackdrop: true,
              disableParentScroll: true,
              skipCompile: true,
              preserveScope: true,
              skipHide: true,
              themable: true
            };
            function showBackdrop(scope, element, options) {
              if (options.nestLevel)
                return angular.noop;
              if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
                options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
              } else {
                options.disableParentScroll = false;
              }
              if (options.hasBackdrop) {
                options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
                $animate.enter(options.backdrop, $document[0].body);
              }
              return function hideBackdrop() {
                if (options.backdrop)
                  options.backdrop.remove();
                if (options.disableParentScroll)
                  options.restoreScroll();
              };
            }
            function onRemove(scope, element, opts) {
              opts.cleanupInteraction();
              opts.cleanupResizing();
              opts.hideBackdrop();
              return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then(detachAndClean);
              function animateRemoval() {
                return $animateCss(element, {addClass: 'md-leave'}).start();
              }
              function detachAndClean() {
                element.removeClass('md-active');
                detachElement(element, opts);
                opts.alreadyOpen = false;
              }
            }
            function onShow(scope, element, opts) {
              sanitizeAndConfigure(opts);
              $mdTheming.inherit(opts.menuContentEl, opts.target);
              opts.cleanupResizing = startRepositioningOnResize();
              opts.hideBackdrop = showBackdrop(scope, element, opts);
              return showMenu().then(function(response) {
                opts.alreadyOpen = true;
                opts.cleanupInteraction = activateInteraction();
                return response;
              });
              function showMenu() {
                opts.parent.append(element);
                element[0].style.display = '';
                return $q(function(resolve) {
                  var position = calculateMenuPosition(element, opts);
                  element.removeClass('md-leave');
                  $animateCss(element, {
                    addClass: 'md-active',
                    from: animator.toCss(position),
                    to: animator.toCss({transform: ''})
                  }).start().then(resolve);
                });
              }
              function sanitizeAndConfigure() {
                if (!opts.target) {
                  throw Error('$mdMenu.show() expected a target to animate from in options.target');
                }
                angular.extend(opts, {
                  alreadyOpen: false,
                  isRemoved: false,
                  target: angular.element(opts.target),
                  parent: angular.element(opts.parent),
                  menuContentEl: angular.element(element[0].querySelector('md-menu-content'))
                });
              }
              function startRepositioningOnResize() {
                var repositionMenu = (function(target, options) {
                  return $$rAF.throttle(function() {
                    if (opts.isRemoved)
                      return;
                    var position = calculateMenuPosition(target, options);
                    target.css(animator.toCss(position));
                  });
                })(element, opts);
                $window.addEventListener('resize', repositionMenu);
                $window.addEventListener('orientationchange', repositionMenu);
                return function stopRepositioningOnResize() {
                  $window.removeEventListener('resize', repositionMenu);
                  $window.removeEventListener('orientationchange', repositionMenu);
                };
              }
              function activateInteraction() {
                element.addClass('md-clickable');
                if (opts.backdrop)
                  opts.backdrop.on('click', onBackdropClick);
                opts.menuContentEl.on('keydown', onMenuKeyDown);
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                var focusTarget = opts.menuContentEl[0].querySelector('[md-menu-focus-target]');
                if (!focusTarget) {
                  var firstChild = opts.menuContentEl[0].firstElementChild;
                  focusTarget = firstChild && (firstChild.querySelector('.md-button:not([disabled])') || firstChild.firstElementChild);
                }
                focusTarget && focusTarget.focus();
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  if (opts.backdrop)
                    opts.backdrop.off('click', onBackdropClick);
                  opts.menuContentEl.off('keydown', onMenuKeyDown);
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
                function onMenuKeyDown(ev) {
                  var handled;
                  switch (ev.keyCode) {
                    case $mdConstant.KEY_CODE.ESCAPE:
                      opts.mdMenuCtrl.close(false, {closeAll: true});
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.UP_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.DOWN_ARROW:
                      if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.LEFT_ARROW:
                      if (opts.nestLevel) {
                        opts.mdMenuCtrl.close();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                    case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU');
                      if (parentMenu && parentMenu != opts.parent[0]) {
                        ev.target.click();
                      } else {
                        opts.mdMenuCtrl.triggerContainerProxy(ev);
                      }
                      handled = true;
                      break;
                  }
                  if (handled) {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                  }
                }
                function onBackdropClick(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  scope.$apply(function() {
                    opts.mdMenuCtrl.close(true, {closeAll: true});
                  });
                }
                function captureClickListener(e) {
                  var target = e.target;
                  do {
                    if (target == opts.menuContentEl[0])
                      return;
                    if ((hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) || target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close'])) {
                      var closestMenu = $mdUtil.getClosest(target, 'MD-MENU');
                      if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {
                        close();
                      }
                      break;
                    }
                  } while (target = target.parentNode);
                  function close() {
                    scope.$apply(function() {
                      opts.mdMenuCtrl.close(true, {closeAll: true});
                    });
                  }
                  function hasAnyAttribute(target, attrs) {
                    if (!target)
                      return false;
                    for (var i = 0,
                        attr; attr = attrs[i]; ++i) {
                      var altForms = [attr, 'data-' + attr, 'x-' + attr];
                      for (var j = 0,
                          rawAttr; rawAttr = altForms[j]; ++j) {
                        if (target.hasAttribute(rawAttr)) {
                          return true;
                        }
                      }
                    }
                    return false;
                  }
                }
                opts.menuContentEl[0].addEventListener('click', captureClickListener, true);
                return function cleanupInteraction() {
                  element.removeClass('md-clickable');
                  opts.menuContentEl.off('keydown');
                  opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
                };
              }
            }
            function focusMenuItem(e, menuEl, opts, direction) {
              var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');
              var items = $mdUtil.nodesToArray(menuEl[0].children);
              var currentIndex = items.indexOf(currentItem);
              var didFocus;
              for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {
                var focusTarget = items[i].querySelector('.md-button');
                didFocus = attemptFocus(focusTarget);
                if (didFocus) {
                  break;
                }
              }
              return didFocus;
            }
            function attemptFocus(el) {
              if (el && el.getAttribute('tabindex') != -1) {
                el.focus();
                return ($document[0].activeElement == el);
              }
            }
            function detachElement(element, opts) {
              if (!opts.preserveElement) {
                if (toNode(element).parentNode === toNode(opts.parent)) {
                  toNode(opts.parent).removeChild(toNode(element));
                }
              } else {
                toNode(element).style.display = 'none';
              }
            }
            function calculateMenuPosition(el, opts) {
              var containerNode = el[0],
                  openMenuNode = el[0].firstElementChild,
                  openMenuNodeRect = openMenuNode.getBoundingClientRect(),
                  boundryNode = $document[0].body,
                  boundryNodeRect = boundryNode.getBoundingClientRect();
              var menuStyle = $window.getComputedStyle(openMenuNode);
              var originNode = opts.target[0].querySelector('[md-menu-origin]') || opts.target[0],
                  originNodeRect = originNode.getBoundingClientRect();
              var bounds = {
                left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                right: boundryNodeRect.right - MENU_EDGE_MARGIN
              };
              var alignTarget,
                  alignTargetRect = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  },
                  existingOffsets = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                  };
              var positionMode = opts.mdMenuCtrl.positionMode();
              if (positionMode.top == 'target' || positionMode.left == 'target' || positionMode.left == 'target-right') {
                alignTarget = firstVisibleChild();
                if (alignTarget) {
                  alignTarget = alignTarget.firstElementChild || alignTarget;
                  alignTarget = alignTarget.querySelector('[md-menu-align-target]') || alignTarget;
                  alignTargetRect = alignTarget.getBoundingClientRect();
                  existingOffsets = {
                    top: parseFloat(containerNode.style.top || 0),
                    left: parseFloat(containerNode.style.left || 0)
                  };
                }
              }
              var position = {};
              var transformOrigin = 'top ';
              switch (positionMode.top) {
                case 'target':
                  position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                  break;
                case 'cascade':
                  position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                  break;
                case 'bottom':
                  position.top = originNodeRect.top + originNodeRect.height;
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
              }
              switch (positionMode.left) {
                case 'target':
                  position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                  transformOrigin += 'left';
                  break;
                case 'target-right':
                  position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                  transformOrigin += 'right';
                  break;
                case 'cascade':
                  var willFitRight = (originNodeRect.right + openMenuNodeRect.width) < bounds.right;
                  position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                  transformOrigin += willFitRight ? 'left' : 'right';
                  break;
                case 'left':
                  position.left = originNodeRect.left;
                  transformOrigin += 'left';
                  break;
                default:
                  throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
              }
              var offsets = opts.mdMenuCtrl.offsets();
              position.top += offsets.top;
              position.left += offsets.left;
              clamp(position);
              var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
              var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;
              return {
                top: Math.round(position.top),
                left: Math.round(position.left),
                transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined,
                transformOrigin: transformOrigin
              };
              function clamp(pos) {
                pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
              }
              function firstVisibleChild() {
                for (var i = 0; i < openMenuNode.children.length; ++i) {
                  if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {
                    return openMenuNode.children[i];
                  }
                }
              }
            }
          }
          function toNode(el) {
            if (el instanceof angular.element) {
              el = el[0];
            }
            return el;
          }
        }
        MenuProvider.$inject = ["$$interimElementProvider"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTab', MdTab);
        function MdTab() {
          return {
            require: '^?mdTabs',
            terminal: true,
            compile: function(element, attr) {
              var label = firstChild(element, 'md-tab-label'),
                  body = firstChild(element, 'md-tab-body');
              if (label.length == 0) {
                label = angular.element('<md-tab-label></md-tab-label>');
                if (attr.label)
                  label.text(attr.label);
                else
                  label.append(element.contents());
                if (body.length == 0) {
                  var contents = element.contents().detach();
                  body = angular.element('<md-tab-body></md-tab-body>');
                  body.append(contents);
                }
              }
              element.append(label);
              if (body.html())
                element.append(body);
              return postLink;
            },
            scope: {
              active: '=?mdActive',
              disabled: '=?ngDisabled',
              select: '&?mdOnSelect',
              deselect: '&?mdOnDeselect'
            }
          };
          function postLink(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var index = ctrl.getTabElementIndex(element),
                body = firstChild(element, 'md-tab-body').remove(),
                label = firstChild(element, 'md-tab-label').remove(),
                data = ctrl.insertTab({
                  scope: scope,
                  parent: scope.$parent,
                  index: index,
                  element: element,
                  template: body.html(),
                  label: label.html()
                }, index);
            scope.select = scope.select || angular.noop;
            scope.deselect = scope.deselect || angular.noop;
            scope.$watch('active', function(active) {
              if (active)
                ctrl.select(data.getIndex());
            });
            scope.$watch('disabled', function() {
              ctrl.refreshIndex();
            });
            scope.$watch(function() {
              return ctrl.getTabElementIndex(element);
            }, function(newIndex) {
              data.index = newIndex;
              ctrl.updateTabOrder();
            });
            scope.$on('$destroy', function() {
              ctrl.removeTab(data);
            });
          }
          function firstChild(element, tagName) {
            var children = element[0].children;
            for (var i = 0,
                len = children.length; i < len; i++) {
              var child = children[i];
              if (child.tagName === tagName.toUpperCase())
                return angular.element(child);
            }
            return angular.element();
          }
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabItem', MdTabItem);
        function MdTabItem() {
          return {
            require: '^?mdTabs',
            link: function link(scope, element, attr, ctrl) {
              if (!ctrl)
                return;
              ctrl.attachRipple(scope, element);
            }
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabLabel', MdTabLabel);
        function MdTabLabel() {
          return {terminal: true};
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabScroll', MdTabScroll);
        function MdTabScroll($parse) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr.mdTabScroll, null, true);
              return function ngEventHandler(scope, element) {
                element.on('mousewheel', function(event) {
                  scope.$apply(function() {
                    fn(scope, {$event: event});
                  });
                });
              };
            }
          };
        }
        MdTabScroll.$inject = ["$parse"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').controller('MdTabsController', MdTabsController);
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
          var ctrl = this,
              locked = false,
              elements = getElements(),
              queue = [],
              destroyed = false,
              loaded = false;
          defineOneWayBinding('stretchTabs', handleStretchTabs);
          defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0);
          defineProperty('offsetLeft', handleOffsetChange, 0);
          defineProperty('hasContent', handleHasContent, false);
          defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth());
          defineProperty('shouldPaginate', handleShouldPaginate, false);
          defineBooleanAttribute('noInkBar', handleInkBar);
          defineBooleanAttribute('dynamicHeight', handleDynamicHeight);
          defineBooleanAttribute('noPagination');
          defineBooleanAttribute('swipeContent');
          defineBooleanAttribute('noDisconnect');
          defineBooleanAttribute('autoselect');
          defineBooleanAttribute('centerTabs', handleCenterTabs, false);
          defineBooleanAttribute('enableDisconnect');
          ctrl.scope = $scope;
          ctrl.parent = $scope.$parent;
          ctrl.tabs = [];
          ctrl.lastSelectedIndex = null;
          ctrl.hasFocus = false;
          ctrl.lastClick = true;
          ctrl.shouldCenterTabs = shouldCenterTabs();
          ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
          ctrl.redirectFocus = redirectFocus;
          ctrl.attachRipple = attachRipple;
          ctrl.insertTab = insertTab;
          ctrl.removeTab = removeTab;
          ctrl.select = select;
          ctrl.scroll = scroll;
          ctrl.nextPage = nextPage;
          ctrl.previousPage = previousPage;
          ctrl.keydown = keydown;
          ctrl.canPageForward = canPageForward;
          ctrl.canPageBack = canPageBack;
          ctrl.refreshIndex = refreshIndex;
          ctrl.incrementIndex = incrementIndex;
          ctrl.getTabElementIndex = getTabElementIndex;
          ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
          ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
          init();
          function init() {
            ctrl.selectedIndex = ctrl.selectedIndex || 0;
            compileTemplate();
            configureWatchers();
            bindEvents();
            $mdTheming($element);
            $mdUtil.nextTick(function() {
              updateHeightFromContent();
              adjustOffset();
              updateInkBarStyles();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
              loaded = true;
              updatePagination();
            });
          }
          function compileTemplate() {
            var template = $attrs.$mdTabsTemplate,
                element = angular.element(elements.data);
            element.html(template);
            $compile(element.contents())(ctrl.parent);
            delete $attrs.$mdTabsTemplate;
          }
          function bindEvents() {
            angular.element($window).on('resize', handleWindowResize);
            $scope.$on('$destroy', cleanup);
          }
          function configureWatchers() {
            $scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);
          }
          function defineOneWayBinding(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            $attrs.$observe(attr, function(newValue) {
              ctrl[key] = newValue;
            });
          }
          function defineBooleanAttribute(key, handler) {
            var attr = $attrs.$normalize('md-' + key);
            if (handler)
              defineProperty(key, handler);
            if ($attrs.hasOwnProperty(attr))
              updateValue($attrs[attr]);
            $attrs.$observe(attr, updateValue);
            function updateValue(newValue) {
              ctrl[key] = newValue !== 'false';
            }
          }
          function cleanup() {
            destroyed = true;
            angular.element($window).off('resize', handleWindowResize);
          }
          function handleStretchTabs(stretchTabs) {
            angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs());
            updateInkBarStyles();
          }
          function handleCenterTabs(newValue) {
            ctrl.shouldCenterTabs = shouldCenterTabs();
          }
          function handleMaxTabWidth(newWidth, oldWidth) {
            if (newWidth !== oldWidth) {
              angular.forEach(elements.tabs, function(tab) {
                tab.style.maxWidth = newWidth + 'px';
              });
              $mdUtil.nextTick(ctrl.updateInkBarStyles);
            }
          }
          function handleShouldPaginate(newValue, oldValue) {
            if (newValue !== oldValue) {
              ctrl.maxTabWidth = getMaxTabWidth();
              ctrl.shouldCenterTabs = shouldCenterTabs();
              $mdUtil.nextTick(function() {
                ctrl.maxTabWidth = getMaxTabWidth();
                adjustOffset(ctrl.selectedIndex);
              });
            }
          }
          function handleHasContent(hasContent) {
            $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');
          }
          function handleOffsetChange(left) {
            var newValue = ctrl.shouldCenterTabs ? '' : '-' + left + 'px';
            angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, 'translate3d(' + newValue + ', 0, 0)');
            $scope.$broadcast('$mdTabsPaginationChanged');
          }
          function handleFocusIndexChange(newIndex, oldIndex) {
            if (newIndex === oldIndex)
              return;
            if (!elements.tabs[newIndex])
              return;
            adjustOffset();
            redirectFocus();
          }
          function handleSelectedIndexChange(newValue, oldValue) {
            if (newValue === oldValue)
              return;
            ctrl.selectedIndex = getNearestSafeIndex(newValue);
            ctrl.lastSelectedIndex = oldValue;
            ctrl.updateInkBarStyles();
            updateHeightFromContent();
            adjustOffset(newValue);
            $scope.$broadcast('$mdTabsChanged');
            ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
            ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
          }
          function getTabElementIndex(tabEl) {
            var tabs = $element[0].getElementsByTagName('md-tab');
            return Array.prototype.indexOf.call(tabs, tabEl[0]);
          }
          function handleResizeWhenVisible() {
            if (handleResizeWhenVisible.watcher)
              return;
            handleResizeWhenVisible.watcher = $scope.$watch(function() {
              $mdUtil.nextTick(function() {
                if (!handleResizeWhenVisible.watcher)
                  return;
                if ($element.prop('offsetParent')) {
                  handleResizeWhenVisible.watcher();
                  handleResizeWhenVisible.watcher = null;
                  handleWindowResize();
                }
              }, false);
            });
          }
          function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                incrementIndex(-1, true);
                break;
              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                incrementIndex(1, true);
                break;
              case $mdConstant.KEY_CODE.SPACE:
              case $mdConstant.KEY_CODE.ENTER:
                event.preventDefault();
                if (!locked)
                  ctrl.selectedIndex = ctrl.focusIndex;
                break;
            }
            ctrl.lastClick = false;
          }
          function select(index) {
            if (!locked)
              ctrl.focusIndex = ctrl.selectedIndex = index;
            ctrl.lastClick = true;
            $mdUtil.nextTick(function() {
              ctrl.tabs[index].element.triggerHandler('click');
            }, false);
          }
          function scroll(event) {
            if (!ctrl.shouldPaginate)
              return;
            event.preventDefault();
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
          }
          function nextPage() {
            var viewportWidth = elements.canvas.clientWidth,
                totalWidth = viewportWidth + ctrl.offsetLeft,
                i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth > totalWidth)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft);
          }
          function previousPage() {
            var i,
                tab;
            for (i = 0; i < elements.tabs.length; i++) {
              tab = elements.tabs[i];
              if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft)
                break;
            }
            ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
          }
          function handleWindowResize() {
            ctrl.lastSelectedIndex = ctrl.selectedIndex;
            ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            $mdUtil.nextTick(function() {
              ctrl.updateInkBarStyles();
              updatePagination();
            });
          }
          function handleInkBar(hide) {
            angular.element(elements.inkBar).toggleClass('ng-hide', hide);
          }
          function handleDynamicHeight(value) {
            $element.toggleClass('md-dynamic-height', value);
          }
          function removeTab(tabData) {
            if (destroyed)
              return;
            var selectedIndex = ctrl.selectedIndex,
                tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
            refreshIndex();
            if (ctrl.selectedIndex === selectedIndex) {
              tab.scope.deselect();
              ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
            }
            $mdUtil.nextTick(function() {
              updatePagination();
              ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
            });
          }
          function insertTab(tabData, index) {
            var hasLoaded = loaded;
            var proto = {
              getIndex: function() {
                return ctrl.tabs.indexOf(tab);
              },
              isActive: function() {
                return this.getIndex() === ctrl.selectedIndex;
              },
              isLeft: function() {
                return this.getIndex() < ctrl.selectedIndex;
              },
              isRight: function() {
                return this.getIndex() > ctrl.selectedIndex;
              },
              shouldRender: function() {
                return !ctrl.noDisconnect || this.isActive();
              },
              hasFocus: function() {
                return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
              },
              id: $mdUtil.nextUid()
            },
                tab = angular.extend(proto, tabData);
            if (angular.isDefined(index)) {
              ctrl.tabs.splice(index, 0, tab);
            } else {
              ctrl.tabs.push(tab);
            }
            processQueue();
            updateHasContent();
            $mdUtil.nextTick(function() {
              updatePagination();
              if (hasLoaded && ctrl.autoselect)
                $mdUtil.nextTick(function() {
                  $mdUtil.nextTick(function() {
                    select(ctrl.tabs.indexOf(tab));
                  });
                });
            });
            return tab;
          }
          function getElements() {
            var elements = {};
            elements.wrapper = $element[0].getElementsByTagName('md-tabs-wrapper')[0];
            elements.data = $element[0].getElementsByTagName('md-tab-data')[0];
            elements.canvas = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];
            elements.paging = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];
            elements.tabs = elements.paging.getElementsByTagName('md-tab-item');
            elements.dummies = elements.canvas.getElementsByTagName('md-dummy-tab');
            elements.inkBar = elements.paging.getElementsByTagName('md-ink-bar')[0];
            elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];
            elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');
            return elements;
          }
          function canPageBack() {
            return ctrl.offsetLeft > 0;
          }
          function canPageForward() {
            var lastTab = elements.tabs[elements.tabs.length - 1];
            return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
          }
          function shouldStretchTabs() {
            switch (ctrl.stretchTabs) {
              case 'always':
                return true;
              case 'never':
                return false;
              default:
                return !ctrl.shouldPaginate && $window.matchMedia('(max-width: 600px)').matches;
            }
          }
          function shouldCenterTabs() {
            return ctrl.centerTabs && !ctrl.shouldPaginate;
          }
          function shouldPaginate() {
            if (ctrl.noPagination || !loaded)
              return false;
            var canvasWidth = $element.prop('clientWidth');
            angular.forEach(getElements().dummies, function(tab) {
              canvasWidth -= tab.offsetWidth;
            });
            return canvasWidth < 0;
          }
          function getNearestSafeIndex(newIndex) {
            if (newIndex === -1)
              return -1;
            var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),
                i,
                tab;
            for (i = 0; i <= maxOffset; i++) {
              tab = ctrl.tabs[newIndex + i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
              tab = ctrl.tabs[newIndex - i];
              if (tab && (tab.scope.disabled !== true))
                return tab.getIndex();
            }
            return newIndex;
          }
          function defineProperty(key, handler, value) {
            Object.defineProperty(ctrl, key, {
              get: function() {
                return value;
              },
              set: function(newValue) {
                var oldValue = value;
                value = newValue;
                handler && handler(newValue, oldValue);
              }
            });
          }
          function updatePagination() {
            if (!shouldStretchTabs())
              updatePagingWidth();
            ctrl.maxTabWidth = getMaxTabWidth();
            ctrl.shouldPaginate = shouldPaginate();
          }
          function updatePagingWidth() {
            var width = 1;
            angular.forEach(getElements().dummies, function(element) {
              width += Math.max(element.offsetWidth, element.getBoundingClientRect().width);
            });
            angular.element(elements.paging).css('width', Math.ceil(width) + 'px');
          }
          function getMaxTabWidth() {
            return $element.prop('clientWidth');
          }
          function updateTabOrder() {
            var selectedItem = ctrl.tabs[ctrl.selectedIndex],
                focusItem = ctrl.tabs[ctrl.focusIndex];
            ctrl.tabs = ctrl.tabs.sort(function(a, b) {
              return a.index - b.index;
            });
            ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
            ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
          }
          function incrementIndex(inc, focus) {
            var newIndex,
                key = focus ? 'focusIndex' : 'selectedIndex',
                index = ctrl[key];
            for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) {}
            if (ctrl.tabs[newIndex]) {
              ctrl[key] = newIndex;
            }
          }
          function redirectFocus() {
            getElements().dummies[ctrl.focusIndex].focus();
          }
          function adjustOffset(index) {
            if (index == null)
              index = ctrl.focusIndex;
            if (!elements.tabs[index])
              return;
            if (ctrl.shouldCenterTabs)
              return;
            var tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = tab.offsetWidth + left;
            ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 32 * 2));
            ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
          }
          function processQueue() {
            queue.forEach(function(func) {
              $mdUtil.nextTick(func);
            });
            queue = [];
          }
          function updateHasContent() {
            var hasContent = false;
            angular.forEach(ctrl.tabs, function(tab) {
              if (tab.template)
                hasContent = true;
            });
            ctrl.hasContent = hasContent;
          }
          function refreshIndex() {
            ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
            ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
          }
          function updateHeightFromContent() {
            if (!ctrl.dynamicHeight)
              return $element.css('height', '');
            if (!ctrl.tabs.length)
              return queue.push(updateHeightFromContent);
            var tabContent = elements.contents[ctrl.selectedIndex],
                contentHeight = tabContent ? tabContent.offsetHeight : 0,
                tabsHeight = elements.wrapper.offsetHeight,
                newHeight = contentHeight + tabsHeight,
                currentHeight = $element.prop('clientHeight');
            if (currentHeight === newHeight)
              return;
            if ($element.attr('md-align-tabs') === 'bottom') {
              currentHeight -= tabsHeight;
              newHeight -= tabsHeight;
              if ($element.attr('md-border-bottom') !== undefined)
                ++currentHeight;
            }
            locked = true;
            var fromHeight = {height: currentHeight + 'px'},
                toHeight = {height: newHeight + 'px'};
            $element.css(fromHeight);
            $animateCss($element, {
              from: fromHeight,
              to: toHeight,
              easing: 'cubic-bezier(0.35, 0, 0.25, 1)',
              duration: 0.5
            }).start().done(function() {
              $element.css({
                transition: 'none',
                height: ''
              });
              $mdUtil.nextTick(function() {
                $element.css('transition', '');
              });
              locked = false;
            });
          }
          function updateInkBarStyles() {
            if (!elements.tabs[ctrl.selectedIndex]) {
              angular.element(elements.inkBar).css({
                left: 'auto',
                right: 'auto'
              });
              return;
            }
            if (!ctrl.tabs.length)
              return queue.push(ctrl.updateInkBarStyles);
            if (!$element.prop('offsetParent'))
              return handleResizeWhenVisible();
            var index = ctrl.selectedIndex,
                totalWidth = elements.paging.offsetWidth,
                tab = elements.tabs[index],
                left = tab.offsetLeft,
                right = totalWidth - left - tab.offsetWidth,
                tabWidth;
            if (ctrl.shouldCenterTabs) {
              tabWidth = Array.prototype.slice.call(elements.tabs).reduce(function(value, element) {
                return value + element.offsetWidth;
              }, 0);
              if (totalWidth > tabWidth)
                $mdUtil.nextTick(updateInkBarStyles, false);
            }
            updateInkBarClassName();
            angular.element(elements.inkBar).css({
              left: left + 'px',
              right: right + 'px'
            });
          }
          function updateInkBarClassName() {
            var newIndex = ctrl.selectedIndex,
                oldIndex = ctrl.lastSelectedIndex,
                ink = angular.element(elements.inkBar);
            if (!angular.isNumber(oldIndex))
              return;
            ink.toggleClass('md-left', newIndex < oldIndex).toggleClass('md-right', newIndex > oldIndex);
          }
          function fixOffset(value) {
            if (!elements.tabs.length || !ctrl.shouldPaginate)
              return 0;
            var lastTab = elements.tabs[elements.tabs.length - 1],
                totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            value = Math.max(0, value);
            value = Math.min(totalWidth - elements.canvas.clientWidth, value);
            return value;
          }
          function attachRipple(scope, element) {
            var options = {colorElement: angular.element(elements.inkBar)};
            $mdTabInkRipple.attach(scope, element, options);
          }
        }
        MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming"];
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabs', MdTabs);
        function MdTabs() {
          return {
            scope: {selectedIndex: '=?mdSelected'},
            template: function(element, attr) {
              attr["$mdTabsTemplate"] = element.html();
              return '' + '<md-tabs-wrapper> ' + '<md-tab-data></md-tab-data> ' + '<md-prev-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Previous Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.previousPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-prev-button> ' + '<md-next-button ' + 'tabindex="-1" ' + 'role="button" ' + 'aria-label="Next Page" ' + 'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' + 'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' + 'ng-if="$mdTabsCtrl.shouldPaginate" ' + 'ng-click="$mdTabsCtrl.nextPage()"> ' + '<md-icon md-svg-icon="md-tabs-arrow"></md-icon> ' + '</md-next-button> ' + '<md-tabs-canvas ' + 'tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ' + 'aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ' + 'ng-focus="$mdTabsCtrl.redirectFocus()" ' + 'ng-class="{ ' + '\'md-paginated\': $mdTabsCtrl.shouldPaginate, ' + '\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs ' + '}" ' + 'ng-keydown="$mdTabsCtrl.keydown($event)" ' + 'role="tablist"> ' + '<md-pagination-wrapper ' + 'ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' + 'md-tab-scroll="$mdTabsCtrl.scroll($event)"> ' + '<md-tab-item ' + 'tabindex="-1" ' + 'class="md-tab" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' + 'ng-class="{ ' + '\'md-active\':    tab.isActive(), ' + '\'md-focused\':   tab.hasFocus(), ' + '\'md-disabled\':  tab.scope.disabled ' + '}" ' + 'ng-disabled="tab.scope.disabled" ' + 'md-swipe-left="$mdTabsCtrl.nextPage()" ' + 'md-swipe-right="$mdTabsCtrl.previousPage()" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-tab-item> ' + '<md-ink-bar></md-ink-bar> ' + '</md-pagination-wrapper> ' + '<div class="md-visually-hidden md-dummy-wrapper"> ' + '<md-dummy-tab ' + 'class="md-tab" ' + 'tabindex="-1" ' + 'id="tab-item-{{::tab.id}}" ' + 'role="tab" ' + 'aria-controls="tab-content-{{::tab.id}}" ' + 'aria-selected="{{tab.isActive()}}" ' + 'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' + 'ng-focus="$mdTabsCtrl.hasFocus = true" ' + 'ng-blur="$mdTabsCtrl.hasFocus = false" ' + 'ng-repeat="tab in $mdTabsCtrl.tabs" ' + 'md-tabs-template="::tab.label" ' + 'md-scope="::tab.parent"></md-dummy-tab> ' + '</div> ' + '</md-tabs-canvas> ' + '</md-tabs-wrapper> ' + '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> ' + '<md-tab-content ' + 'id="tab-content-{{::tab.id}}" ' + 'role="tabpanel" ' + 'aria-labelledby="tab-item-{{::tab.id}}" ' + 'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' + 'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' + 'ng-if="$mdTabsCtrl.hasContent" ' + 'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' + 'ng-class="{ ' + '\'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, ' + '\'md-active\':        tab.isActive(), ' + '\'md-left\':          tab.isLeft(), ' + '\'md-right\':         tab.isRight(), ' + '\'md-no-scroll\':     $mdTabsCtrl.dynamicHeight ' + '}"> ' + '<div ' + 'md-tabs-template="::tab.template" ' + 'md-connected-if="tab.isActive()" ' + 'md-scope="::tab.parent" ' + 'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' + '</md-tab-content> ' + '</md-tabs-content-wrapper>';
            },
            controller: 'MdTabsController',
            controllerAs: '$mdTabsCtrl',
            bindToController: true
          };
        }
      })();
      (function() {
        "use strict";
        angular.module('material.components.tabs').directive('mdTabsTemplate', MdTabsTemplate);
        function MdTabsTemplate($compile, $mdUtil) {
          return {
            restrict: 'A',
            link: link,
            scope: {
              template: '=mdTabsTemplate',
              connected: '=?mdConnectedIf',
              compileScope: '=mdScope'
            },
            require: '^?mdTabs'
          };
          function link(scope, element, attr, ctrl) {
            if (!ctrl)
              return;
            var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
            element.html(scope.template);
            $compile(element.contents())(compileScope);
            element.on('DOMSubtreeModified', function() {
              ctrl.updatePagination();
              ctrl.updateInkBarStyles();
            });
            return $mdUtil.nextTick(handleScope);
            function handleScope() {
              scope.$watch('connected', function(value) {
                value === false ? disconnect() : reconnect();
              });
              scope.$on('$destroy', reconnect);
            }
            function disconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.disconnectScope(compileScope);
            }
            function reconnect() {
              if (ctrl.enableDisconnect)
                $mdUtil.reconnectScope(compileScope);
            }
          }
        }
        MdTabsTemplate.$inject = ["$compile", "$mdUtil"];
      })();
      (function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-700}}'; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-700}}'; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}' !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: '{{foreground-1}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-hue-1}}';  color: '{{foreground-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: '{{background-color}}'; }.md-THEME_NAME-theme .md-datepicker-input {  color: '{{background-contrast}}';  background: '{{background-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-300}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-color}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [ng-messages] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme data-ng-message :not(.md-char-counter), md-input-container.md-THEME_NAME-theme x-ng-message :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message] :not(.md-char-counter),md-input-container.md-THEME_NAME-theme [ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [data-ng-message-exp] :not(.md-char-counter), md-input-container.md-THEME_NAME-theme [x-ng-message-exp] :not(.md-char-counter) {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{foreground-2}}'; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-color}}';  color: '{{foreground-1}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{primary-contrast}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: '{{foreground-2}}'; }");
      })();
    })(window, window.angular);
    ;
    window.ngMaterial = {version: {full: "1.0.6"}};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("12", ["5", "c", "d", "11"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('5');
  $__require('c');
  $__require('d');
  $__require('11');
  module.exports = 'ngMaterial';
  return module.exports;
});

$__System.registerDynamic("13", ["12"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('12');
  return module.exports;
});

$__System.registerDynamic("14", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(window, angular, undefined) {
    'use strict';
    angular.module('md.table.templates', ['md-table-pagination.html', 'md-table-progress.html', 'arrow-up.svg', 'navigate-before.svg', 'navigate-first.svg', 'navigate-last.svg', 'navigate-next.svg']);
    angular.module('md-table-pagination.html', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('md-table-pagination.html', '<span class="label" ng-if="$pagination.showPageSelect()">{{ $pagination.$label[\'page\'] }}</span>\n' + '\n' + '<md-select class="md-table-select" ng-if="$pagination.showPageSelect()" ng-model="$pagination.page" md-container-class="md-pagination-select" ng-change="$pagination.onPaginationChange()" aria-label="Page">\n' + '  <md-option ng-repeat="num in $pagination.range($pagination.pages()) track by $index" ng-value="$index + 1">{{$index + 1}}</md-option>\n' + '</md-select>\n' + '\n' + '<span class="label">{{ $pagination.$label[\'rowsPerPage\'] }}</span>\n' + '\n' + '<md-select class="md-table-select" ng-model="$pagination.limit" md-container-class="md-pagination-select" aria-label="Rows" placeholder="{{$pagination.options ? $pagination.options[0] : 5}}">\n' + '  <md-option ng-repeat="rows in $pagination.options ? $pagination.options : [5, 10, 15]" ng-value="rows">{{rows}}</md-option>\n' + '</md-select>\n' + '\n' + '<span class="label">{{$pagination.min() + 1}} - {{$pagination.max()}} {{ $pagination.$label[\'of\'] }} {{$pagination.total}}</span>\n' + '\n' + '<md-button class="md-icon-button" type="button" ng-if="$pagination.showBoundaryLinks()" ng-click="$pagination.first()" ng-disabled="!$pagination.hasPrevious()" aria-label="First">\n' + '  <md-icon md-svg-icon="navigate-first.svg"></md-icon>\n' + '</md-button>\n' + '<md-button class="md-icon-button" type="button" ng-click="$pagination.previous()" ng-disabled="!$pagination.hasPrevious()" aria-label="Previous">\n' + '  <md-icon md-svg-icon="navigate-before.svg"></md-icon>\n' + '</md-button>\n' + '<md-button class="md-icon-button" type="button" ng-click="$pagination.next()" ng-disabled="$pagination.disableNext()" aria-label="Next">\n' + '  <md-icon md-svg-icon="navigate-next.svg"></md-icon>\n' + '</md-button>\n' + '<md-button class="md-icon-button" type="button" ng-if="$pagination.showBoundaryLinks()" ng-click="$pagination.last()" ng-disabled="$pagination.disableNext()" aria-label="Last">\n' + '  <md-icon md-svg-icon="navigate-last.svg"></md-icon>\n' + '</md-button>');
    }]);
    angular.module('md-table-progress.html', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('md-table-progress.html', '<tr>\n' + '  <th colspan="{{columnCount()}}">\n' + '    <md-progress-linear ng-show="deferred()" md-mode="indeterminate"></md-progress-linear>\n' + '  </th>\n' + '</tr>');
    }]);
    angular.module('arrow-up.svg', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('arrow-up.svg', '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/></svg>');
    }]);
    angular.module('navigate-before.svg', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('navigate-before.svg', '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>');
    }]);
    angular.module('navigate-first.svg', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('navigate-first.svg', '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M7 6 v12 h2 v-12 h-2z M17.41 7.41L16 6l-6 6 6 6 1.41-1.41L12.83 12z"/></svg>');
    }]);
    angular.module('navigate-last.svg', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('navigate-last.svg', '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15 6 v12 h2 v-12 h-2z M8 6L6.59 7.41 11.17 12l-4.58 4.59L8 18l6-6z"/></svg>');
    }]);
    angular.module('navigate-next.svg', []).run(['$templateCache', function($templateCache) {
      $templateCache.put('navigate-next.svg', '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>');
    }]);
    angular.module('md.data.table', ['md.table.templates']);
    angular.module('md.data.table').directive('mdBody', mdBody);
    function mdBody() {
      function compile(tElement) {
        tElement.addClass('md-body');
      }
      return {
        compile: compile,
        restrict: 'A'
      };
    }
    angular.module('md.data.table').directive('mdCell', mdCell);
    function mdCell() {
      function compile(tElement) {
        var select = tElement.find('md-select');
        if (select.length) {
          select.addClass('md-table-select').attr('md-container-class', 'md-table-select');
        }
        tElement.addClass('md-cell');
        return postLink;
      }
      function Controller() {}
      function postLink(scope, element, attrs, ctrls) {
        var select = element.find('md-select');
        var cellCtrl = ctrls.shift();
        var tableCtrl = ctrls.shift();
        if (attrs.ngClick) {
          element.addClass('md-clickable');
        }
        if (select.length) {
          select.on('click', function(event) {
            event.stopPropagation();
          });
          element.addClass('md-clickable').on('click', function(event) {
            event.stopPropagation();
            select[0].click();
          });
        }
        cellCtrl.getTable = tableCtrl.getElement;
        function getColumn() {
          return tableCtrl.$$columns[getIndex()];
        }
        function getIndex() {
          return Array.prototype.indexOf.call(element.parent().children(), element[0]);
        }
        scope.$watch(getColumn, function(column) {
          if (!column) {
            return;
          }
          if (column.numeric) {
            element.addClass('md-numeric');
          } else {
            element.removeClass('md-numeric');
          }
        });
      }
      return {
        controller: Controller,
        compile: compile,
        require: ['mdCell', '^^mdTable'],
        restrict: 'A'
      };
    }
    angular.module('md.data.table').directive('mdColumn', mdColumn);
    function mdColumn($compile) {
      function compile(tElement) {
        tElement.addClass('md-column');
        return postLink;
      }
      function postLink(scope, element, attrs, ctrls) {
        var headCtrl = ctrls.shift();
        var tableCtrl = ctrls.shift();
        function attachSortIcon() {
          var sortIcon = angular.element('<md-icon md-svg-icon="arrow-up.svg">');
          $compile(sortIcon.addClass('md-sort-icon').attr('ng-class', 'getDirection()'))(scope);
          if (element.hasClass('md-numeric')) {
            element.prepend(sortIcon);
          } else {
            element.append(sortIcon);
          }
        }
        function detachSortIcon() {
          Array.prototype.some.call(element.find('md-icon'), function(icon) {
            return icon.classList.contains('md-sort-icon') && element[0].removeChild(icon);
          });
        }
        function disableSorting() {
          detachSortIcon();
          element.removeClass('md-sort').off('click', setOrder);
        }
        function enableSorting() {
          attachSortIcon();
          element.addClass('md-sort').on('click', setOrder);
        }
        function getIndex() {
          return Array.prototype.indexOf.call(element.parent().children(), element[0]);
        }
        function isActive() {
          if (!scope.orderBy) {
            return false;
          }
          return headCtrl.order === scope.orderBy || headCtrl.order === '-' + scope.orderBy;
        }
        function isNumeric() {
          if (attrs.hasOwnProperty('mdNumeric') && attrs.mdNumeric === '') {
            return true;
          }
          return scope.numeric;
        }
        function setOrder() {
          scope.$applyAsync(function() {
            if (!isActive()) {
              headCtrl.order = scope.getDirection() === 'md-asc' ? scope.orderBy : '-' + scope.orderBy;
            } else {
              headCtrl.order = scope.getDirection() === 'md-asc' ? '-' + scope.orderBy : scope.orderBy;
            }
            if (angular.isFunction(headCtrl.onReorder)) {
              headCtrl.onReorder(headCtrl.order);
            }
          });
        }
        function updateColumn(index, column) {
          tableCtrl.$$columns[index] = column;
          if (column.numeric) {
            element.addClass('md-numeric');
          } else {
            element.removeClass('md-numeric');
          }
        }
        scope.getDirection = function() {
          if (!isActive()) {
            return attrs.hasOwnProperty('mdDesc') ? 'md-desc' : 'md-asc';
          }
          return headCtrl.order === '-' + scope.orderBy ? 'md-desc' : 'md-asc';
        };
        scope.$watch(isActive, function(active) {
          if (active) {
            element.addClass('md-active');
          } else {
            element.removeClass('md-active');
          }
        });
        scope.$watch(getIndex, function(index) {
          updateColumn(index, {'numeric': isNumeric()});
        });
        scope.$watch(isNumeric, function(numeric) {
          updateColumn(getIndex(), {'numeric': numeric});
        });
        scope.$watch('orderBy', function(orderBy) {
          if (orderBy) {
            enableSorting();
          } else {
            disableSorting();
          }
        });
      }
      return {
        compile: compile,
        require: ['^^mdHead', '^^mdTable'],
        restrict: 'A',
        scope: {
          numeric: '=?mdNumeric',
          orderBy: '@?mdOrderBy'
        }
      };
    }
    mdColumn.$inject = ['$compile'];
    angular.module('md.data.table').decorator('$controller', controllerDecorator).factory('$mdEditDialog', mdEditDialog);
    function controllerDecorator($delegate) {
      return function(expression, locals, later, ident) {
        if (later && typeof later === 'object') {
          var create = $delegate(expression, locals, true, ident);
          angular.extend(create.instance, later);
          return create();
        }
        return $delegate(expression, locals, later, ident);
      };
    }
    controllerDecorator.$inject = ['$delegate'];
    function mdEditDialog($compile, $controller, $document, $mdUtil, $q, $rootScope, $templateCache, $templateRequest, $window) {
      var ESCAPE = 27;
      var busy = false;
      var body = angular.element($document.prop('body'));
      var defaultOptions = {
        clickOutsideToClose: true,
        disableScroll: true,
        escToClose: true,
        focusOnOpen: true
      };
      function build(template, options) {
        var scope = $rootScope.$new();
        var element = $compile(template)(scope);
        var backdrop = $mdUtil.createBackdrop(scope, 'md-edit-dialog-backdrop');
        var controller;
        if (options.controller) {
          controller = getController(options, scope, {
            $element: element,
            $scope: scope
          });
        } else {
          angular.extend(scope, options.scope);
        }
        if (options.disableScroll) {
          disableScroll(element);
        }
        body.prepend(backdrop).append(element.addClass('md-whiteframe-1dp'));
        positionDialog(element, options.target);
        if (options.focusOnOpen) {
          focusOnOpen(element);
        }
        if (options.clickOutsideToClose) {
          backdrop.on('click', function() {
            element.remove();
          });
        }
        if (options.escToClose) {
          escToClose(element);
        }
        element.on('$destroy', function() {
          busy = false;
          backdrop.remove();
        });
        return controller;
      }
      function disableScroll(element) {
        var restoreScroll = $mdUtil.disableScrollAround(element, body);
        element.on('$destroy', function() {
          restoreScroll();
        });
      }
      function getController(options, scope, inject) {
        if (!options.controller) {
          return;
        }
        if (options.resolve) {
          angular.extend(inject, options.resolve);
        }
        if (options.locals) {
          angular.extend(inject, options.locals);
        }
        if (options.controllerAs) {
          scope[options.controllerAs] = {};
          if (options.bindToController) {
            angular.extend(scope[options.controllerAs], options.scope);
          } else {
            angular.extend(scope, options.scope);
          }
        } else {
          angular.extend(scope, options.scope);
        }
        if (options.bindToController) {
          return $controller(options.controller, inject, scope[options.controllerAs]);
        } else {
          return $controller(options.controller, inject);
        }
      }
      function getTemplate(options) {
        return $q(function(resolve, reject) {
          var template = options.template;
          function illegalType(type) {
            reject('Unexpected template value. Expected a string; received a ' + type + '.');
          }
          if (template) {
            return angular.isString(template) ? resolve(template) : illegalType(typeof template);
          }
          if (options.templateUrl) {
            template = $templateCache.get(options.templateUrl);
            if (template) {
              return resolve(template);
            }
            var success = function(template) {
              return resolve(template);
            };
            var error = function() {
              return reject('Error retrieving template from URL.');
            };
            return $templateRequest(options.templateUrl).then(success, error);
          }
          reject('Template not provided.');
        });
      }
      function logError(error) {
        busy = false;
        console.error(error);
      }
      function escToClose(element) {
        var keyup = function(event) {
          if (event.keyCode === ESCAPE) {
            element.remove();
          }
        };
        body.on('keyup', keyup);
        element.on('$destroy', function() {
          body.off('keyup', keyup);
        });
      }
      function focusOnOpen(element) {
        $mdUtil.nextTick(function() {
          var autofocus = $mdUtil.findFocusTarget(element);
          if (autofocus) {
            autofocus.focus();
          }
        }, false);
      }
      function positionDialog(element, target) {
        var table = angular.element(target).controller('mdCell').getTable();
        var getHeight = function() {
          return element.prop('clientHeight');
        };
        var getSize = function() {
          return {
            width: getWidth(),
            height: getHeight()
          };
        };
        var getTableBounds = function() {
          var parent = table.parent();
          if (parent.prop('tagName') === 'MD-TABLE-CONTAINER') {
            return parent[0].getBoundingClientRect();
          } else {
            return table[0].getBoundingClientRect();
          }
        };
        var getWidth = function() {
          return element.prop('clientWidth');
        };
        var reposition = function() {
          var size = getSize();
          var cellBounds = target.getBoundingClientRect();
          var tableBounds = getTableBounds();
          if (size.width > tableBounds.right - cellBounds.left) {
            element.css('left', tableBounds.right - size.width + 'px');
          } else {
            element.css('left', cellBounds.left + 'px');
          }
          if (size.height > tableBounds.bottom - cellBounds.top) {
            element.css('top', tableBounds.bottom - size.height + 'px');
          } else {
            element.css('top', cellBounds.top + 1 + 'px');
          }
          element.css('minWidth', cellBounds.width + 'px');
        };
        var watchWidth = $rootScope.$watch(getWidth, reposition);
        var watchHeight = $rootScope.$watch(getHeight, reposition);
        $window.addEventListener('resize', reposition);
        element.on('$destroy', function() {
          watchWidth();
          watchHeight();
          $window.removeEventListener('resize', reposition);
        });
      }
      function preset(size, options) {
        function getAttrs() {
          var attrs = 'type="' + (options.type || 'text') + '"';
          for (var attr in options.validators) {
            attrs += ' ' + attr + '="' + options.validators[attr] + '"';
          }
          return attrs;
        }
        return {
          controller: ['$element', '$q', 'save', '$scope', function($element, $q, save, $scope) {
            function update() {
              if ($scope.editDialog.$invalid) {
                return $q.reject();
              }
              if (angular.isFunction(save)) {
                return $q.when(save($scope.editDialog.input));
              }
              return $q.resolve();
            }
            this.dismiss = function() {
              $element.remove();
            };
            this.getInput = function() {
              return $scope.editDialog.input;
            };
            $scope.dismiss = this.dismiss;
            $scope.submit = function() {
              update().then(function() {
                $scope.dismiss();
              });
            };
          }],
          locals: {save: options.save},
          scope: {
            cancel: options.cancel || 'Cancel',
            messages: options.messages,
            model: options.modelValue,
            ok: options.ok || 'Save',
            placeholder: options.placeholder,
            title: options.title,
            size: size
          },
          template: '<md-edit-dialog>' + '<div layout="column" class="md-content">' + '<div ng-if="size === \'large\'" class="md-title">{{title || \'Edit\'}}</div>' + '<form name="editDialog" layout="column" ng-submit="submit(model)">' + '<md-input-container md-no-float>' + '<input name="input" ng-model="model" md-autofocus placeholder="{{placeholder}} "' + getAttrs() + '>' + '<div ng-messages="editDialog.input.$error">' + '<div ng-repeat="(key, message) in messages" ng-message="{{key}}">{{message}}</div>' + '</div>' + '</md-input-container>' + '</form>' + '</div>' + '<div ng-if="size === \'large\'" layout="row" layout-align="end" class="md-actions">' + '<md-button class="md-primary" ng-click="dismiss()">{{cancel}}</md-button>' + '<md-button class="md-primary" ng-click="submit()">{{ok}}</md-button>' + '</div>' + '</md-edit-dialog>'
        };
      }
      this.show = function(options) {
        if (busy) {
          return $q.reject();
        }
        busy = true;
        options = angular.extend({}, defaultOptions, options);
        if (!options.targetEvent) {
          return logError('options.targetEvent is required to align the dialog with the table cell.');
        }
        if (!options.targetEvent.currentTarget.classList.contains('md-cell')) {
          return logError('The event target must be a table cell.');
        }
        if (options.bindToController && !options.controllerAs) {
          return logError('You must define options.controllerAs when options.bindToController is true.');
        }
        options.target = options.targetEvent.currentTarget;
        var promise = getTemplate(options);
        var promises = [promise];
        for (var prop in options.resolve) {
          promise = options.resolve[prop];
          promises.push($q.when(angular.isFunction(promise) ? promise() : promise));
        }
        promise = $q.all(promises);
        promise['catch'](logError);
        return promise.then(function(results) {
          var template = results.shift();
          for (var prop in options.resolve) {
            options.resolve[prop] = results.shift();
          }
          return build(template, options);
        });
      };
      this.small = function(options) {
        return this.show(angular.extend({}, options, preset('small', options)));
      }.bind(this);
      this.large = function(options) {
        return this.show(angular.extend({}, options, preset('large', options)));
      }.bind(this);
      return this;
    }
    mdEditDialog.$inject = ['$compile', '$controller', '$document', '$mdUtil', '$q', '$rootScope', '$templateCache', '$templateRequest', '$window'];
    angular.module('md.data.table').directive('mdFoot', mdFoot);
    function mdFoot() {
      function compile(tElement) {
        tElement.addClass('md-foot');
      }
      return {
        compile: compile,
        restrict: 'A'
      };
    }
    angular.module('md.data.table').directive('mdHead', mdHead);
    function mdHead($compile) {
      function compile(tElement) {
        tElement.addClass('md-head');
        return postLink;
      }
      function Controller() {}
      function postLink(scope, element, attrs, tableCtrl) {
        function attachCheckbox() {
          var children = element.children();
          for (var i = 0; i < children.length - 1; i++) {
            children.eq(i).prepend('<th class="md-column">');
          }
          children.eq(children.length - 1).prepend(createCheckBox());
        }
        function createCheckBox() {
          var checkbox = angular.element('<md-checkbox>');
          checkbox.attr('aria-label', 'Select All');
          checkbox.attr('ng-click', 'toggleAll()');
          checkbox.attr('ng-checked', 'allSelected()');
          checkbox.attr('ng-disabled', '!getSelectableRows().length');
          return angular.element('<th class="md-column md-checkbox-column">').append($compile(checkbox)(scope));
        }
        function enableRowSelection() {
          return tableCtrl.$$rowSelect;
        }
        function mdSelectCtrl(row) {
          return angular.element(row).controller('mdSelect');
        }
        function removeCheckbox() {
          var children = element.children();
          var child = children.eq(children.length - 1);
          Array.prototype.some.call(child.prop('cells'), function(cell) {
            return cell.classList.contains('md-checkbox-column') && child[0].removeChild(cell);
          });
        }
        scope.allSelected = function() {
          var rows = scope.getSelectableRows();
          return rows.length && rows.every(function(row) {
            return row.isSelected();
          });
        };
        scope.getSelectableRows = function() {
          return tableCtrl.getBodyRows().map(mdSelectCtrl).filter(function(ctrl) {
            return ctrl && !ctrl.disabled;
          });
        };
        scope.selectAll = function() {
          tableCtrl.getBodyRows().map(mdSelectCtrl).forEach(function(ctrl) {
            if (ctrl && !ctrl.isSelected()) {
              ctrl.select();
            }
          });
        };
        scope.toggleAll = function() {
          return scope.allSelected() ? scope.unSelectAll() : scope.selectAll();
        };
        scope.unSelectAll = function() {
          tableCtrl.getBodyRows().map(mdSelectCtrl).forEach(function(ctrl) {
            if (ctrl && ctrl.isSelected()) {
              ctrl.deselect();
            }
          });
        };
        scope.$watch(enableRowSelection, function(enable) {
          if (enable) {
            attachCheckbox();
          } else {
            removeCheckbox();
          }
        });
      }
      return {
        bindToController: true,
        compile: compile,
        controller: Controller,
        controllerAs: '$mdHead',
        require: '^^mdTable',
        restrict: 'A',
        scope: {
          order: '=?mdOrder',
          onReorder: '=?mdOnReorder'
        }
      };
    }
    mdHead.$inject = ['$compile'];
    angular.module('md.data.table').directive('mdRow', mdRow);
    function mdRow() {
      function compile(tElement) {
        tElement.addClass('md-row');
        return postLink;
      }
      function postLink(scope, element, attrs, tableCtrl) {
        function enableRowSelection() {
          return tableCtrl.$$rowSelect;
        }
        function isBodyRow() {
          return tableCtrl.getBodyRows().indexOf(element[0]) !== -1;
        }
        function isChild(node) {
          return node.parent()[0] === element[0];
        }
        if (isBodyRow()) {
          var cell = angular.element('<td class="md-cell">');
          scope.$watch(enableRowSelection, function(enable) {
            if (enable && !attrs.mdSelect) {
              if (!isChild(cell)) {
                element.prepend(cell);
              }
              return;
            }
            if (isChild(cell)) {
              cell.remove();
            }
          });
        }
      }
      return {
        compile: compile,
        require: '^^mdTable',
        restrict: 'A'
      };
    }
    angular.module('md.data.table').directive('mdSelect', mdSelect);
    function mdSelect($compile) {
      function Controller() {}
      function postLink(scope, element, attrs, ctrls) {
        var self = ctrls.shift();
        var tableCtrl = ctrls.shift();
        if (tableCtrl.$$rowSelect && self.id && tableCtrl.$$hash.has(self.id)) {
          var index = tableCtrl.selected.indexOf(tableCtrl.$$hash.get(self.id));
          if (index === -1) {
            tableCtrl.$$hash.purge(self.id);
          } else if (!tableCtrl.$$hash.equals(self.id, self.model)) {
            tableCtrl.$$hash.update(self.id, self.model);
            tableCtrl.selected.splice(index, 1, self.model);
          }
        }
        self.isSelected = function() {
          if (!tableCtrl.$$rowSelect) {
            return false;
          }
          if (self.id) {
            return tableCtrl.$$hash.has(self.id);
          }
          return tableCtrl.selected.indexOf(self.model) !== -1;
        };
        self.select = function() {
          if (self.disabled) {
            return;
          }
          tableCtrl.selected.push(self.model);
          if (angular.isFunction(self.onSelect)) {
            self.onSelect(self.model);
          }
        };
        self.deselect = function() {
          if (self.disabled) {
            return;
          }
          tableCtrl.selected.splice(tableCtrl.selected.indexOf(self.model), 1);
          if (angular.isFunction(self.onDeselect)) {
            self.onDeselect(self.model);
          }
        };
        self.toggle = function(event) {
          if (event && event.stopPropagation) {
            event.stopPropagation();
          }
          return self.isSelected() ? self.deselect() : self.select();
        };
        function autoSelect() {
          if (attrs.hasOwnProperty('mdAutoSelect') && attrs.mdAutoSelect === '') {
            return true;
          }
          return self.autoSelect;
        }
        function createCheckbox() {
          var checkbox = angular.element('<md-checkbox>');
          checkbox.attr('aria-label', 'Select Row');
          checkbox.attr('ng-click', '$mdSelect.toggle($event)');
          checkbox.attr('ng-checked', '$mdSelect.isSelected()');
          checkbox.attr('ng-disabled', '$mdSelect.disabled');
          return angular.element('<td class="md-cell md-checkbox-cell">').append($compile(checkbox)(scope));
        }
        function disableSelection() {
          Array.prototype.some.call(element.children(), function(child) {
            return child.classList.contains('md-checkbox-cell') && element[0].removeChild(child);
          });
          if (autoSelect()) {
            element.off('click', toggle);
          }
        }
        function enableSelection() {
          element.prepend(createCheckbox());
          if (autoSelect()) {
            element.on('click', toggle);
          }
        }
        function enableRowSelection() {
          return tableCtrl.$$rowSelect;
        }
        function onSelectChange(selected) {
          if (!self.id) {
            return;
          }
          if (tableCtrl.$$hash.has(self.id)) {
            if (selected.indexOf(tableCtrl.$$hash.get(self.id)) === -1) {
              tableCtrl.$$hash.purge(self.id);
            }
            return;
          }
          if (selected.indexOf(self.model) !== -1) {
            tableCtrl.$$hash.update(self.id, self.model);
          }
        }
        function toggle(event) {
          scope.$applyAsync(function() {
            self.toggle(event);
          });
        }
        scope.$watch(enableRowSelection, function(enable) {
          if (enable) {
            enableSelection();
          } else {
            disableSelection();
          }
        });
        scope.$watch(autoSelect, function(newValue, oldValue) {
          if (newValue === oldValue) {
            return;
          }
          if (tableCtrl.$$rowSelect && newValue) {
            element.on('click', toggle);
          } else {
            element.off('click', toggle);
          }
        });
        scope.$watch(self.isSelected, function(isSelected) {
          return isSelected ? element.addClass('md-selected') : element.removeClass('md-selected');
        });
        tableCtrl.registerModelChangeListener(onSelectChange);
        element.on('$destroy', function() {
          tableCtrl.removeModelChangeListener(onSelectChange);
        });
      }
      return {
        bindToController: true,
        controller: Controller,
        controllerAs: '$mdSelect',
        link: postLink,
        require: ['mdSelect', '^^mdTable'],
        restrict: 'A',
        scope: {
          id: '@mdSelectId',
          model: '=mdSelect',
          disabled: '=ngDisabled',
          onSelect: '=?mdOnSelect',
          onDeselect: '=?mdOnDeselect',
          autoSelect: '=mdAutoSelect'
        }
      };
    }
    mdSelect.$inject = ['$compile'];
    angular.module('md.data.table').directive('mdTable', mdTable);
    function Hash() {
      var keys = {};
      this.equals = function(key, item) {
        return keys[key] === item;
      };
      this.get = function(key) {
        return keys[key];
      };
      this.has = function(key) {
        return keys.hasOwnProperty(key);
      };
      this.purge = function(key) {
        delete keys[key];
      };
      this.update = function(key, item) {
        keys[key] = item;
      };
    }
    function mdTable() {
      function compile(tElement, tAttrs) {
        tElement.addClass('md-table');
        if (tAttrs.hasOwnProperty('mdProgress')) {
          var body = tElement.find('tbody')[0];
          var progress = angular.element('<thead class="md-table-progress">');
          if (body) {
            tElement[0].insertBefore(progress[0], body);
          }
        }
      }
      function Controller($attrs, $element, $q, $scope) {
        var self = this;
        var queue = [];
        var watchListener;
        var modelChangeListeners = [];
        self.$$hash = new Hash();
        self.$$columns = {};
        function enableRowSelection() {
          self.$$rowSelect = true;
          watchListener = $scope.$watchCollection('$mdTable.selected', function(selected) {
            modelChangeListeners.forEach(function(listener) {
              listener(selected);
            });
          });
          $element.addClass('md-row-select');
        }
        function disableRowSelection() {
          self.$$rowSelect = false;
          if (angular.isFunction(watchListener)) {
            watchListener();
          }
          $element.removeClass('md-row-select');
        }
        function resolvePromises() {
          if (!queue.length) {
            return $scope.$applyAsync();
          }
          queue[0]['finally'](function() {
            queue.shift();
            resolvePromises();
          });
        }
        function rowSelect() {
          if ($attrs.hasOwnProperty('mdRowSelect') && $attrs.mdRowSelect === '') {
            return true;
          }
          return self.rowSelect;
        }
        function validateModel() {
          if (!self.selected) {
            return console.error('Row selection: ngModel is not defined.');
          }
          if (!angular.isArray(self.selected)) {
            return console.error('Row selection: Expected an array. Recived ' + typeof self.selected + '.');
          }
          return true;
        }
        self.columnCount = function() {
          return self.getRows($element[0]).reduce(function(count, row) {
            return row.cells.length > count ? row.cells.length : count;
          }, 0);
        };
        self.getRows = function(element) {
          return Array.prototype.filter.call(element.rows, function(row) {
            return !row.classList.contains('ng-leave');
          });
        };
        self.getBodyRows = function() {
          return Array.prototype.reduce.call($element.prop('tBodies'), function(result, tbody) {
            return result.concat(self.getRows(tbody));
          }, []);
        };
        self.getElement = function() {
          return $element;
        };
        self.getHeaderRows = function() {
          return self.getRows($element.prop('tHead'));
        };
        self.waitingOnPromise = function() {
          return !!queue.length;
        };
        self.queuePromise = function(promise) {
          if (!promise) {
            return;
          }
          if (queue.push(angular.isArray(promise) ? $q.all(promise) : $q.when(promise)) === 1) {
            resolvePromises();
          }
        };
        self.registerModelChangeListener = function(listener) {
          modelChangeListeners.push(listener);
        };
        self.removeModelChangeListener = function(listener) {
          var index = modelChangeListeners.indexOf(listener);
          if (index !== -1) {
            modelChangeListeners.splice(index, 1);
          }
        };
        if ($attrs.hasOwnProperty('mdProgress')) {
          $scope.$watch('$mdTable.progress', self.queuePromise);
        }
        $scope.$watch(rowSelect, function(enable) {
          if (enable && !!validateModel()) {
            enableRowSelection();
          } else {
            disableRowSelection();
          }
        });
      }
      Controller.$inject = ['$attrs', '$element', '$q', '$scope'];
      return {
        bindToController: true,
        compile: compile,
        controller: Controller,
        controllerAs: '$mdTable',
        restrict: 'A',
        scope: {
          progress: '=?mdProgress',
          selected: '=ngModel',
          rowSelect: '=mdRowSelect'
        }
      };
    }
    angular.module('md.data.table').directive('mdTablePagination', mdTablePagination);
    function mdTablePagination() {
      function compile(tElement) {
        tElement.addClass('md-table-pagination');
      }
      function Controller($attrs, $scope) {
        var self = this;
        self.$label = angular.extend({
          page: 'Page:',
          rowsPerPage: 'Rows per page:',
          of: 'of'
        }, $scope.$eval(self.label) || {});
        function isPositive(number) {
          return number > 0;
        }
        function isZero(number) {
          return number === 0 || number === '0';
        }
        self.disableNext = function() {
          return isZero(self.limit) || !self.hasNext();
        };
        self.first = function() {
          self.page = 1;
          self.onPaginationChange();
        };
        self.hasNext = function() {
          return self.page * self.limit < self.total;
        };
        self.hasPrevious = function() {
          return self.page > 1;
        };
        self.last = function() {
          self.page = self.pages();
          self.onPaginationChange();
        };
        self.max = function() {
          return self.hasNext() ? self.page * self.limit : self.total;
        };
        self.min = function() {
          return self.page * self.limit - self.limit;
        };
        self.next = function() {
          self.page++;
          self.onPaginationChange();
        };
        self.onPaginationChange = function() {
          if (angular.isFunction(self.onPaginate)) {
            self.onPaginate(self.page, self.limit);
          }
        };
        self.pages = function() {
          return Math.ceil(self.total / (isZero(self.limit) ? 1 : self.limit));
        };
        self.previous = function() {
          self.page--;
          self.onPaginationChange();
        };
        self.range = function(total) {
          return new Array(isFinite(total) && isPositive(total) ? total : 1);
        };
        self.showBoundaryLinks = function() {
          if ($attrs.hasOwnProperty('mdBoundaryLinks') && $attrs.mdBoundaryLinks === '') {
            return true;
          }
          return self.boundaryLinks;
        };
        self.showPageSelect = function() {
          if ($attrs.hasOwnProperty('mdPageSelect') && $attrs.mdPageSelect === '') {
            return true;
          }
          return self.pageSelect;
        };
        $scope.$watch('$pagination.limit', function(newValue, oldValue) {
          if (newValue === oldValue) {
            return;
          }
          self.page = Math.floor(((self.page * oldValue - oldValue) + newValue) / (isZero(newValue) ? 1 : newValue));
          self.onPaginationChange();
        });
      }
      Controller.$inject = ['$attrs', '$scope'];
      return {
        bindToController: {
          boundaryLinks: '=?mdBoundaryLinks',
          label: '@?mdLabel',
          limit: '=mdLimit',
          page: '=mdPage',
          pageSelect: '=?mdPageSelect',
          onPaginate: '=?mdOnPaginate',
          options: '=mdOptions',
          total: '@mdTotal'
        },
        compile: compile,
        controller: Controller,
        controllerAs: '$pagination',
        restrict: 'E',
        scope: {},
        templateUrl: 'md-table-pagination.html'
      };
    }
    angular.module('md.data.table').directive('mdTableProgress', mdTableProgress);
    function mdTableProgress() {
      function postLink(scope, element, attrs, tableCtrl) {
        scope.columnCount = tableCtrl.columnCount;
        scope.deferred = tableCtrl.waitingOnPromise;
      }
      return {
        link: postLink,
        require: '^^mdTable',
        restrict: 'C',
        scope: {},
        templateUrl: 'md-table-progress.html'
      };
    }
  })(window, angular);
  return module.exports;
});

$__System.registerDynamic("15", ["13", "14"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('13');
  $__require('14');
  module.exports = 'md.data.table';
  return module.exports;
});

$__System.registerDynamic("16", ["15"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('15');
  return module.exports;
});

$__System.registerDynamic("17", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.2/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.2',
        major: 1,
        minor: 5,
        dot: 2,
        codeName: 'differential-recovery'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function extractArgs(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || noop;
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            return {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = document.createElement('div');
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ' + (comment || '') + ' ';
            }
            return document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  removeScopeBindingWatches,
                  removeControllerBindingWatches;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (removeScopeBindingWatches) {
                  isolateScope.$on('$destroy', removeScopeBindingWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  removeControllerBindingWatches && removeControllerBindingWatches();
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                if (isFunction(controller.instance.$onInit)) {
                  controller.instance.$onInit();
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  destination[scopeName] = parentGet(scope);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newParentValue) {
                    destination[scopeName] = newParentValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            return removeWatchCollection.length && function removeWatches() {
              for (var i = 0,
                  ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            };
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals)
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals)
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length > pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option && !option.disabled) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option && !option.disabled)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function addOrReuseElement(parent, current, type, templateElement) {
            var element;
            if (current && lowercase(current.nodeName) === type) {
              element = current;
            } else {
              element = templateElement.cloneNode(false);
              if (!current) {
                parent.appendChild(element);
              } else {
                parent.insertBefore(element, current);
              }
            }
            return element;
          }
          function removeExcessElements(current) {
            var next;
            while (current) {
              next = current.nextSibling;
              jqLiteRemove(current);
              current = next;
            }
          }
          function skipEmptyAndUnknownOptions(current) {
            var emptyOption_ = emptyOption && emptyOption[0];
            var unknownOption_ = unknownOption && unknownOption[0];
            if (emptyOption_ || unknownOption_) {
              while (current && (current === emptyOption_ || current === unknownOption_ || current.nodeType === NODE_TYPE_COMMENT || (nodeName_(current) === 'option' && current.value === ''))) {
                current = current.nextSibling;
              }
            }
            return current;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            options = ngOptions.getOptions();
            var groupMap = {};
            var currentElement = selectElement[0].firstChild;
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            currentElement = skipEmptyAndUnknownOptions(currentElement);
            options.items.forEach(function updateOption(option) {
              var group;
              var groupElement;
              var optionElement;
              if (isDefined(option.group)) {
                group = groupMap[option.group];
                if (!group) {
                  groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                  currentElement = groupElement.nextSibling;
                  groupElement.label = option.group;
                  group = groupMap[option.group] = {
                    groupElement: groupElement,
                    currentOptionElement: groupElement.firstChild
                  };
                }
                optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                group.currentOptionElement = optionElement.nextSibling;
              } else {
                optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                currentElement = optionElement.nextSibling;
              }
            });
            Object.keys(groupMap).forEach(function(key) {
              removeExcessElements(groupMap[key].currentOptionElement);
            });
            removeExcessElements(currentElement);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("5", ["17"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('17');
  return module.exports;
});

$__System.registerDynamic("18", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var isArray = angular.isArray;
      var forEach = angular.forEach;
      var isString = angular.isString;
      var jqLite = angular.element;
      angular.module('ngMessages', []).directive('ngMessages', ['$animate', function($animate) {
        var ACTIVE_CLASS = 'ng-active';
        var INACTIVE_CLASS = 'ng-inactive';
        return {
          require: 'ngMessages',
          restrict: 'AE',
          controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
            var ctrl = this;
            var latestKey = 0;
            var nextAttachId = 0;
            this.getAttachId = function getAttachId() {
              return nextAttachId++;
            };
            var messages = this.messages = {};
            var renderLater,
                cachedCollection;
            this.render = function(collection) {
              collection = collection || {};
              renderLater = false;
              cachedCollection = collection;
              var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) || isAttrTruthy($scope, $attrs.multiple);
              var unmatchedMessages = [];
              var matchedKeys = {};
              var messageItem = ctrl.head;
              var messageFound = false;
              var totalMessages = 0;
              while (messageItem != null) {
                totalMessages++;
                var messageCtrl = messageItem.message;
                var messageUsed = false;
                if (!messageFound) {
                  forEach(collection, function(value, key) {
                    if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                      if (matchedKeys[key])
                        return;
                      matchedKeys[key] = true;
                      messageUsed = true;
                      messageCtrl.attach();
                    }
                  });
                }
                if (messageUsed) {
                  messageFound = !multiple;
                } else {
                  unmatchedMessages.push(messageCtrl);
                }
                messageItem = messageItem.next;
              }
              forEach(unmatchedMessages, function(messageCtrl) {
                messageCtrl.detach();
              });
              unmatchedMessages.length !== totalMessages ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS) : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
            };
            $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);
            this.reRender = function() {
              if (!renderLater) {
                renderLater = true;
                $scope.$evalAsync(function() {
                  if (renderLater) {
                    cachedCollection && ctrl.render(cachedCollection);
                  }
                });
              }
            };
            this.register = function(comment, messageCtrl) {
              var nextKey = latestKey.toString();
              messages[nextKey] = {message: messageCtrl};
              insertMessageNode($element[0], comment, nextKey);
              comment.$$ngMessageNode = nextKey;
              latestKey++;
              ctrl.reRender();
            };
            this.deregister = function(comment) {
              var key = comment.$$ngMessageNode;
              delete comment.$$ngMessageNode;
              removeMessageNode($element[0], comment, key);
              delete messages[key];
              ctrl.reRender();
            };
            function findPreviousMessage(parent, comment) {
              var prevNode = comment;
              var parentLookup = [];
              while (prevNode && prevNode !== parent) {
                var prevKey = prevNode.$$ngMessageNode;
                if (prevKey && prevKey.length) {
                  return messages[prevKey];
                }
                if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) == -1) {
                  parentLookup.push(prevNode);
                  prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
                } else {
                  prevNode = prevNode.previousSibling || prevNode.parentNode;
                }
              }
            }
            function insertMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              if (!ctrl.head) {
                ctrl.head = messageNode;
              } else {
                var match = findPreviousMessage(parent, comment);
                if (match) {
                  messageNode.next = match.next;
                  match.next = messageNode;
                } else {
                  messageNode.next = ctrl.head;
                  ctrl.head = messageNode;
                }
              }
            }
            function removeMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              var match = findPreviousMessage(parent, comment);
              if (match) {
                match.next = messageNode.next;
              } else {
                ctrl.head = messageNode.next;
              }
            }
          }]
        };
        function isAttrTruthy(scope, attr) {
          return (isString(attr) && attr.length === 0) || truthy(scope.$eval(attr));
        }
        function truthy(val) {
          return isString(val) ? val.length : !!val;
        }
      }]).directive('ngMessagesInclude', ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {
        return {
          restrict: 'AE',
          require: '^^ngMessages',
          link: function($scope, element, attrs) {
            var src = attrs.ngMessagesInclude || attrs.src;
            $templateRequest(src).then(function(html) {
              $compile(html)($scope, function(contents) {
                element.after(contents);
                var comment = $compile.$$createComment ? $compile.$$createComment('ngMessagesInclude', src) : $document[0].createComment(' ngMessagesInclude: ' + src + ' ');
                var anchor = jqLite(comment);
                element.after(anchor);
                element.remove();
              });
            });
          }
        };
      }]).directive('ngMessage', ngMessageDirectiveFactory()).directive('ngMessageExp', ngMessageDirectiveFactory());
      function ngMessageDirectiveFactory() {
        return ['$animate', function($animate) {
          return {
            restrict: 'AE',
            transclude: 'element',
            priority: 1,
            terminal: true,
            require: '^^ngMessages',
            link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
              var commentNode = element[0];
              var records;
              var staticExp = attrs.ngMessage || attrs.when;
              var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
              var assignRecords = function(items) {
                records = items ? (isArray(items) ? items : items.split(/[\s,]+/)) : null;
                ngMessagesCtrl.reRender();
              };
              if (dynamicExp) {
                assignRecords(scope.$eval(dynamicExp));
                scope.$watchCollection(dynamicExp, assignRecords);
              } else {
                assignRecords(staticExp);
              }
              var currentElement,
                  messageCtrl;
              ngMessagesCtrl.register(commentNode, messageCtrl = {
                test: function(name) {
                  return contains(records, name);
                },
                attach: function() {
                  if (!currentElement) {
                    $transclude(scope, function(elm) {
                      $animate.enter(elm, null, element);
                      currentElement = elm;
                      var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                      currentElement.on('$destroy', function() {
                        if (currentElement && currentElement.$$attachId === $$attachId) {
                          ngMessagesCtrl.deregister(commentNode);
                          messageCtrl.detach();
                        }
                      });
                    });
                  }
                },
                detach: function() {
                  if (currentElement) {
                    var elm = currentElement;
                    currentElement = null;
                    $animate.leave(elm);
                  }
                }
              });
            }
          };
        }];
        function contains(collection, key) {
          if (collection) {
            return isArray(collection) ? collection.indexOf(key) >= 0 : collection.hasOwnProperty(key);
          }
        }
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("19", ["18"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('18');
  return module.exports;
});

$__System.register("1a", [], function (_export) {
    /**
     * Created by piec on 13.03.16.
     */

    /**
     * @description Konfiguracja routera dla korzenia routera.
     * @param {type} $stateProvider
     * @param {type} $urlRouterProvider
     * @returns {undefined}
     */
    "use strict";

    function routing($stateProvider, $urlRouterProvider) {
        //******************** Defaultowy stan aplikacji ***************************\\
        $urlRouterProvider.otherwise("/app/home");
        //**************************************************************************\\

        $stateProvider.state('app', {
            url: "/app",
            templateUrl: "modules/mainApp/application/application.html",
            controller: "ApplicationController",
            controllerAs: "appCtrl"
        }).state('app.home', {
            url: "/home",
            templateUrl: "modules/mainApp/home/home.html",
            controller: "HomeController",
            controllerAs: "homeCtrl"
        }).state('test', {
            url: "/test",
            templateUrl: "modules/mainApp/test/test.html",
            controller: "TestController",
            controllerAs: "homeCtrl"
        });
    }

    return {
        setters: [],
        execute: function () {
            _export("default", routing);
        }
    };
});
$__System.register('1b', ['1c', '1d'], function (_export) {
    var _createClass, _classCallCheck, ApplicationController;

    return {
        setters: [function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * @description Glowny, najbardziej zewnetrzny kontroler. Kod z tego pliku wykona sie na kazdej podstronie.
             * @param {type} $scope
             * @returns {undefined}
             */

            'use strict';

            ApplicationController = (function () {
                function ApplicationController($scope, $log) {
                    _classCallCheck(this, ApplicationController);

                    var self = this;
                    self.$scope = $scope;
                    self.$l = $log;
                    self.setWatchers();
                }

                _createClass(ApplicationController, [{
                    key: 'setWatchers',
                    value: function setWatchers() {
                        var self = this;
                        self.$scope.$on('userObjectChange', function (event, newUser) {
                            self.user = newUser;
                        });
                    }
                }]);

                return ApplicationController;
            })();

            _export('default', ApplicationController);
        }
    };
});
$__System.register("1e", ["1c", "1d"], function (_export) {
    var _createClass, _classCallCheck, LoginModalController;

    return {
        setters: [function (_c) {
            _createClass = _c["default"];
        }, function (_d) {
            _classCallCheck = _d["default"];
        }],
        execute: function () {
            /**
             * Created by danielslaby on 14/03/16.
             */

            "use strict";

            LoginModalController = (function () {
                function LoginModalController($log, $mdDialog, loader, UserService) {
                    _classCallCheck(this, LoginModalController);

                    var self = this;
                    self.$l = $log;
                    self.$mdDialog = $mdDialog;
                    self.loader = loader;
                    self.UserService = UserService;
                    self.clearForms();
                }

                /**
                 * Remove and initialize models for forms.
                 */

                _createClass(LoginModalController, [{
                    key: "clearForms",
                    value: function clearForms() {
                        self.userLogin = {
                            login: "",
                            password: ""
                        };
                        self.userRegister = {
                            login: "",
                            password: "",
                            retypedPassword: ""
                        };
                    }

                    /**
                     * Remove modal from screen
                     */
                }, {
                    key: "closeModal",
                    value: function closeModal() {
                        var self = this;
                        self.$mdDialog.hide();
                    }

                    /**
                     * Login user by credentials.
                     */
                }, {
                    key: "login",
                    value: function login() {
                        var self = this;
                        self.loader.show();
                        self.$l.debug("login credentials", self.userLogin.login, self.userLogin.password);
                        self.UserService.login(self.userLogin).then(
                        // Success
                        function (data) {
                            self.loader.hide();
                            self.closeModal();
                        },
                        // Errors
                        function (err) {
                            self.loader.hide();
                        });
                    }

                    /**
                     * Register new user to system
                     *
                     */
                }, {
                    key: "register",
                    value: function register() {
                        var self = this;
                        self.loader.show();
                        self.UserService.register(self.userRegister).then(
                        // Success
                        function () {
                            self.loader.hide();
                            self.closeModal();
                        },
                        // Errors
                        function (err) {
                            self.loader.hide();
                        });
                    }
                }]);

                return LoginModalController;
            })();

            _export("default", LoginModalController);
        }
    };
});
$__System.register("1f", ["1d"], function (_export) {
    var _classCallCheck, HomeController;

    return {
        setters: [function (_d) {
            _classCallCheck = _d["default"];
        }],
        execute: function () {
            "use strict";

            HomeController = function HomeController($scope, $log) {
                _classCallCheck(this, HomeController);

                var self = this;
                self.$scope = $scope;
                self.$l = $log;
            };

            _export("default", HomeController);
        }
    };
});
$__System.register("20", ["1d"], function (_export) {
    var _classCallCheck, TestController;

    return {
        setters: [function (_d) {
            _classCallCheck = _d["default"];
        }],
        execute: function () {
            /**
             * Created by piec on 3/22/2016.
             */

            "use strict";

            TestController = function TestController($log, UserService) {
                _classCallCheck(this, TestController);

                var self = this;
                self.$l = $log;
            };

            _export("default", TestController);
        }
    };
});
$__System.register('21', ['22', '1c', '1d'], function (_export) {
    var User, _createClass, _classCallCheck, UserService;

    return {
        setters: [function (_) {
            User = _['default'];
        }, function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /* global CryptoJS */

            /**
             * @description Serwis odpowiedzialny za obsluge uzytkownika tj logowanie, wylogowanie, rejestracja, przechowywanie tokenu nadanego po logowaniu.
             * @param $http
             */
            'use strict';

            UserService = (function () {
                function UserService($log, $http, $state, localStorageService, $q, $rootScope, $mdDialog) {
                    _classCallCheck(this, UserService);

                    var self = this;
                    self.$l = $log;
                    self.$http = $http;
                    self.$state = $state;
                    self.$q = $q;
                    self.localStorage = localStorageService;
                    self.$rootScope = $rootScope;
                    self.$mdDialog = $mdDialog;
                    self.user = new User();
                }

                /**
                 * Login user by credentials. Return promise.
                 * @param passedUser Promise
                 * @returns {*}
                 */

                _createClass(UserService, [{
                    key: 'login',
                    value: function login(passedUser) {
                        var self = this;
                        var promise = self.$q.defer();
                        self.$http.post("/user", passedUser).then(function (received) {
                            promise.resolve(received);
                            self.user = new User(received.data.user._id, received.data.user.login, received.data.user.groups);
                            self.token = received.data.token;
                        }, function (err) {
                            promise.reject(err);
                        });
                        return promise.promise;
                    }
                }, {
                    key: 'register',

                    /**
                     * Register new user in server. Returns promise.
                     * @param passedUser
                     */
                    value: function register(passedUser) {
                        var self = this;
                        var promise = self.$q.defer();
                        self.$rootScope.$evalAsync(function () {
                            self.$http.post("/user/register", passedUser).then(function (received) {
                                promise.resolve(received);
                                self.user = new User(received.data.user.id, received.data.user.login, received.data.user.groups);
                                self.token = received.data.token;
                            }, function (err) {
                                promise.reject(err);
                            });
                        });
                        return promise.promise;
                    }
                }, {
                    key: 'logout',
                    value: function logout() {
                        var self = this;
                        self.user = new User();
                        self.token = undefined;
                    }
                }, {
                    key: 'loginByToken',
                    value: function loginByToken() {
                        var self = this;
                        var promise = self.$q.defer();
                        self.$http.post('/user/token', { "token": self.token }).then(
                        // SUCCESS
                        function (data) {
                            self.$l.debug("Data", data);
                            self.user = new User(data.data._id, data.data.login, data.data.groups);
                            promise.resolve(data);
                            // ERROR
                        }, function (err) {
                            self.token = undefined;
                            promise.resolve(err);
                        });

                        return promise.promise;
                    }

                    /**
                     * Pop up login/register modal on screen.
                     */
                }, {
                    key: 'showLoginModal',
                    value: function showLoginModal() {
                        var self = this;
                        var parentElement = angular.element(document.body);
                        self.$mdDialog.show({
                            parent: parentElement,
                            templateUrl: 'modules/mainApp/login/loginModal.html',
                            controller: 'LoginModalController',
                            controllerAs: 'loginModalCtrl'
                        });
                    }

                    /**
                     *  Checks if user has passed right
                     * @param rightsToCheck
                     * for arrays declared like:  visibility: ["user", "admin"]  pass visibility[0], for all other just pass the ["user","admin"]
                     */
                }, {
                    key: 'hasRight',
                    value: function hasRight(rightsToCheck) {
                        var self = this;
                        var hasRight = false;
                        for (var i = 0; i < rightsToCheck.length; i++) {
                            if (self.user.groups.indexOf(rightsToCheck[i]) !== -1) {
                                hasRight = true;
                                break;
                            }
                        }
                        return hasRight;
                    }
                }, {
                    key: 'token',

                    /**
                     * Returns token
                     * @returns {*}
                     */
                    get: function get() {
                        var self = this;
                        if (!self._token) {
                            self._token = self.localStorage.get('token');
                        }
                        return self._token;
                    },

                    /**
                     * Saves token to service variable and localStorage.
                     * If value is evaluated to false removes token from localStorage.
                     * @param token
                     */
                    set: function set(token) {
                        var self = this;
                        self._token = token;
                        if (token) {
                            self.localStorage.add('token', token);
                        } else {
                            self.localStorage.remove('token', token);
                        }
                    }

                    /**
                     *  Set user object in service
                     * @param user
                     */
                }, {
                    key: 'user',
                    set: function set(user) {
                        this._user = user;
                    },

                    /**
                     * Returns user object from service
                     * @returns {*|modalInstance.resolve.user|modalInstance.resolve."user"|null}
                     */
                    get: function get() {
                        return this._user;
                    }
                }]);

                return UserService;
            })();

            _export('default', UserService);
        }
    };
});
$__System.register('23', ['24', '1c', '1d'], function (_export) {
    var Moment, _createClass, _classCallCheck, Event;

    return {
        setters: [function (_) {
            Moment = _['default'];
        }, function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 3/22/2016.
             */
            'use strict';

            Event = (function () {
                function Event() {
                    var description = arguments.length <= 0 || arguments[0] === undefined ? 'test' : arguments[0];
                    var date = arguments.length <= 1 || arguments[1] === undefined ? new Moment() : arguments[1];
                    var userList = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
                    var localization = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];
                    var price = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];

                    _classCallCheck(this, Event);

                    this.description = description;
                    this.date = date;
                    this.userList = userList;
                    this.localization = localization;
                    this.price = price;
                }

                _createClass(Event, [{
                    key: 'description',
                    get: function get() {
                        return this._description;
                    },
                    set: function set(description) {
                        this._description = description;
                    }
                }, {
                    key: 'userList',
                    get: function get() {
                        return this._userList;
                    },
                    set: function set(tab) {
                        this._userList = tab;
                    }
                }, {
                    key: 'date',
                    get: function get() {
                        return this._date;
                    },
                    set: function set(date) {
                        this._date = date;
                    }
                }, {
                    key: 'localization',
                    get: function get() {
                        return this._localization;
                    },
                    set: function set(loc) {
                        this._localization = loc;
                    }
                }, {
                    key: 'price',
                    get: function get() {
                        return this._price;
                    },
                    set: function set(value) {
                        this._price = value;
                    }
                }]);

                return Event;
            })();

            _export('default', Event);
        }
    };
});
$__System.registerDynamic("25", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  ;
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
  }(this, function() {
    'use strict';
    var hookCallback;
    function utils_hooks__hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map(arr, fn) {
      var res = [],
          i;
      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    function valid__isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
        if (m._strict) {
          m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }
      }
      return m._isValid;
    }
    function valid__createInvalid(flags) {
      var m = create_utc__createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    function isUndefined(input) {
      return input === void 0;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
      var i,
          prop,
          val;
      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }
      if (!isUndefined(from._i)) {
        to._i = from._i;
      }
      if (!isUndefined(from._f)) {
        to._f = from._f;
      }
      if (!isUndefined(from._l)) {
        to._l = from._l;
      }
      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }
      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }
      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }
      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }
      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }
      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }
      if (momentProperties.length > 0) {
        for (i in momentProperties) {
          prop = momentProperties[i];
          val = from[prop];
          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }
      return to;
    }
    var updateInProgress = false;
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (updateInProgress === false) {
        updateInProgress = true;
        utils_hooks__hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number);
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
      for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function warn(msg) {
      if (utils_hooks__hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (firstTime) {
          warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }
    function isObject(input) {
      return Object.prototype.toString.call(input) === '[object Object]';
    }
    function locale_set__set(config) {
      var prop,
          i;
      for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
      this._config = config;
      this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));
          if (locale) {
            return locale;
          }
          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return null;
    }
    function loadLocale(name) {
      var oldLocale = null;
      if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          $__require('./locale/' + name);
          locale_locales__getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }
      return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = locale_locales__getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale');
          config = mergeConfigs(locales[name]._config, config);
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            config = mergeConfigs(locales[config.parentLocale]._config, config);
          } else {
            deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet');
          }
        }
        locales[name] = new Locale(config);
        locale_locales__getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale;
        if (locales[name] != null) {
          config = mergeConfigs(locales[name]._config, config);
        }
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;
        locale_locales__getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function locale_locales__getLocale(key) {
      var locale;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale = loadLocale(key);
        if (locale) {
          return locale;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function locale_locales__listLocales() {
      return Object.keys(locales);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          get_set__set(this, unit, value);
          utils_hooks__hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get_set__get(this, unit);
        }
      };
    }
    function get_set__get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }
    function get_set__set(mom, unit, value) {
      if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
    function getSet(units, value) {
      var unit;
      if (typeof units === 'object') {
        for (unit in units) {
          this.set(unit, units[unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;
      if (typeof callback === 'string') {
        func = function() {
          return this[callback]();
        };
      }
      if (token) {
        formatTokenFunctions[token] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal) {
        formatTokenFunctions[ordinal] = function() {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }
      return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = '';
        for (i = 0; i < length; i++) {
          output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
      };
    }
    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match3to4 = /\d\d\d\d?/;
    var match5to6 = /\d\d\d\d\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }
      return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
      var i,
          func = callback;
      if (typeof token === 'string') {
        token = [token];
      }
      if (typeof callback === 'number') {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }
    function addWeekParseToken(token, callback) {
      addParseToken(token, function(input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }
    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;
    function daysInMonth(year, month) {
      return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken('M', ['MM', 2], 'Mo', function() {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function(format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function(format) {
      return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function(isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function(isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m, format) {
      return isArray(this._months) ? this._months[m.month()] : this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m, format) {
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
      var i,
          mom,
          regex;
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = create_utc__createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (typeof value !== 'number') {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        utils_hooks__hooks.updateOffset(this, true);
        return this;
      } else {
        return get_set__get(this, 'Month');
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    var defaultMonthsRegex = matchWord;
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;
      for (i = 0; i < 12; i++) {
        mom = create_utc__createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }
      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
    }
    function checkOverflow(m) {
      var overflow;
      var a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });
    function createDate(y, m, d, h, M, s, ms) {
      var date = new Date(y, m, d, h, M, s, ms);
      if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
      return date;
    }
    function createUTCDate(y) {
      var date = new Date(Date.UTC.apply(null, arguments));
      if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
      return date;
    }
    addFormatToken('Y', 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
    addUnitAlias('year', 'y');
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function(input, array) {
      array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function(input, array) {
      array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', false);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy,
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(utils_hooks__hooks.now());
      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse)) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w,
          weekYear,
          week,
          weekday,
          dow,
          doy,
          temp,
          weekdayOverflow;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
        week = defaults(w.w, 1);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
      if (config._f === utils_hooks__hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }
          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;
      if (meridiem == null) {
        return hour;
      }
      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig,
          bestMoment,
          scoreToBeat,
          i,
          currentScore;
      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (!valid__isValid(tempConfig)) {
          continue;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, 'd');
        res._nextDay = undefined;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || locale_locales__getLocale(config._l);
      if (input === null || (format === undefined && input === '')) {
        return valid__createInvalid({nullInput: true});
      }
      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else if (isDate(input)) {
        config._d = input;
      } else {
        configFromInput(config);
      }
      if (!valid__isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (input === undefined) {
        config._d = new Date(utils_hooks__hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(+input);
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (typeof(input) === 'object') {
        configFromObject(config);
      } else if (typeof(input) === 'number') {
        config._d = new Date(input);
      } else {
        utils_hooks__hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};
      if (typeof(locale) === 'boolean') {
        strict = locale;
        locale = undefined;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return valid__createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
      var other = local__createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return valid__createInvalid();
      }
    });
    function pickBy(fn, moments) {
      var res,
          i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return local__createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }
    var now = function() {
      return Date.now ? Date.now() : +(new Date());
    };
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
      this._days = +days + weeks * 7;
      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = locale_locales__getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function offset(token, separator) {
      addFormatToken(token, 0, 0, function() {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
      });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = ((string || '').match(matcher) || []);
      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
      var res,
          diff;
      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
        res._d.setTime(+res._d + diff);
        utils_hooks__hooks.updateOffset(res, false);
        return res;
      } else {
        return local__createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
      var offset = this._offset || 0,
          localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);
        } else if (Math.abs(input) < 16) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }
        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            utils_hooks__hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm) {
        this.utcOffset(this._tzm);
      } else if (typeof this._i === 'string') {
        this.utcOffset(offsetFromString(matchOffset, this._i));
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? local__createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
    var isoRegex = /^(-)?P(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)W)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?$/;
    function create__createDuration(input, key) {
      var duration = input,
          match = null,
          sign,
          ret,
          diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (typeof input === 'number') {
        duration = {};
        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(match[MILLISECOND]) * sign
        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }
      return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
      var res = inp && parseFloat(inp.replace(',', '.'));
      return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
      var res = {
        milliseconds: 0,
        months: 0
      };
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur,
            tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
          tmp = val;
          val = period;
          period = tmp;
        }
        val = typeof val === 'string' ? +val : val;
        dur = create__createDuration(val, period);
        add_subtract__addSubtract(this, dur, direction);
        return this;
      };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (milliseconds) {
        mom._d.setTime(+mom._d + milliseconds * isAdding);
      }
      if (days) {
        get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
      }
      if (months) {
        setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
      }
      if (updateOffset) {
        utils_hooks__hooks.updateOffset(mom, days || months);
      }
    }
    var add_subtract__add = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');
    function moment_calendar__calendar(time, formats) {
      var now = time || local__createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          diff = this.diff(sod, 'days', true),
          format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : local__createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
      if (units === 'millisecond') {
        return +this > +localInput;
      } else {
        return +localInput < +this.clone().startOf(units);
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : local__createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
      if (units === 'millisecond') {
        return +this < +localInput;
      } else {
        return +this.clone().endOf(units) < +localInput;
      }
    }
    function isBetween(from, to, units) {
      return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : local__createLocal(input),
          inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units || 'millisecond');
      if (units === 'millisecond') {
        return +this === +localInput;
      } else {
        inputMs = +localInput;
        return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that,
          zoneDelta,
          delta,
          output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
          output = output / 3;
        } else if (units === 'year') {
          output = output / 12;
        }
      } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function moment_format__toISOString() {
      var m = this.clone().utc();
      if (0 < m.year() && m.year() <= 9999) {
        if (isFunction(Date.prototype.toISOString)) {
          return this.toDate().toISOString();
        } else {
          return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
      } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    }
    function format(inputString) {
      var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
        return create__createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
        return create__createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = locale_locales__getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
    function localeData() {
      return this._locale;
    }
    function startOf(units) {
      units = normalizeUnits(units);
      switch (units) {
        case 'year':
          this.month(0);
        case 'quarter':
        case 'month':
          this.date(1);
        case 'week':
        case 'isoWeek':
        case 'day':
          this.hours(0);
        case 'hour':
          this.minutes(0);
        case 'minute':
          this.seconds(0);
        case 'second':
          this.milliseconds(0);
      }
      if (units === 'week') {
        this.weekday(0);
      }
      if (units === 'isoWeek') {
        this.isoWeekday(1);
      }
      if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
      }
      return this;
    }
    function endOf(units) {
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond') {
        return this;
      }
      return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }
    function to_type__valueOf() {
      return +this._d - ((this._offset || 0) * 60000);
    }
    function unix() {
      return Math.floor(+this / 1000);
    }
    function toDate() {
      return this._offset ? new Date(+this) : this._d;
    }
    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function moment_valid__isValid() {
      return valid__isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken(0, ['gg', 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
      week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken('Q', 0, 'Qo', 'quarter');
    addUnitAlias('quarter', 'Q');
    addRegexToken('Q', match1);
    addParseToken('Q', function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('D', ['DD', 2], 'Do', 'date');
    addUnitAlias('date', 'D');
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function(isStrict, locale) {
      return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function(format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function(format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function(format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', matchWord);
    addRegexToken('ddd', matchWord);
    addRegexToken('dddd', matchWord);
    addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
      week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale.weekdaysParse(input);
      if (typeof input === 'number') {
        return input;
      }
      return null;
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m, format) {
      return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }
    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
      return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
      return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
      var i,
          mom,
          regex;
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = local__createLocal([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('hmm', 0, 0, function() {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function() {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function() {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function() {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function(input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function(input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return ((input + '').toLowerCase().charAt(0) === 'p');
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    }
    var getSetHour = makeGetSet('Hours', true);
    addFormatToken('m', ['mm', 2], 0, 'minute');
    addUnitAlias('minute', 'm');
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', ['ss', 2], 0, 'second');
    addUnitAlias('second', 's');
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function() {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function() {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
      return this.millisecond() * 1000000;
    });
    addUnitAlias('millisecond', 'ms');
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isSameOrAfter = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore = isSameOrBefore;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = toJSON;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.creationData = creationData;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
      return local__createLocal(input * 1000);
    }
    function moment__createInZone() {
      return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };
    function locale_calendar__calendar(key, mom, now) {
      var output = this._calendar[key];
      return isFunction(output) ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };
    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format || !formatUpper) {
        return format;
      }
      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }
    function preParsePostFormat(string) {
      return string;
    }
    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto._monthsRegex = defaultMonthsRegex;
    prototype__proto.monthsRegex = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex = monthsShortRegex;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
      var locale = locale_locales__getLocale();
      var utc = create_utc__createUTC().set(setter, index);
      return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      format = format || '';
      if (index != null) {
        return lists__get(format, index, field, setter);
      }
      var i;
      var out = [];
      for (i = 0; i < count; i++) {
        out[i] = lists__get(format, i, field, setter);
      }
      return out;
    }
    function lists__listMonths(format, index) {
      return list(format, index, 'months', 12, 'month');
    }
    function lists__listMonthsShort(format, index) {
      return list(format, index, 'monthsShort', 12, 'month');
    }
    function lists__listWeekdays(format, index) {
      return list(format, index, 'weekdays', 7, 'day');
    }
    function lists__listWeekdaysShort(format, index) {
      return list(format, index, 'weekdaysShort', 7, 'day');
    }
    function lists__listWeekdaysMin(format, index) {
      return list(format, index, 'weekdaysMin', 7, 'day');
    }
    locale_locales__getSetGlobalLocale('en', {
      ordinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
        return number + output;
      }
    });
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
      var other = create__createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
      return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds,
          minutes,
          hours,
          years,
          monthsFromDays;
      if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      }
      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24);
      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays));
      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }
    function daysToMonths(days) {
      return days * 4800 / 146097;
    }
    function monthsToDays(months) {
      return months * 146097 / 4800;
    }
    function as(units) {
      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);
      if (units === 'month' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
      } else {
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;
          case 'day':
            return days + milliseconds / 864e5;
          case 'hour':
            return days * 24 + milliseconds / 36e5;
          case 'minute':
            return days * 1440 + milliseconds / 6e4;
          case 'second':
            return days * 86400 + milliseconds / 1000;
          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;
          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    }
    function duration_as__valueOf() {
      return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');
    function duration_get__get(units) {
      units = normalizeUnits(units);
      return this[units + 's']();
    }
    function makeGetter(name) {
      return function() {
        return this._data[name];
      };
    }
    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
      var duration = create__createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }
      if (limit === undefined) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      return true;
    }
    function humanize(withSuffix) {
      var locale = this.localeData();
      var output = duration_humanize__relativeTime(this, !withSuffix, locale);
      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }
      return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
      var seconds = iso_string__abs(this._milliseconds) / 1000;
      var days = iso_string__abs(this._days);
      var months = iso_string__abs(this._months);
      var minutes,
          hours,
          years;
      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60;
      years = absFloor(months / 12);
      months %= 12;
      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds;
      var total = this.asSeconds();
      if (!total) {
        return 'P0D';
      }
      return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function(input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = '2.12.0';
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.now = now;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.updateLocale = updateLocale;
    utils_hooks__hooks.locales = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype = momentPrototype;
    var _moment = utils_hooks__hooks;
    return _moment;
  }));
  return module.exports;
});

$__System.registerDynamic("24", ["25"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('25');
  return module.exports;
});

$__System.register('26', ['23', '24', '1c', '1d'], function (_export) {
    var Event, Moment, _createClass, _classCallCheck, EventService;

    return {
        setters: [function (_) {
            Event = _['default'];
        }, function (_2) {
            Moment = _2['default'];
        }, function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 3/22/2016.
             */
            'use strict';

            EventService = (function () {
                function EventService($log) {
                    _classCallCheck(this, EventService);

                    var self = this;
                    self.$l = $log;
                    self.defaultValues();
                }

                _createClass(EventService, [{
                    key: 'defaultValues',
                    value: function defaultValues() {
                        var self = this;
                        self.events = [];
                    }
                }, {
                    key: 'events',
                    get: function get() {
                        return this._events;
                    },
                    set: function set(value) {
                        this._events = value;
                    }
                }]);

                return EventService;
            })();

            _export('default', EventService);
        }
    };
});
$__System.register('27', ['1c', '1d'], function (_export) {
    var _createClass, _classCallCheck, LoaderService;

    return {
        setters: [function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by danielslaby on 19/03/16.
             */

            'use strict';

            LoaderService = (function () {
                function LoaderService($log) {
                    _classCallCheck(this, LoaderService);

                    var self = this;
                    self.$l = $log;
                    self.$l.debug("Test Spinner");
                }

                _createClass(LoaderService, [{
                    key: 'show',
                    value: function show() {
                        var self = this;
                        $('loader').css('display', 'initial');
                    }
                }, {
                    key: 'hide',
                    value: function hide() {
                        var self = this;
                        self.$l.debug("Hide Loader");
                        $('loader').css('display', 'none');
                    }
                }]);

                return LoaderService;
            })();

            _export('default', LoaderService);
        }
    };
});
$__System.registerDynamic("28", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

$__System.registerDynamic("29", ["28"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('28');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  return module.exports;
});

$__System.registerDynamic("2a", ["29"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('29'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("1c", ["2a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$defineProperty = $__require('2a')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  return module.exports;
});

$__System.register('22', ['1d'], function (_export) {
    var _classCallCheck, User;

    return {
        setters: [function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 3/22/2016.
             */
            'use strict';

            User = function User(id, login, groups, email, firstName, lastName, phone, localization) {
                if (groups === undefined) groups = ['guest'];

                _classCallCheck(this, User);

                this.id = id;
                this.login = login;
                this.email = email;
                this.groups = groups;
                this.firstName = firstName;
                this.lastName = lastName;
                this.phone = phone;
                this.localization = localization;
            };

            _export('default', User);
        }
    };
});
$__System.register('2b', ['22', '1c', '1d'], function (_export) {
    var User, _createClass, _classCallCheck, HeaderController;

    function header() {
        return {
            restrict: 'E',
            templateUrl: 'modules/directives/header/header.html',
            controller: HeaderController,
            controllerAs: "headerCtrl"
        };
    }

    return {
        setters: [function (_) {
            User = _['default'];
        }, function (_c) {
            _createClass = _c['default'];
        }, function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 13.03.16.
             */
            'use strict';

            HeaderController = (function () {
                function HeaderController($log, localStorageService, UserService, $scope, EventService) {
                    _classCallCheck(this, HeaderController);

                    var self = this;
                    self.localStorageService = localStorageService;
                    self.UserService = UserService;
                    self.$l = $log;
                    self.$scope = $scope;
                    self.setDefaultValues();
                    self.setWatchers();
                }

                _createClass(HeaderController, [{
                    key: 'setWatchers',
                    value: function setWatchers() {
                        var self = this;
                        self.userWatch = self.$scope.$watch('headerCtrl.UserService.user', function (newUser) {
                            self.user = newUser;
                        }, true);
                    }
                }, {
                    key: 'setDefaultValues',
                    value: function setDefaultValues() {
                        var _this = this;

                        var self = this;
                        self.options = [{
                            placeholder: "Jak to działa?",
                            click: function click() {},
                            visibility: ["guest", "user"]
                        }, {
                            placeholder: "Dodaj wydarzenie",
                            click: function click() {},
                            visibility: ["user"]
                        }, {
                            placeholder: "Ustawienia konta",
                            click: function click() {},
                            visibility: ["user"]
                        }, {
                            placeholder: "CMS",
                            click: function click() {},
                            visibility: ["admin"]
                        }, {
                            placeholder: "Wyloguj",
                            click: function click() {
                                var self = _this;
                                self.UserService.logout();
                            },
                            visibility: ["user"]
                        }];
                    }
                }]);

                return HeaderController;
            })();

            _export('default', header);
        }
    };
});
$__System.register('2c', ['1d'], function (_export) {
    var _classCallCheck, FooterController;

    function footer() {
        return {
            restrict: 'E',
            templateUrl: 'modules/directives/footer/footer.html',
            controller: FooterController,
            controllerAs: "footerCtrl"
        };
    }

    return {
        setters: [function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 13.03.16.
             */'use strict';

            FooterController = function FooterController() {
                _classCallCheck(this, FooterController);

                var self = this;
            };

            _export('default', footer);
        }
    };
});
$__System.register('2d', ['1d'], function (_export) {
    var _classCallCheck, PrefooterController;

    function prefooter() {
        return {
            restrict: 'E',
            templateUrl: 'modules/directives/prefooter/prefooter.html',
            controller: PrefooterController,
            controllerAs: "prefooterCtrl"
        };
    }

    return {
        setters: [function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 13.03.16.
             */'use strict';

            PrefooterController = function PrefooterController() {
                _classCallCheck(this, PrefooterController);

                var self = this;
            };

            _export('default', prefooter);
        }
    };
});
$__System.register('2e', ['1d'], function (_export) {
    var _classCallCheck, Prefooter2Controller;

    function prefooter2() {
        return {
            restrict: 'E',
            templateUrl: 'modules/directives/prefooter2/prefooter2.html',
            controller: Prefooter2Controller,
            controllerAs: "prefooter2Ctrl"
        };
    }

    return {
        setters: [function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by piec on 13.03.16.
             */'use strict';

            Prefooter2Controller = function Prefooter2Controller() {
                _classCallCheck(this, Prefooter2Controller);

                var self = this;
            };

            _export('default', prefooter2);
        }
    };
});
$__System.register('2f', ['1d'], function (_export) {
	var _classCallCheck, LatestEventsTableController;

	function latestEventsTable() {
		return {
			restrict: 'E',
			templateUrl: 'modules/directives/latestEventsTable/latestEventsTable.html',
			controller: LatestEventsTableController,
			controllerAs: "latestEventsTableCtrl"
		};
	}

	return {
		setters: [function (_d) {
			_classCallCheck = _d['default'];
		}],
		execute: function () {
			/**
    * Created by Dammic on 14.03.16.
    */'use strict';

			LatestEventsTableController = function LatestEventsTableController() {
				_classCallCheck(this, LatestEventsTableController);

				var self = this;

				self.events = [{
					avatar: "gallery/default.gif",
					name: "Buziaczek22",
					city: "Jarosław",
					region: "Podkarpackie",
					category: "Piłka nożna",
					date: "16.11.2008",
					description: "Szukamy ludzi do gry w piłkę..."
				}, {
					avatar: "gallery/default.gif",
					name: "Mechanix",
					city: "Rzeszów",
					region: "Podkarpackie",
					category: "Siatkówka",
					date: "18.11.2008",
					description: "Witam, jestem studentem pr..."
				}, {
					avatar: "gallery/default.gif",
					name: "KochamOgorki",
					city: "Kraków",
					region: "Małopolskie",
					category: "Inne",
					date: "11.11.2008",
					description: "4 osoby, 40 zł, własny sprzę..."
				}, {
					avatar: "gallery/default.gif",
					name: "ElDammicos",
					city: "Kraków",
					region: "Małopolskie",
					category: "Siatkówka",
					date: "11.11.2666",
					description: "Chciałbym powiedzieć, że je..."
				}];
			}
			/*tu bedzie oczywiscie to wczytywane jakos
         self.options = [
   	{
                 placeholder: "Co jeszcze tu dać?",
                 click: () => {
                     
                 },
   		visibility: "guest"
             },
             {
                 placeholder: "Jak to działa?",
                 click: () => {
                     //userService.openLoginRegister();
                 },
   		visibility: "guest"
             },
   	{
                 placeholder: "Dodaj wydarzenie",
                 click: () => {
                     
                 },
   		visibility: "user"
             },
   	{
                 placeholder: "Ustawienia konta",
                 click: () => {
                     
                 },
   		visibility: "user"
             },
   	{
                 placeholder: "CMS",
                 click: () => {
                     
                 },
   		visibility: "admin"
             },
   	{
                 placeholder: "Wyloguj",
                 click: () => {
                     let self = this;
   			self.logout();
                 },
   		visibility: "user"
             }
         ];
   self.initLogin();
   }
   
   logout(){
   let self = this;
   console.log("logout");
         self.UserService.user = null;
         self.UserService.token = null;
   self.UserService.logout();
   }
   
   openLoginRegister(){
   console.log("lol");
   let self = this;
   let modalInstance = $uibModal.open(
   	{
   		templateUrl: 'modules/mainApp/views/login_registerView.html',
   		controller: 'login_registerCtrl',
   		backdrop: "static",
   		resolve: {
   			isLogged: () =>{
   				return self.isLogged;
   			}
   		}
   	}
   );
   
   modalInstance.result.then((is) => {
   	self.isLogged = is;
   }, () => {
   });
   }
   
   ///**
   // * @description Funkcja inicjalizujaca i ew. przekierowujaca do cms, gdy uzytkownik jest juz zalogowany.
   // */
			/*
   initLogin(){
   	let self = this;
   	self.userLogin = {
   		"login": "",
   		"password": ""
   	};
   	let token = self.localStorageService.get("token");
   	if (token) {
   		userService.loginByToken(token).then(
   			// SUCCESS
   			(message) => {
   				self.$evalAsync(() => {
   					self.isLogged = true;
   					self.user = userService.getUser();
   				});
   				/*$state.go("cms");*/
			// ERROR
			/*}, (message) =>{
   	console.log(message.data);
   	self.isLogged = false;
   	// usuwamy niepoprawny token
   	self.localStorageService.remove("token");
   	// MESSAGE
   }, (message) => {
   	self.isLogged = false;
   	console.log(message);
   });
   } else {
   self.isLogged = false;
   console.log("Token is empty!");
   }
   }	
   }
   */
			;

			_export('default', latestEventsTable);
		}
	};
});
$__System.register('30', [], function (_export) {
    /**
     * Created by danielslaby on 19/03/16.
     */

    'use strict';

    function RetypedPasswordValidator() {
        return {
            restrict: 'A',
            link: function link(scope, element, attr, ctrl) {
                scope.$watch('loginModalCtrl.userRegister.retypedPassword', function (retypedPassword) {
                    var password = undefined;
                    try {
                        password = scope.loginModalCtrl.userRegister.password;
                    } catch (e) {}

                    if (retypedPassword === password && retypedPassword !== undefined && retypedPassword !== '') {
                        scope.loginModalCtrl.registerForm.retypedPassword.$setValidity('notMatchingPassword', true);
                    } else {
                        scope.loginModalCtrl.registerForm.retypedPassword.$setValidity('notMatchingPassword', false);
                    }
                });
            }
        };
    }

    return {
        setters: [],
        execute: function () {
            _export('default', RetypedPasswordValidator);
        }
    };
});
$__System.registerDynamic("1d", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.register('31', ['1d'], function (_export) {
    var _classCallCheck, LoaderController;

    function LoaderDirective() {
        return {
            restrict: 'E',
            templateUrl: 'modules/directives/loader/loader.html',
            controller: LoaderController,
            controllerAs: "loaderCtrl"
        };
    }

    return {
        setters: [function (_d) {
            _classCallCheck = _d['default'];
        }],
        execute: function () {
            /**
             * Created by danielslaby on 19/03/16.
             */'use strict';

            LoaderController = function LoaderController($log) {
                _classCallCheck(this, LoaderController);

                var self = this;
                self.$l = $log;
                self.$l.debug("Dyrektywa show");
            };

            _export('default', LoaderDirective);
        }
    };
});
$__System.register('32', [], function (_export) {
    /**
     * Created by danielslaby on 20/03/16.
     */
    'use strict';

    function main(UserService, loader, $state) {
        "use strict";
        var token = UserService.token;
        if (token) {
            loader.show();
            UserService.loginByToken(token).then(
            // Success
            function () {
                loader.hide();
                $state.go('app.home');
            },
            // Error
            function () {
                loader.hide;
                $state.go('app.home');
            });
        }
    }
    return {
        setters: [],
        execute: function () {
            _export('default', main);
        }
    };
});
$__System.register('1', ['3', '5', '6', '9', '16', '19', '20', '21', '26', '27', '30', '31', '32', 'e', '1a', '1b', '1e', '1f', '2b', '2c', '2d', '2e', '2f'], function (_export) {
    /**
     * Created by piec on 13.03.16.
     */
    // -----------------------------------------------------   Libs imports          ------------------------------------------------------------------------------------------

    // ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    // -----------------------------------------------------   Other imports         ------------------------------------------------------------------------------------------

    // -----------------------------------------------------   Controllers imports   ------------------------------------------------------------------------------------------
    'use strict';

    // -----------------------------------------------------   Directives imports    ------------------------------------------------------------------------------------------

    // -----------------------------------------------------   Services imports      ------------------------------------------------------------------------------------------

    // -----------------------------------------------------   Config imports        ------------------------------------------------------------------------------------------
    var angular, ui_router, angular_local_storage, angular_material_data_table, ngMessages, TestController, UserService, EventService, LoaderService, RetypedPasswordValidatorDirective, LoaderDirective, Main, angular_material, routing, ApplicationController, LoginModalController, HomeController, HeaderDirective, FooterDirective, PrefooterDirective, Prefooter2Directive, LatestEventsTableDirective;
    return {
        setters: [function (_) {}, function (_2) {
            angular = _2;
        }, function (_3) {
            ui_router = _3;
        }, function (_4) {
            angular_local_storage = _4;
        }, function (_5) {
            angular_material_data_table = _5;
        }, function (_6) {
            ngMessages = _6;
        }, function (_7) {
            TestController = _7['default'];
        }, function (_8) {
            UserService = _8['default'];
        }, function (_9) {
            EventService = _9['default'];
        }, function (_10) {
            LoaderService = _10['default'];
        }, function (_11) {
            RetypedPasswordValidatorDirective = _11['default'];
        }, function (_12) {
            LoaderDirective = _12['default'];
        }, function (_13) {
            Main = _13['default'];
        }, function (_e) {
            angular_material = _e;
        }, function (_a) {
            routing = _a['default'];
        }, function (_b) {
            ApplicationController = _b['default'];
        }, function (_e2) {
            LoginModalController = _e2['default'];
        }, function (_f) {
            HomeController = _f['default'];
        }, function (_b2) {
            HeaderDirective = _b2['default'];
        }, function (_c) {
            FooterDirective = _c['default'];
        }, function (_d) {
            PrefooterDirective = _d['default'];
        }, function (_e3) {
            Prefooter2Directive = _e3['default'];
        }, function (_f2) {
            LatestEventsTableDirective = _f2['default'];
        }],
        execute: function () {
            angular.module("mainApp", ['ui.router', 'LocalStorageModule', 'ngMaterial', 'md.data.table', 'ngMessages']).controller("ApplicationController", ApplicationController).controller("LoginModalController", LoginModalController).controller("HomeController", HomeController).controller("TestController", TestController).service("UserService", UserService).service("EventService", EventService).service("loader", LoaderService).directive("header", HeaderDirective).directive("footer", FooterDirective).directive("prefooter", PrefooterDirective).directive("prefooter2", Prefooter2Directive).directive("latestEventsTable", LatestEventsTableDirective).directive("retypedPasswordValidator", RetypedPasswordValidatorDirective).directive("loader", LoaderDirective).config(routing).run(Main);
        }
    };
});
$__System.register('github:angular/bower-material@1.0.6/angular-material.css!github:systemjs/plugin-css@0.1.20.js', [], false, function() {});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.0.6\n */body,html{height:100%;color:rgba(0,0,0,.87);background:#fff;position:relative}body{margin:0;padding:0}[tabindex='-1']:focus{outline:0}.inset{padding:10px}button.md-no-style{font-weight:400;background-color:inherit;text-align:left;border:none;padding:0;margin:0}button,input,select,textarea{vertical-align:baseline}button,html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[type=button][disabled],input[type=reset][disabled],input[type=submit][disabled]{cursor:default}textarea{vertical-align:top;overflow:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box;-webkit-box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}.md-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;text-transform:none;width:1px}.md-shadow{position:absolute;top:0;left:0;bottom:0;right:0;border-radius:inherit;pointer-events:none}.md-shadow-bottom-z-1{box-shadow:0 2px 5px 0 rgba(0,0,0,.26)}.md-shadow-bottom-z-2{box-shadow:0 4px 8px 0 rgba(0,0,0,.4)}.md-shadow-animated.md-shadow{transition:box-shadow .28s cubic-bezier(.4,0,.2,1)}.md-ripple-container{pointer-events:none;position:absolute;overflow:hidden;left:0;top:0;width:100%;height:100%;transition:all .55s cubic-bezier(.25,.8,.25,1)}.md-ripple{position:absolute;-webkit-transform:translate(-50%,-50%) scale(0);transform:translate(-50%,-50%) scale(0);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;opacity:0;border-radius:50%}.md-ripple.md-ripple-placed{transition:margin .9s cubic-bezier(.25,.8,.25,1),border .9s cubic-bezier(.25,.8,.25,1),width .9s cubic-bezier(.25,.8,.25,1),height .9s cubic-bezier(.25,.8,.25,1),opacity .9s cubic-bezier(.25,.8,.25,1),-webkit-transform .9s cubic-bezier(.25,.8,.25,1);transition:margin .9s cubic-bezier(.25,.8,.25,1),border .9s cubic-bezier(.25,.8,.25,1),width .9s cubic-bezier(.25,.8,.25,1),height .9s cubic-bezier(.25,.8,.25,1),opacity .9s cubic-bezier(.25,.8,.25,1),transform .9s cubic-bezier(.25,.8,.25,1)}.md-ripple.md-ripple-scaled{-webkit-transform:translate(-50%,-50%) scale(1);transform:translate(-50%,-50%) scale(1)}.md-ripple.md-ripple-active,.md-ripple.md-ripple-full,.md-ripple.md-ripple-visible{opacity:.2}.md-padding{padding:8px}.md-margin{margin:8px}.md-scroll-mask{position:absolute;background-color:transparent;top:0;right:0;bottom:0;left:0}.md-scroll-mask>.md-scroll-mask-bar{display:block;position:absolute;background-color:#fafafa;right:0;top:0;bottom:0;z-index:65;box-shadow:inset 0 0 1px rgba(0,0,0,.3)}@media (min-width:960px){.md-padding{padding:16px}}body,html{-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;min-height:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.md-display-4{font-size:112px;font-weight:300;letter-spacing:-.010em;line-height:112px}.md-display-3{font-size:56px;font-weight:400;letter-spacing:-.005em;line-height:56px}.md-display-2{font-size:45px;font-weight:400;line-height:64px}.md-display-1{font-size:34px;font-weight:400;line-height:40px}.md-headline{font-size:24px;font-weight:400;line-height:32px}.md-title{font-size:20px;font-weight:500;letter-spacing:.005em}.md-subhead{font-size:16px;font-weight:400;letter-spacing:.010em;line-height:24px}.md-body-1{font-size:14px;font-weight:400;letter-spacing:.010em;line-height:20px}.md-body-2{font-size:14px;font-weight:500;letter-spacing:.010em;line-height:24px}.md-caption{font-size:12px;letter-spacing:.020em}.md-button{letter-spacing:.010em}button,html,input,select,textarea{font-family:Roboto,\"Helvetica Neue\",sans-serif}button,input,select,textarea{font-size:100%}@-webkit-keyframes md-autocomplete-list-out{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear}50%{opacity:0;height:40px;-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}100%{height:0;opacity:0}}@keyframes md-autocomplete-list-out{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear}50%{opacity:0;height:40px;-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}100%{height:0;opacity:0}}@-webkit-keyframes md-autocomplete-list-in{0%{opacity:0;height:0;-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}50%{opacity:0;height:40px}100%{opacity:1;height:40px}}@keyframes md-autocomplete-list-in{0%{opacity:0;height:0;-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}50%{opacity:0;height:40px}100%{opacity:1;height:40px}}md-autocomplete{border-radius:2px;display:block;height:40px;position:relative;overflow:visible;min-width:190px}md-autocomplete[disabled] input{cursor:default}md-autocomplete[md-floating-label]{border-radius:0;background:0 0;height:auto}md-autocomplete[md-floating-label] md-input-container{padding-bottom:26px}md-autocomplete[md-floating-label] md-input-container.md-input-has-messages{padding-bottom:2px}md-autocomplete[md-floating-label] md-autocomplete-wrap{height:auto}md-autocomplete[md-floating-label] button{position:absolute;top:auto;bottom:0;right:0;width:30px;height:30px}md-autocomplete md-autocomplete-wrap{display:block;position:relative;overflow:visible;height:40px}md-autocomplete md-autocomplete-wrap.md-menu-showing{z-index:51}md-autocomplete md-autocomplete-wrap md-progress-linear{position:absolute;bottom:-2px;left:0}md-autocomplete md-autocomplete-wrap md-progress-linear.md-inline{bottom:40px;right:2px;left:2px;width:auto}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate{position:absolute;top:0;left:0;width:100%;height:3px;transition:none}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate .md-container{transition:none;height:3px}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-enter{transition:opacity .15s linear}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-enter.ng-enter-active{opacity:1}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-leave{transition:opacity .15s linear}md-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-leave.ng-leave-active{opacity:0}md-autocomplete input:not(.md-input){font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:0;background:0 0;width:100%;padding:0 15px;line-height:40px;height:40px}md-autocomplete input:not(.md-input)::-ms-clear{display:none}md-autocomplete button{position:relative;line-height:20px;text-align:center;width:30px;height:30px;cursor:pointer;border:none;border-radius:50%;padding:0;font-size:12px;background:0 0;margin:auto 5px}md-autocomplete button:after{content:'';position:absolute;top:-6px;right:-6px;bottom:-6px;left:-6px;border-radius:50%;-webkit-transform:scale(0);transform:scale(0);opacity:0;transition:all .4s cubic-bezier(.25,.8,.25,1)}md-autocomplete button:focus{outline:0}md-autocomplete button:focus:after{-webkit-transform:scale(1);transform:scale(1);opacity:1}md-autocomplete button md-icon{position:absolute;top:50%;left:50%;-webkit-transform:translate3d(-50%,-50%,0) scale(.9);transform:translate3d(-50%,-50%,0) scale(.9)}md-autocomplete button md-icon path{stroke-width:0}md-autocomplete button.ng-enter{-webkit-transform:scale(0);transform:scale(0);transition:-webkit-transform .15s ease-out;transition:transform .15s ease-out}md-autocomplete button.ng-enter.ng-enter-active{-webkit-transform:scale(1);transform:scale(1)}md-autocomplete button.ng-leave{transition:-webkit-transform .15s ease-out;transition:transform .15s ease-out}md-autocomplete button.ng-leave.ng-leave-active{-webkit-transform:scale(0);transform:scale(0)}@media screen and (-ms-high-contrast:active){md-autocomplete input{border:1px solid #fff}md-autocomplete li:focus{color:#fff}}.md-virtual-repeat-container.md-autocomplete-suggestions-container{position:absolute;box-shadow:0 2px 5px rgba(0,0,0,.25);height:225.5px;max-height:225.5px;z-index:100}.md-virtual-repeat-container.md-not-found{height:48px}.md-autocomplete-suggestions{margin:0;list-style:none;padding:0}.md-autocomplete-suggestions li{font-size:14px;overflow:hidden;padding:0 15px;line-height:48px;height:48px;transition:background .15s linear;margin:0;white-space:nowrap;text-overflow:ellipsis}.md-autocomplete-suggestions li:focus{outline:0}.md-autocomplete-suggestions li:not(.md-not-found-wrapper){cursor:pointer}@media screen and (-ms-high-contrast:active){.md-autocomplete-suggestions,md-autocomplete{border:1px solid #fff}}md-backdrop{transition:opacity 450ms;position:absolute;top:0;bottom:0;left:0;right:0;z-index:50}md-backdrop.md-menu-backdrop{position:fixed!important;z-index:99}md-backdrop.md-select-backdrop{z-index:81;transition-duration:0}md-backdrop.md-dialog-backdrop{z-index:79}md-backdrop.md-bottom-sheet-backdrop{z-index:69}md-backdrop.md-sidenav-backdrop{z-index:59}md-backdrop.md-click-catcher{position:absolute}md-backdrop.md-opaque{opacity:.48}md-backdrop.md-opaque.ng-enter{opacity:0}md-backdrop.md-opaque.ng-enter.md-opaque.ng-enter-active{opacity:.48}md-backdrop.md-opaque.ng-leave{opacity:.48;transition:opacity .4s}md-backdrop.md-opaque.ng-leave.md-opaque.ng-leave-active{opacity:0}button.md-button::-moz-focus-inner{border:0}.md-button{border-radius:3px;box-sizing:border-box;color:currentColor;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;outline:0;border:0;display:inline-block;-webkit-align-items:center;-ms-flex-align:center;align-items:center;padding:0 6px;margin:6px 8px;line-height:36px;min-height:36px;background:0 0;white-space:nowrap;min-width:88px;text-align:center;text-transform:uppercase;font-weight:500;font-size:14px;font-style:inherit;font-variant:inherit;font-family:inherit;text-decoration:none;cursor:pointer;overflow:hidden;transition:box-shadow .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.md-button:focus{outline:0}.md-button:focus,.md-button:hover{text-decoration:none}.md-button.ng-hide,.md-button.ng-leave{transition:none}.md-button.md-cornered{border-radius:0}.md-button.md-icon{padding:0;background:0 0}.md-button.md-raised:not([disabled]){box-shadow:0 2px 5px 0 rgba(0,0,0,.26)}.md-button.md-icon-button{margin:0 6px;height:40px;min-width:0;line-height:24px;padding:8px;width:40px;border-radius:50%}.md-button.md-icon-button .md-ripple-container{border-radius:50%;background-clip:padding-box;overflow:hidden;-webkit-mask-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC)}.md-button.md-fab{z-index:20;line-height:56px;min-width:0;width:56px;height:56px;vertical-align:middle;box-shadow:0 2px 5px 0 rgba(0,0,0,.26);border-radius:50%;background-clip:padding-box;overflow:hidden;transition:all .3s cubic-bezier(.55,0,.55,.2);transition-property:background-color,box-shadow,-webkit-transform;transition-property:background-color,box-shadow,transform}.md-button.md-fab.md-fab-bottom-right{top:auto;right:20px;bottom:20px;left:auto;position:absolute}.md-button.md-fab.md-fab-bottom-left{top:auto;right:auto;bottom:20px;left:20px;position:absolute}.md-button.md-fab.md-fab-top-right{top:20px;right:20px;bottom:auto;left:auto;position:absolute}.md-button.md-fab.md-fab-top-left{top:20px;right:auto;bottom:auto;left:20px;position:absolute}.md-button.md-fab .md-ripple-container{border-radius:50%;background-clip:padding-box;overflow:hidden;-webkit-mask-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC)}.md-button.md-fab.md-mini{line-height:40px;width:40px;height:40px}.md-button.md-fab.ng-hide,.md-button.md-fab.ng-leave{transition:none}.md-button:not([disabled]).md-fab.md-focused,.md-button:not([disabled]).md-raised.md-focused{box-shadow:0 2px 5px 0 rgba(0,0,0,.26)}.md-button:not([disabled]).md-fab:active,.md-button:not([disabled]).md-raised:active{box-shadow:0 4px 8px 0 rgba(0,0,0,.4)}.md-button .md-ripple-container{border-radius:3px;background-clip:padding-box;overflow:hidden;-webkit-mask-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC)}.md-toast-open-top .md-button.md-fab-top-left,.md-toast-open-top .md-button.md-fab-top-right{transition:all .4s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate3d(0,42px,0);transform:translate3d(0,42px,0)}.md-toast-open-top .md-button.md-fab-top-left:not([disabled]).md-focused,.md-toast-open-top .md-button.md-fab-top-left:not([disabled]):hover,.md-toast-open-top .md-button.md-fab-top-right:not([disabled]).md-focused,.md-toast-open-top .md-button.md-fab-top-right:not([disabled]):hover{-webkit-transform:translate3d(0,41px,0);transform:translate3d(0,41px,0)}.md-toast-open-bottom .md-button.md-fab-bottom-left,.md-toast-open-bottom .md-button.md-fab-bottom-right{transition:all .4s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate3d(0,-42px,0);transform:translate3d(0,-42px,0)}.md-toast-open-bottom .md-button.md-fab-bottom-left:not([disabled]).md-focused,.md-toast-open-bottom .md-button.md-fab-bottom-left:not([disabled]):hover,.md-toast-open-bottom .md-button.md-fab-bottom-right:not([disabled]).md-focused,.md-toast-open-bottom .md-button.md-fab-bottom-right:not([disabled]):hover{-webkit-transform:translate3d(0,-43px,0);transform:translate3d(0,-43px,0)}.md-button-group{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1;-ms-flex:1;flex:1;width:100%}.md-button-group>.md-button{-webkit-flex:1;-ms-flex:1;flex:1;display:block;overflow:hidden;width:0;border-width:1px 0 1px 1px;border-radius:0;text-align:center;text-overflow:ellipsis;white-space:nowrap}.md-button-group>.md-button:first-child{border-radius:2px 0 0 2px}.md-button-group>.md-button:last-child{border-right-width:1px;border-radius:0 2px 2px 0}@media screen and (-ms-high-contrast:active){.md-button.md-fab,.md-button.md-raised{border:1px solid #fff}}md-card{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:8px;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12)}md-card md-card-header{padding:16px;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-card md-card-header:first-child md-card-avatar{margin-right:12px}md-card md-card-header:last-child md-card-avatar{margin-left:12px}md-card md-card-header md-card-avatar{width:40px;height:40px}md-card md-card-header md-card-avatar .md-user-avatar,md-card md-card-header md-card-avatar md-icon{border-radius:50%}md-card md-card-header md-card-avatar md-icon{padding:8px}md-card md-card-header md-card-avatar+md-card-header-text{max-height:40px}md-card md-card-header md-card-avatar+md-card-header-text .md-title{font-size:14px}md-card md-card-header md-card-header-text{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1;-ms-flex:1;flex:1;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}md-card md-card-header md-card-header-text .md-subhead{font-size:14px}md-card>:not(md-card-content) img,md-card>img{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:100%;height:auto}md-card md-card-title{padding:24px 16px 16px;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex:1;-ms-flex:1;flex:1;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-card md-card-title+md-card-content{padding-top:0}md-card md-card-title md-card-title-text{-webkit-flex:1;-ms-flex:1;flex:1;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;display:-webkit-flex;display:-ms-flexbox;display:flex}md-card md-card-title md-card-title-text .md-subhead{padding-top:0;font-size:14px}md-card md-card-title md-card-title-text:only-child .md-subhead{padding-top:12px}md-card md-card-title md-card-title-media{margin-top:-8px}md-card md-card-title md-card-title-media .md-media-sm{height:80px;width:80px}md-card md-card-title md-card-title-media .md-media-md{height:112px;width:112px}md-card md-card-title md-card-title-media .md-media-lg{height:152px;width:152px}md-card md-card-content{display:block;padding:16px}md-card md-card-content>p:first-child{margin-top:0}md-card md-card-content>p:last-child{margin-bottom:0}md-card md-card-content .md-media-xl{height:240px;width:240px}md-card .md-actions,md-card md-card-actions{margin:8px}md-card .md-actions.layout-column .md-button:not(.md-icon-button),md-card md-card-actions.layout-column .md-button:not(.md-icon-button){margin:2px 0}md-card .md-actions.layout-column .md-button:not(.md-icon-button):first-of-type,md-card md-card-actions.layout-column .md-button:not(.md-icon-button):first-of-type{margin-top:0}md-card .md-actions.layout-column .md-button:not(.md-icon-button):last-of-type,md-card md-card-actions.layout-column .md-button:not(.md-icon-button):last-of-type{margin-bottom:0}md-card .md-actions.layout-column .md-button.md-icon-button,md-card md-card-actions.layout-column .md-button.md-icon-button{margin-top:6px;margin-bottom:6px}md-card .md-actions md-card-icon-actions,md-card md-card-actions md-card-icon-actions{-webkit-flex:1;-ms-flex:1;flex:1;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-card .md-actions:not(.layout-column) .md-button:not(.md-icon-button),md-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button){margin:0 4px}md-card .md-actions:not(.layout-column) .md-button:not(.md-icon-button):first-of-type,md-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):first-of-type{margin-left:0}md-card .md-actions:not(.layout-column) .md-button:not(.md-icon-button):last-of-type,md-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):last-of-type{margin-right:0}md-card .md-actions:not(.layout-column) .md-button.md-icon-button,md-card md-card-actions:not(.layout-column) .md-button.md-icon-button{margin-left:6px;margin-right:6px}md-card .md-actions:not(.layout-column) .md-button.md-icon-button:first-of-type,md-card md-card-actions:not(.layout-column) .md-button.md-icon-button:first-of-type{margin-left:12px}md-card .md-actions:not(.layout-column) .md-button.md-icon-button:last-of-type,md-card md-card-actions:not(.layout-column) .md-button.md-icon-button:last-of-type{margin-right:12px}md-card .md-actions:not(.layout-column) .md-button+md-card-icon-actions,md-card md-card-actions:not(.layout-column) .md-button+md-card-icon-actions{-webkit-flex:1;-ms-flex:1;flex:1;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-card md-card-footer{margin-top:auto;padding:16px}@media screen and (-ms-high-contrast:active){md-card{border:1px solid #fff}}.md-inline-form md-checkbox{margin:19px 0 18px}md-checkbox{box-sizing:border-box;display:inline-block;margin-bottom:16px;white-space:nowrap;cursor:pointer;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;min-width:20px;min-height:20px;margin-left:inherit;margin-right:16px}html[dir=rtl] md-checkbox{margin-left:16px;unicode-bidi:embed}body[dir=rtl] md-checkbox{margin-left:16px;unicode-bidi:embed}md-checkbox bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-checkbox{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-checkbox{margin-right:inherit;unicode-bidi:embed}md-checkbox bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-checkbox:last-of-type{margin-left:inherit;margin-right:0}html[dir=rtl] md-checkbox:last-of-type{margin-left:0;unicode-bidi:embed}body[dir=rtl] md-checkbox:last-of-type{margin-left:0;unicode-bidi:embed}md-checkbox:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-checkbox:last-of-type{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-checkbox:last-of-type{margin-right:inherit;unicode-bidi:embed}md-checkbox:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-checkbox.md-focused:not([disabled]) .md-container:before{left:-8px;top:-8px;right:-8px;bottom:-8px}md-checkbox.md-focused:not([disabled]):not(.md-checked) .md-container:before{background-color:rgba(0,0,0,.12)}md-checkbox .md-container{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);box-sizing:border-box;display:inline-block;width:20px;height:20px;left:0;right:auto}html[dir=rtl] md-checkbox .md-container{left:auto;unicode-bidi:embed}body[dir=rtl] md-checkbox .md-container{left:auto;unicode-bidi:embed}md-checkbox .md-container bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox .md-container bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-checkbox .md-container{right:0;unicode-bidi:embed}body[dir=rtl] md-checkbox .md-container{right:0;unicode-bidi:embed}md-checkbox .md-container bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox .md-container bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-checkbox .md-container:before{box-sizing:border-box;background-color:transparent;border-radius:50%;content:'';position:absolute;display:block;height:auto;left:0;top:0;right:0;bottom:0;transition:all .5s;width:auto}md-checkbox .md-container:after{box-sizing:border-box;content:'';position:absolute;top:-10px;right:-10px;bottom:-10px;left:-10px}md-checkbox .md-container .md-ripple-container{position:absolute;display:block;width:auto;height:auto;left:-15px;top:-15px;right:-15px;bottom:-15px}md-checkbox.md-align-top-left>div.md-container{top:12px}md-checkbox .md-icon{box-sizing:border-box;transition:240ms;position:absolute;top:0;left:0;width:20px;height:20px;border-width:2px;border-style:solid;border-radius:2px}md-checkbox.md-checked .md-icon{border:none}md-checkbox[disabled]{cursor:default}md-checkbox.md-checked .md-icon:after{box-sizing:border-box;-webkit-transform:rotate(45deg);transform:rotate(45deg);position:absolute;left:6.67px;top:2.22px;display:table;width:6.67px;height:13.33px;border-width:2px;border-style:solid;border-top:0;border-left:0;content:''}md-checkbox .md-label{box-sizing:border-box;position:relative;display:inline-block;vertical-align:middle;white-space:normal;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;margin-left:30px;margin-right:0}html[dir=rtl] md-checkbox .md-label{margin-left:0;unicode-bidi:embed}body[dir=rtl] md-checkbox .md-label{margin-left:0;unicode-bidi:embed}md-checkbox .md-label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox .md-label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-checkbox .md-label{margin-right:30px;unicode-bidi:embed}body[dir=rtl] md-checkbox .md-label{margin-right:30px;unicode-bidi:embed}md-checkbox .md-label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-checkbox .md-label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-bottom-sheet{position:absolute;left:0;right:0;bottom:0;padding:8px 16px 88px 16px;z-index:70;border-top-width:1px;border-top-style:solid;-webkit-transform:translate3d(0,80px,0);transform:translate3d(0,80px,0);transition:all .4s cubic-bezier(.25,.8,.25,1);transition-property:-webkit-transform;transition-property:transform}md-bottom-sheet.md-has-header{padding-top:0}md-bottom-sheet.ng-enter{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}md-bottom-sheet.ng-enter-active{opacity:1;display:block;-webkit-transform:translate3d(0,80px,0)!important;transform:translate3d(0,80px,0)!important}md-bottom-sheet.ng-leave-active{-webkit-transform:translate3d(0,100%,0)!important;transform:translate3d(0,100%,0)!important;transition:all .3s cubic-bezier(.55,0,.55,.2)}md-bottom-sheet .md-subheader{background-color:transparent;font-family:Roboto,\"Helvetica Neue\",sans-serif;line-height:56px;padding:0;white-space:nowrap}md-bottom-sheet md-inline-icon{display:inline-block;height:24px;width:24px;fill:#444}md-bottom-sheet md-list-item{display:-webkit-flex;display:-ms-flexbox;display:flex;outline:0}md-bottom-sheet md-list-item:hover{cursor:pointer}md-bottom-sheet.md-list md-list-item{padding:0;-webkit-align-items:center;-ms-flex-align:center;align-items:center;height:48px}md-bottom-sheet.md-list md-list-item div.md-icon-container{display:inline-block;height:24px;margin-right:32px}md-bottom-sheet.md-grid{padding-left:24px;padding-right:24px;padding-top:0}md-bottom-sheet.md-grid md-list{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;transition:all .5s;-webkit-align-items:center;-ms-flex-align:center;align-items:center}md-bottom-sheet.md-grid md-list-item{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-ms-flex-align:center;align-items:center;transition:all .5s;height:96px;margin-top:8px;margin-bottom:8px}@media screen and (max-width:960px){md-bottom-sheet.md-grid md-list-item{-webkit-flex:1 1 33.33333%;-ms-flex:1 1 33.33333%;flex:1 1 33.33333%;max-width:33.33333%}md-bottom-sheet.md-grid md-list-item:nth-of-type(3n+1){-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}md-bottom-sheet.md-grid md-list-item:nth-of-type(3n){-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end}}@media screen and (min-width:960px) and (max-width:1279px){md-bottom-sheet.md-grid md-list-item{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%}}@media screen and (min-width:1280px) and (max-width:1919px){md-bottom-sheet.md-grid md-list-item{-webkit-flex:1 1 16.66667%;-ms-flex:1 1 16.66667%;flex:1 1 16.66667%;max-width:16.66667%}}@media screen and (min-width:1920px){md-bottom-sheet.md-grid md-list-item{-webkit-flex:1 1 14.28571%;-ms-flex:1 1 14.28571%;flex:1 1 14.28571%;max-width:14.28571%}}md-bottom-sheet.md-grid md-list-item .md-list-item-content{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-ms-flex-align:center;align-items:center;width:48px;padding-bottom:16px}md-bottom-sheet.md-grid md-list-item .md-grid-item-content{border:1px solid transparent;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-ms-flex-align:center;align-items:center;width:80px}md-bottom-sheet.md-grid md-list-item .md-icon-container{display:inline-block;box-sizing:border-box;height:48px;width:48px;margin:0 0}md-bottom-sheet.md-grid md-list-item .md-grid-text{font-weight:400;line-height:16px;font-size:13px;margin:0;white-space:nowrap;width:64px;text-align:center;text-transform:none;padding-top:8px}@media screen and (-ms-high-contrast:active){md-bottom-sheet{border:1px solid #fff}}.md-contact-chips .md-chips .md-chip{padding:0 25px 0 0}.md-contact-chips .md-chips .md-chip .md-contact-avatar{float:left}.md-contact-chips .md-chips .md-chip .md-contact-avatar img{height:32px;border-radius:16px}.md-contact-chips .md-chips .md-chip .md-contact-name{display:inline-block;height:32px;margin-left:8px}.md-contact-suggestion{height:56px}.md-contact-suggestion img{height:40px;border-radius:20px;margin-top:8px}.md-contact-suggestion .md-contact-name{margin-left:8px;width:120px}.md-contact-suggestion .md-contact-email,.md-contact-suggestion .md-contact-name{display:inline-block;overflow:hidden;text-overflow:ellipsis}.md-contact-chips-suggestions li{height:100%}.md-chips{display:block;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:16px;padding:0 0 8px 3px;vertical-align:middle}.md-chips:after{content:'';display:table;clear:both}.md-chips:not(.md-readonly){cursor:text}.md-chips:not(.md-readonly) .md-chip:not(.md-readonly){padding-right:22px}.md-chips:not(.md-readonly) .md-chip:not(.md-readonly) .md-chip-content{padding-right:4px}.md-chips .md-chip{cursor:default;border-radius:16px;display:block;height:32px;line-height:32px;margin:8px 8px 0 0;padding:0 12px 0 12px;float:left;box-sizing:border-box;max-width:100%;position:relative}.md-chips .md-chip .md-chip-content{display:block;float:left;white-space:nowrap;max-width:100%;overflow:hidden;text-overflow:ellipsis}.md-chips .md-chip .md-chip-content:focus{outline:0}.md-chips .md-chip .md-chip-remove-container{position:absolute;right:0;line-height:22px}.md-chips .md-chip .md-chip-remove{text-align:center;width:32px;height:32px;min-width:0;padding:0;background:0 0;border:none;box-shadow:none;margin:0;position:relative}.md-chips .md-chip .md-chip-remove md-icon{height:18px;width:18px;position:absolute;top:50%;left:50%;-webkit-transform:translate3d(-50%,-50%,0);transform:translate3d(-50%,-50%,0)}.md-chips .md-chip-input-container{display:block;line-height:32px;margin:8px 8px 0 0;padding:0;float:left}.md-chips .md-chip-input-container input:not([type]),.md-chips .md-chip-input-container input[type=url],.md-chips .md-chip-input-container input[type=text],.md-chips .md-chip-input-container input[type=email],.md-chips .md-chip-input-container input[type=number],.md-chips .md-chip-input-container input[type=tel]{border:0;height:32px;line-height:32px;padding:0}.md-chips .md-chip-input-container input:not([type]):focus,.md-chips .md-chip-input-container input[type=url]:focus,.md-chips .md-chip-input-container input[type=text]:focus,.md-chips .md-chip-input-container input[type=email]:focus,.md-chips .md-chip-input-container input[type=number]:focus,.md-chips .md-chip-input-container input[type=tel]:focus{outline:0}.md-chips .md-chip-input-container md-autocomplete,.md-chips .md-chip-input-container md-autocomplete-wrap{background:0 0;height:32px}.md-chips .md-chip-input-container md-autocomplete md-autocomplete-wrap{box-shadow:none}.md-chips .md-chip-input-container md-autocomplete input{position:relative}.md-chips .md-chip-input-container input{border:0;height:32px;line-height:32px;padding:0}.md-chips .md-chip-input-container input:focus{outline:0}.md-chips .md-chip-input-container md-autocomplete,.md-chips .md-chip-input-container md-autocomplete-wrap{height:32px}.md-chips .md-chip-input-container md-autocomplete{box-shadow:none}.md-chips .md-chip-input-container md-autocomplete input{position:relative}.md-chips .md-chip-input-container:not(:first-child){margin:8px 8px 0 0}.md-chips .md-chip-input-container input{background:0 0;border-width:0}.md-chips md-autocomplete button{display:none}@media screen and (-ms-high-contrast:active){.md-chip-input-container,md-chip{border:1px solid #fff}.md-chip-input-container md-autocomplete{border:none}}.md-dialog-is-showing{max-height:100%}.md-dialog-container{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:absolute;top:0;left:0;width:100%;height:100%;z-index:80;overflow:hidden}md-dialog{opacity:0;min-width:240px;max-width:80%;max-height:80%;position:relative;overflow:auto;box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 13px 19px 2px rgba(0,0,0,.14),0 5px 24px 4px rgba(0,0,0,.12);display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}md-dialog.md-transition-in{opacity:1;transition:all .4s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate(0,0) scale(1);transform:translate(0,0) scale(1)}md-dialog.md-transition-out{opacity:0;transition:all .4s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate(0,100%) scale(.2);transform:translate(0,100%) scale(.2)}md-dialog>form{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:auto}md-dialog .md-dialog-content{padding:24px}md-dialog md-dialog-content{-webkit-order:1;-ms-flex-order:1;order:1;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:auto;-webkit-overflow-scrolling:touch}md-dialog md-dialog-content:not([layout=row])>:first-child:not(.md-subheader){margin-top:0}md-dialog md-dialog-content:focus{outline:0}md-dialog md-dialog-content .md-subheader{margin:0}md-dialog md-dialog-content .md-subheader.sticky-clone{box-shadow:0 2px 4px 0 rgba(0,0,0,.16)}md-dialog md-dialog-content.sticky-container{padding:0}md-dialog md-dialog-content.sticky-container>div{padding:24px;padding-top:0}md-dialog md-dialog-content .md-dialog-content-body{width:100%}md-dialog .md-actions,md-dialog md-dialog-actions{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-order:2;-ms-flex-order:2;order:2;box-sizing:border-box;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end;margin-bottom:0;padding-right:8px;padding-left:16px;min-height:52px;overflow:hidden}md-dialog .md-actions .md-button,md-dialog md-dialog-actions .md-button{margin-bottom:8px;margin-left:8px;margin-right:0;margin-top:8px}md-dialog.md-content-overflow .md-actions,md-dialog.md-content-overflow md-dialog-actions{border-top-width:1px;border-top-style:solid}@media screen and (-ms-high-contrast:active){md-dialog{border:1px solid #fff}}@media (max-width:959px){md-dialog.md-dialog-fullscreen{min-height:100%;min-width:100%;border-radius:0}}md-divider{display:block;border-top-width:1px;border-top-style:solid;margin:0}md-divider[md-inset]{margin-left:80px}.layout-row>md-divider{border-top-width:0;border-right-width:1px;border-right-style:solid}md-calendar{font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md-calendar-scroll-mask{display:inline-block;overflow:hidden;height:308px}.md-calendar-scroll-mask .md-virtual-repeat-scroller{overflow-y:scroll;-webkit-overflow-scrolling:touch}.md-calendar-scroll-mask .md-virtual-repeat-scroller::-webkit-scrollbar{display:none}.md-calendar-scroll-mask .md-virtual-repeat-offsetter{width:100%}.md-calendar-scroll-container{box-shadow:inset -3px 3px 6px rgba(0,0,0,.2);display:inline-block;height:308px;width:346px}.md-calendar-date{height:44px;width:44px;text-align:center;padding:0;border:none}.md-calendar-date:first-child{padding-left:16px}.md-calendar-date:last-child{padding-right:16px}.md-calendar-date.md-calendar-date-disabled{cursor:default}.md-calendar-date-selection-indicator{transition:background-color,color .4s cubic-bezier(.25,.8,.25,1);border-radius:50%;display:inline-block;width:40px;height:40px;line-height:40px}.md-calendar-date:not(.md-disabled) .md-calendar-date-selection-indicator{cursor:pointer}.md-calendar-month-label{height:44px;font-size:14px;font-weight:500;padding:0 0 0 24px}.md-calendar-day-header{table-layout:fixed;border-spacing:0;border-collapse:collapse}.md-calendar-day-header th{height:44px;width:44px;text-align:center;padding:0;border:none;font-weight:400;height:40px}.md-calendar-day-header th:first-child{padding-left:16px}.md-calendar-day-header th:last-child{padding-right:16px}.md-calendar{table-layout:fixed;border-spacing:0;border-collapse:collapse}.md-calendar tr:last-child td{border-bottom-width:1px;border-bottom-style:solid}.md-calendar:first-child{border-top:1px solid transparent}md-datepicker{white-space:nowrap;overflow:hidden;padding-right:18px;margin-right:-18px;vertical-align:middle}.md-inline-form md-datepicker{margin-top:12px}.md-datepicker-button{display:inline-block;box-sizing:border-box;background:0 0}.md-datepicker-input{font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:0;background:0 0;min-width:120px;max-width:328px}.md-datepicker-input::-ms-clear{display:none}.md-datepicker-input-container{position:relative;padding-bottom:5px;border-bottom-width:1px;border-bottom-style:solid;display:inline-block;width:auto;margin-left:12px}.md-datepicker-input-container.md-datepicker-focused{border-bottom-width:2px}.md-datepicker-calendar-pane{position:absolute;top:0;left:0;z-index:100;border-width:1px;border-style:solid;background:0 0;-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:0 0;transform-origin:0 0;transition:-webkit-transform .2s cubic-bezier(.25,.8,.25,1);transition:transform .2s cubic-bezier(.25,.8,.25,1)}.md-datepicker-calendar-pane.md-pane-open{-webkit-transform:scale(1);transform:scale(1)}.md-datepicker-input-mask{height:40px;width:340px;position:relative;background:0 0;pointer-events:none;cursor:text}.md-datepicker-input-mask-opaque{position:absolute;right:0;left:120px;height:100%}.md-datepicker-calendar{opacity:0;transition:opacity .2s cubic-bezier(.5,0,.25,1)}.md-pane-open .md-datepicker-calendar{opacity:1}.md-datepicker-calendar md-calendar:focus{outline:0}.md-datepicker-expand-triangle{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid}.md-datepicker-triangle-button{position:absolute;right:0;top:0;-webkit-transform:translateY(-25%) translateX(45%);transform:translateY(-25%) translateX(45%)}.md-datepicker-triangle-button.md-button.md-icon-button{height:100%;width:36px;position:absolute}md-datepicker[disabled] .md-datepicker-input-container{border-bottom-color:transparent}md-datepicker[disabled] .md-datepicker-triangle-button{display:none}.md-datepicker-open .md-datepicker-input-container{margin-left:-12px;border:none}.md-datepicker-open .md-datepicker-input{margin-left:24px;height:40px}.md-datepicker-open .md-datepicker-triangle-button{display:none}.md-datepicker-pos-adjusted .md-datepicker-input-mask{display:none}.md-datepicker-calendar-pane .md-calendar{-webkit-transform:translateY(-85px);transform:translateY(-85px);transition:-webkit-transform .65s cubic-bezier(.25,.8,.25,1);transition:transform .65s cubic-bezier(.25,.8,.25,1);transition-delay:125ms}.md-datepicker-calendar-pane.md-pane-open .md-calendar{-webkit-transform:translateY(0);transform:translateY(0)}md-content{display:block;position:relative;overflow:auto;-webkit-overflow-scrolling:touch}md-content[md-scroll-y]{overflow-y:auto;overflow-x:hidden}md-content[md-scroll-x]{overflow-x:auto;overflow-y:hidden}md-content.autoScroll{-webkit-overflow-scrolling:auto}md-fab-speed-dial{position:relative;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;z-index:20}md-fab-speed-dial.md-fab-bottom-right{top:auto;right:20px;bottom:20px;left:auto;position:absolute}md-fab-speed-dial.md-fab-bottom-left{top:auto;right:auto;bottom:20px;left:20px;position:absolute}md-fab-speed-dial.md-fab-top-right{top:20px;right:20px;bottom:auto;left:auto;position:absolute}md-fab-speed-dial.md-fab-top-left{top:20px;right:auto;bottom:auto;left:20px;position:absolute}md-fab-speed-dial:not(.md-hover-full){pointer-events:none}md-fab-speed-dial:not(.md-hover-full) .md-fab-action-item,md-fab-speed-dial:not(.md-hover-full) md-fab-trigger{pointer-events:auto}md-fab-speed-dial:not(.md-hover-full).md-is-open{pointer-events:auto}md-fab-speed-dial .md-css-variables{z-index:20}md-fab-speed-dial.md-is-open .md-fab-action-item{-webkit-align-items:center;-ms-flex-align:center;align-items:center}md-fab-speed-dial md-fab-actions{display:-webkit-flex;display:-ms-flexbox;display:flex;height:auto}md-fab-speed-dial md-fab-actions .md-fab-action-item{transition:all .3s cubic-bezier(.55,0,.55,.2)}md-fab-speed-dial.md-down{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}md-fab-speed-dial.md-down md-fab-trigger{-webkit-order:1;-ms-flex-order:1;order:1}md-fab-speed-dial.md-down md-fab-actions{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-order:2;-ms-flex-order:2;order:2}md-fab-speed-dial.md-up{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}md-fab-speed-dial.md-up md-fab-trigger{-webkit-order:2;-ms-flex-order:2;order:2}md-fab-speed-dial.md-up md-fab-actions{-webkit-flex-direction:column-reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse;-webkit-order:1;-ms-flex-order:1;order:1}md-fab-speed-dial.md-left{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-fab-speed-dial.md-left md-fab-trigger{-webkit-order:2;-ms-flex-order:2;order:2}md-fab-speed-dial.md-left md-fab-actions{-webkit-flex-direction:row-reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse;-webkit-order:1;-ms-flex-order:1;order:1}md-fab-speed-dial.md-left md-fab-actions .md-fab-action-item{transition:all .3s cubic-bezier(.55,0,.55,.2)}md-fab-speed-dial.md-right{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-fab-speed-dial.md-right md-fab-trigger{-webkit-order:1;-ms-flex-order:1;order:1}md-fab-speed-dial.md-right md-fab-actions{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-order:2;-ms-flex-order:2;order:2}md-fab-speed-dial.md-right md-fab-actions .md-fab-action-item{transition:all .3s cubic-bezier(.55,0,.55,.2)}md-fab-speed-dial.md-fling-remove .md-fab-action-item>*,md-fab-speed-dial.md-scale-remove .md-fab-action-item>*{visibility:hidden}md-fab-speed-dial.md-fling .md-fab-action-item{opacity:1}md-fab-speed-dial.md-fling.md-animations-waiting .md-fab-action-item{opacity:0;transition-duration:0s}md-fab-speed-dial.md-scale .md-fab-action-item{-webkit-transform:scale(0);transform:scale(0);transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:.14286s}md-fab-toolbar{display:block}md-fab-toolbar.md-fab-bottom-right{top:auto;right:20px;bottom:20px;left:auto;position:absolute}md-fab-toolbar.md-fab-bottom-left{top:auto;right:auto;bottom:20px;left:20px;position:absolute}md-fab-toolbar.md-fab-top-right{top:20px;right:20px;bottom:auto;left:auto;position:absolute}md-fab-toolbar.md-fab-top-left{top:20px;right:auto;bottom:auto;left:20px;position:absolute}md-fab-toolbar .md-fab-toolbar-wrapper{display:block;position:relative;overflow:hidden;height:68px}md-fab-toolbar md-fab-trigger{position:absolute;z-index:20}md-fab-toolbar md-fab-trigger button{overflow:visible!important}md-fab-toolbar md-fab-trigger .md-fab-toolbar-background{display:block;position:absolute;z-index:21;opacity:1;transition:all .3s cubic-bezier(.55,0,.55,.2)}md-fab-toolbar md-fab-trigger md-icon{position:relative;z-index:22;opacity:1;transition:all .2s ease-in}md-fab-toolbar.md-left md-fab-trigger{right:0}md-fab-toolbar.md-left .md-toolbar-tools{-webkit-flex-direction:row-reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}md-fab-toolbar.md-left .md-toolbar-tools>.md-button:first-child{margin-right:.6rem}md-fab-toolbar.md-left .md-toolbar-tools>.md-button:first-child{margin-left:-.8rem}md-fab-toolbar.md-left .md-toolbar-tools>.md-button:last-child{margin-right:8px}md-fab-toolbar.md-right md-fab-trigger{left:0}md-fab-toolbar.md-right .md-toolbar-tools{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-fab-toolbar md-toolbar{background-color:transparent!important;pointer-events:none;z-index:23}md-fab-toolbar md-toolbar .md-toolbar-tools{padding:0 20px;margin-top:3px}md-fab-toolbar md-toolbar .md-fab-action-item{opacity:0;-webkit-transform:scale(0);transform:scale(0);transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:.15s}md-fab-toolbar.md-is-open md-fab-trigger>button{box-shadow:none}md-fab-toolbar.md-is-open md-fab-trigger>button md-icon{opacity:0}md-fab-toolbar.md-is-open .md-fab-action-item{opacity:1;-webkit-transform:scale(1);transform:scale(1)}md-grid-list{box-sizing:border-box;display:block;position:relative}md-grid-list md-grid-tile,md-grid-list md-grid-tile-footer,md-grid-list md-grid-tile-header,md-grid-list md-grid-tile>figure{box-sizing:border-box}md-grid-list md-grid-tile{display:block;position:absolute}md-grid-list md-grid-tile figure{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;height:100%;position:absolute;top:0;right:0;bottom:0;left:0;padding:0;margin:0}md-grid-list md-grid-tile md-grid-tile-footer,md-grid-list md-grid-tile md-grid-tile-header{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-ms-flex-align:center;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.18);overflow:hidden;position:absolute;left:0;right:0}md-grid-list md-grid-tile md-grid-tile-footer h3,md-grid-list md-grid-tile md-grid-tile-footer h4,md-grid-list md-grid-tile md-grid-tile-header h3,md-grid-list md-grid-tile md-grid-tile-header h4{font-weight:400;margin:0 0 0 16px}md-grid-list md-grid-tile md-grid-tile-footer h3,md-grid-list md-grid-tile md-grid-tile-header h3{font-size:14px}md-grid-list md-grid-tile md-grid-tile-footer h4,md-grid-list md-grid-tile md-grid-tile-header h4{font-size:12px}md-grid-list md-grid-tile md-grid-tile-header{top:0}md-grid-list md-grid-tile md-grid-tile-footer{bottom:0}@media screen and (-ms-high-contrast:active){md-grid-tile{border:1px solid #fff}md-grid-tile-footer{border-top:1px solid #fff}}md-icon{margin:auto;background-repeat:no-repeat no-repeat;display:inline-block;vertical-align:middle;fill:currentColor;height:24px;width:24px}md-icon svg{pointer-events:none;display:block}md-icon[md-font-icon]{line-height:1;width:auto}md-input-container{display:inline-block;position:relative;padding:2px;margin:18px 0;vertical-align:middle}md-input-container:after{content:'';display:table;clear:both}md-input-container.md-block{display:block}md-input-container .md-errors-spacer{float:right;min-height:24px;min-width:1px}html[dir=rtl] md-input-container .md-errors-spacer{float:left;unicode-bidi:embed}body[dir=rtl] md-input-container .md-errors-spacer{float:left;unicode-bidi:embed}md-input-container .md-errors-spacer bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-errors-spacer bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container>md-icon{position:absolute;top:5px;left:2px;right:auto}html[dir=rtl] md-input-container>md-icon{left:auto;unicode-bidi:embed}body[dir=rtl] md-input-container>md-icon{left:auto;unicode-bidi:embed}md-input-container>md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container>md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container>md-icon{right:2px;unicode-bidi:embed}body[dir=rtl] md-input-container>md-icon{right:2px;unicode-bidi:embed}md-input-container>md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container>md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container input[type=url],md-input-container input[type=text],md-input-container input[type=password],md-input-container input[type=datetime],md-input-container input[type=datetime-local],md-input-container input[type=date],md-input-container input[type=month],md-input-container input[type=time],md-input-container input[type=week],md-input-container input[type=color],md-input-container input[type=search],md-input-container input[type=email],md-input-container input[type=number],md-input-container input[type=tel],md-input-container textarea{-moz-appearance:none;-webkit-appearance:none}md-input-container input[type=datetime-local],md-input-container input[type=date],md-input-container input[type=month],md-input-container input[type=time],md-input-container input[type=week]{min-height:26px}md-input-container textarea{resize:none;overflow:hidden}md-input-container textarea.md-input{min-height:26px;-ms-flex-preferred-size:auto}md-input-container label:not(.md-container-ignore){position:absolute;bottom:100%;left:0;right:auto}html[dir=rtl] md-input-container label:not(.md-container-ignore){left:auto;unicode-bidi:embed}body[dir=rtl] md-input-container label:not(.md-container-ignore){left:auto;unicode-bidi:embed}md-input-container label:not(.md-container-ignore) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container label:not(.md-container-ignore) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container label:not(.md-container-ignore){right:0;unicode-bidi:embed}body[dir=rtl] md-input-container label:not(.md-container-ignore){right:0;unicode-bidi:embed}md-input-container label:not(.md-container-ignore) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container label:not(.md-container-ignore) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container.md-has-icon{padding-left:36px;padding-right:0}html[dir=rtl] md-input-container.md-has-icon{padding-left:0;unicode-bidi:embed}body[dir=rtl] md-input-container.md-has-icon{padding-left:0;unicode-bidi:embed}md-input-container.md-has-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-has-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container.md-has-icon{padding-right:36px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-has-icon{padding-right:36px;unicode-bidi:embed}md-input-container.md-has-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-has-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container.md-has-icon>label{left:36px;right:auto}html[dir=rtl] md-input-container.md-has-icon>label{left:auto;unicode-bidi:embed}body[dir=rtl] md-input-container.md-has-icon>label{left:auto;unicode-bidi:embed}md-input-container.md-has-icon>label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-has-icon>label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container.md-has-icon>label{right:36px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-has-icon>label{right:36px;unicode-bidi:embed}md-input-container.md-has-icon>label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-has-icon>label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container .md-placeholder,md-input-container label:not(.md-no-float):not(.md-container-ignore){-webkit-order:1;-ms-flex-order:1;order:1;pointer-events:none;-webkit-font-smoothing:antialiased;padding-left:3px;padding-right:0;z-index:1;-webkit-transform:translate3d(0,28px,0) scale(1);transform:translate3d(0,28px,0) scale(1);transition:-webkit-transform cubic-bezier(.25,.8,.25,1) .25s;transition:transform cubic-bezier(.25,.8,.25,1) .25s;-webkit-transform-origin:left top;transform-origin:left top}html[dir=rtl] md-input-container .md-placeholder,html[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){padding-left:0;unicode-bidi:embed}body[dir=rtl] md-input-container .md-placeholder,body[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){padding-left:0;unicode-bidi:embed}md-input-container .md-placeholder bdo[dir=rtl],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-placeholder bdo[dir=ltr],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container .md-placeholder,html[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){padding-right:3px;unicode-bidi:embed}body[dir=rtl] md-input-container .md-placeholder,body[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){padding-right:3px;unicode-bidi:embed}md-input-container .md-placeholder bdo[dir=rtl],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-placeholder bdo[dir=ltr],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container .md-placeholder,html[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){-webkit-transform-origin:right top;transform-origin:right top;unicode-bidi:embed}body[dir=rtl] md-input-container .md-placeholder,body[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore){-webkit-transform-origin:right top;transform-origin:right top;unicode-bidi:embed}md-input-container .md-placeholder bdo[dir=rtl],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-placeholder bdo[dir=ltr],md-input-container label:not(.md-no-float):not(.md-container-ignore) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container .md-placeholder{position:absolute;top:0;opacity:0;transition-property:opacity,-webkit-transform;transition-property:opacity,transform;-webkit-transform:translate3d(0,30px,0);transform:translate3d(0,30px,0)}md-input-container.md-input-focused .md-placeholder{opacity:1;-webkit-transform:translate3d(0,24px,0);transform:translate3d(0,24px,0)}md-input-container.md-input-has-value .md-placeholder{transition:none;opacity:0}md-input-container:not(.md-input-has-value) input:not(:focus),md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-ampm-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-day-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-hour-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-millisecond-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-minute-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-month-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-second-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-text,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-week-field,md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-year-field{color:transparent}md-input-container .md-input{-webkit-order:2;-ms-flex-order:2;order:2;display:block;margin-top:0;background:0 0;padding-top:2px;padding-bottom:1px;padding-left:2px;padding-right:2px;border-width:0 0 1px 0;line-height:26px;height:30px;-ms-flex-preferred-size:26px;border-radius:0;border-style:solid;width:100%;box-sizing:border-box;float:left}html[dir=rtl] md-input-container .md-input{float:right;unicode-bidi:embed}body[dir=rtl] md-input-container .md-input{float:right;unicode-bidi:embed}md-input-container .md-input bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-input bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container .md-input:focus{outline:0}md-input-container .md-input:invalid{outline:0;box-shadow:none}md-input-container .md-input.md-no-flex{-webkit-flex:none!important;-ms-flex:none!important;flex:none!important}md-input-container .md-char-counter{text-align:right;padding-right:2px;padding-left:0}html[dir=rtl] md-input-container .md-char-counter{text-align:left;unicode-bidi:embed}body[dir=rtl] md-input-container .md-char-counter{text-align:left;unicode-bidi:embed}md-input-container .md-char-counter bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-char-counter bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container .md-char-counter{padding-right:0;unicode-bidi:embed}body[dir=rtl] md-input-container .md-char-counter{padding-right:0;unicode-bidi:embed}md-input-container .md-char-counter bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-char-counter bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container .md-char-counter{padding-left:2px;unicode-bidi:embed}body[dir=rtl] md-input-container .md-char-counter{padding-left:2px;unicode-bidi:embed}md-input-container .md-char-counter bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-char-counter bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container [data-ng-messages],md-input-container [ng-messages],md-input-container [x-ng-messages],md-input-container data-ng-messages,md-input-container ng-messages,md-input-container x-ng-messages{position:relative;-webkit-order:4;-ms-flex-order:4;order:4;overflow:hidden;clear:left}html[dir=rtl] md-input-container [data-ng-messages],html[dir=rtl] md-input-container [ng-messages],html[dir=rtl] md-input-container [x-ng-messages],html[dir=rtl] md-input-container data-ng-messages,html[dir=rtl] md-input-container ng-messages,html[dir=rtl] md-input-container x-ng-messages{clear:right;unicode-bidi:embed}body[dir=rtl] md-input-container [data-ng-messages],body[dir=rtl] md-input-container [ng-messages],body[dir=rtl] md-input-container [x-ng-messages],body[dir=rtl] md-input-container data-ng-messages,body[dir=rtl] md-input-container ng-messages,body[dir=rtl] md-input-container x-ng-messages{clear:right;unicode-bidi:embed}md-input-container [data-ng-messages] bdo[dir=rtl],md-input-container [ng-messages] bdo[dir=rtl],md-input-container [x-ng-messages] bdo[dir=rtl],md-input-container data-ng-messages bdo[dir=rtl],md-input-container ng-messages bdo[dir=rtl],md-input-container x-ng-messages bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container [data-ng-messages] bdo[dir=ltr],md-input-container [ng-messages] bdo[dir=ltr],md-input-container [x-ng-messages] bdo[dir=ltr],md-input-container data-ng-messages bdo[dir=ltr],md-input-container ng-messages bdo[dir=ltr],md-input-container x-ng-messages bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container [data-ng-messages].ng-enter [data-ng-message-exp],md-input-container [data-ng-messages].ng-enter [data-ng-message],md-input-container [data-ng-messages].ng-enter [ng-message-exp],md-input-container [data-ng-messages].ng-enter [ng-message],md-input-container [data-ng-messages].ng-enter [x-ng-message-exp],md-input-container [data-ng-messages].ng-enter [x-ng-message],md-input-container [data-ng-messages].ng-enter data-ng-message,md-input-container [data-ng-messages].ng-enter ng-message,md-input-container [data-ng-messages].ng-enter x-ng-message,md-input-container [ng-messages].ng-enter [data-ng-message-exp],md-input-container [ng-messages].ng-enter [data-ng-message],md-input-container [ng-messages].ng-enter [ng-message-exp],md-input-container [ng-messages].ng-enter [ng-message],md-input-container [ng-messages].ng-enter [x-ng-message-exp],md-input-container [ng-messages].ng-enter [x-ng-message],md-input-container [ng-messages].ng-enter data-ng-message,md-input-container [ng-messages].ng-enter ng-message,md-input-container [ng-messages].ng-enter x-ng-message,md-input-container [x-ng-messages].ng-enter [data-ng-message-exp],md-input-container [x-ng-messages].ng-enter [data-ng-message],md-input-container [x-ng-messages].ng-enter [ng-message-exp],md-input-container [x-ng-messages].ng-enter [ng-message],md-input-container [x-ng-messages].ng-enter [x-ng-message-exp],md-input-container [x-ng-messages].ng-enter [x-ng-message],md-input-container [x-ng-messages].ng-enter data-ng-message,md-input-container [x-ng-messages].ng-enter ng-message,md-input-container [x-ng-messages].ng-enter x-ng-message,md-input-container data-ng-messages.ng-enter [data-ng-message-exp],md-input-container data-ng-messages.ng-enter [data-ng-message],md-input-container data-ng-messages.ng-enter [ng-message-exp],md-input-container data-ng-messages.ng-enter [ng-message],md-input-container data-ng-messages.ng-enter [x-ng-message-exp],md-input-container data-ng-messages.ng-enter [x-ng-message],md-input-container data-ng-messages.ng-enter data-ng-message,md-input-container data-ng-messages.ng-enter ng-message,md-input-container data-ng-messages.ng-enter x-ng-message,md-input-container ng-messages.ng-enter [data-ng-message-exp],md-input-container ng-messages.ng-enter [data-ng-message],md-input-container ng-messages.ng-enter [ng-message-exp],md-input-container ng-messages.ng-enter [ng-message],md-input-container ng-messages.ng-enter [x-ng-message-exp],md-input-container ng-messages.ng-enter [x-ng-message],md-input-container ng-messages.ng-enter data-ng-message,md-input-container ng-messages.ng-enter ng-message,md-input-container ng-messages.ng-enter x-ng-message,md-input-container x-ng-messages.ng-enter [data-ng-message-exp],md-input-container x-ng-messages.ng-enter [data-ng-message],md-input-container x-ng-messages.ng-enter [ng-message-exp],md-input-container x-ng-messages.ng-enter [ng-message],md-input-container x-ng-messages.ng-enter [x-ng-message-exp],md-input-container x-ng-messages.ng-enter [x-ng-message],md-input-container x-ng-messages.ng-enter data-ng-message,md-input-container x-ng-messages.ng-enter ng-message,md-input-container x-ng-messages.ng-enter x-ng-message{opacity:0;margin-top:-100px}md-input-container .md-char-counter,md-input-container [data-ng-message-exp],md-input-container [data-ng-message],md-input-container [ng-message-exp],md-input-container [ng-message],md-input-container [x-ng-message-exp],md-input-container [x-ng-message],md-input-container data-ng-message,md-input-container ng-message,md-input-container x-ng-message{font-size:12px;line-height:14px;overflow:hidden;transition:all .3s cubic-bezier(.55,0,.55,.2);opacity:1;margin-top:0;padding-top:5px}md-input-container .md-char-counter:not(.md-char-counter),md-input-container [data-ng-message-exp]:not(.md-char-counter),md-input-container [data-ng-message]:not(.md-char-counter),md-input-container [ng-message-exp]:not(.md-char-counter),md-input-container [ng-message]:not(.md-char-counter),md-input-container [x-ng-message-exp]:not(.md-char-counter),md-input-container [x-ng-message]:not(.md-char-counter),md-input-container data-ng-message:not(.md-char-counter),md-input-container ng-message:not(.md-char-counter),md-input-container x-ng-message:not(.md-char-counter){padding-right:5px;padding-left:0}html[dir=rtl] md-input-container .md-char-counter:not(.md-char-counter),html[dir=rtl] md-input-container [data-ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [data-ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container [ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container [x-ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [x-ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container data-ng-message:not(.md-char-counter),html[dir=rtl] md-input-container ng-message:not(.md-char-counter),html[dir=rtl] md-input-container x-ng-message:not(.md-char-counter){padding-right:0;unicode-bidi:embed}body[dir=rtl] md-input-container .md-char-counter:not(.md-char-counter),body[dir=rtl] md-input-container [data-ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [data-ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container [ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container [x-ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [x-ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container data-ng-message:not(.md-char-counter),body[dir=rtl] md-input-container ng-message:not(.md-char-counter),body[dir=rtl] md-input-container x-ng-message:not(.md-char-counter){padding-right:0;unicode-bidi:embed}md-input-container .md-char-counter:not(.md-char-counter) bdo[dir=rtl],md-input-container [data-ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [data-ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container [ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container [x-ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [x-ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container data-ng-message:not(.md-char-counter) bdo[dir=rtl],md-input-container ng-message:not(.md-char-counter) bdo[dir=rtl],md-input-container x-ng-message:not(.md-char-counter) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-char-counter:not(.md-char-counter) bdo[dir=ltr],md-input-container [data-ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [data-ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container [ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container [x-ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [x-ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container data-ng-message:not(.md-char-counter) bdo[dir=ltr],md-input-container ng-message:not(.md-char-counter) bdo[dir=ltr],md-input-container x-ng-message:not(.md-char-counter) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container .md-char-counter:not(.md-char-counter),html[dir=rtl] md-input-container [data-ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [data-ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container [ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container [x-ng-message-exp]:not(.md-char-counter),html[dir=rtl] md-input-container [x-ng-message]:not(.md-char-counter),html[dir=rtl] md-input-container data-ng-message:not(.md-char-counter),html[dir=rtl] md-input-container ng-message:not(.md-char-counter),html[dir=rtl] md-input-container x-ng-message:not(.md-char-counter){padding-left:5px;unicode-bidi:embed}body[dir=rtl] md-input-container .md-char-counter:not(.md-char-counter),body[dir=rtl] md-input-container [data-ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [data-ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container [ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container [x-ng-message-exp]:not(.md-char-counter),body[dir=rtl] md-input-container [x-ng-message]:not(.md-char-counter),body[dir=rtl] md-input-container data-ng-message:not(.md-char-counter),body[dir=rtl] md-input-container ng-message:not(.md-char-counter),body[dir=rtl] md-input-container x-ng-message:not(.md-char-counter){padding-left:5px;unicode-bidi:embed}md-input-container .md-char-counter:not(.md-char-counter) bdo[dir=rtl],md-input-container [data-ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [data-ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container [ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container [x-ng-message-exp]:not(.md-char-counter) bdo[dir=rtl],md-input-container [x-ng-message]:not(.md-char-counter) bdo[dir=rtl],md-input-container data-ng-message:not(.md-char-counter) bdo[dir=rtl],md-input-container ng-message:not(.md-char-counter) bdo[dir=rtl],md-input-container x-ng-message:not(.md-char-counter) bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container .md-char-counter:not(.md-char-counter) bdo[dir=ltr],md-input-container [data-ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [data-ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container [ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container [x-ng-message-exp]:not(.md-char-counter) bdo[dir=ltr],md-input-container [x-ng-message]:not(.md-char-counter) bdo[dir=ltr],md-input-container data-ng-message:not(.md-char-counter) bdo[dir=ltr],md-input-container ng-message:not(.md-char-counter) bdo[dir=ltr],md-input-container x-ng-message:not(.md-char-counter) bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container:not(.md-input-invalid) .md-auto-hide .md-input-message-animation{opacity:0;margin-top:-100px}md-input-container .md-auto-hide .md-input-message-animation:not(.ng-animate){opacity:0;margin-top:-100px}md-input-container .md-input-message-animation.ng-enter{opacity:0;margin-top:-100px}md-input-container.md-input-focused label:not(.md-no-float),md-input-container.md-input-has-placeholder label:not(.md-no-float),md-input-container.md-input-has-value label:not(.md-no-float){-webkit-transform:translate3d(0,6px,0) scale(.75);transform:translate3d(0,6px,0) scale(.75)}md-input-container.md-input-has-value label{transition:none}md-input-container .md-input.ng-invalid.ng-dirty,md-input-container.md-input-focused .md-input{padding-bottom:0;border-width:0 0 2px 0}[disabled] md-input-container .md-input,md-input-container .md-input[disabled]{background-position:0 bottom;background-size:4px 1px;background-repeat:repeat-x;margin-bottom:-1px}md-input-container.md-icon-float{transition:margin-top .5s cubic-bezier(.25,.8,.25,1)}md-input-container.md-icon-float>label{pointer-events:none;position:absolute}md-input-container.md-icon-float>md-icon{top:2px;left:2px;right:auto}html[dir=rtl] md-input-container.md-icon-float>md-icon{left:auto;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-float>md-icon{left:auto;unicode-bidi:embed}md-input-container.md-icon-float>md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-float>md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container.md-icon-float>md-icon{right:2px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-float>md-icon{right:2px;unicode-bidi:embed}md-input-container.md-icon-float>md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-float>md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container.md-icon-float.md-input-focused label,md-input-container.md-icon-float.md-input-has-value label{-webkit-transform:translate3d(0,6px,0) scale(.75);transform:translate3d(0,6px,0) scale(.75);transition:-webkit-transform cubic-bezier(.25,.8,.25,1) .5s;transition:transform cubic-bezier(.25,.8,.25,1) .5s}md-input-container.md-icon-right{padding-right:36px;padding-left:36px}html[dir=rtl] md-input-container.md-icon-right{padding-right:36px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-right{padding-right:36px;unicode-bidi:embed}md-input-container.md-icon-right bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-right bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container.md-icon-right{padding-left:36px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-right{padding-left:36px;unicode-bidi:embed}md-input-container.md-icon-right bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-right bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-input-container.md-icon-right .md-errors-spacer+md-icon{margin:0;right:2px;left:auto}html[dir=rtl] md-input-container.md-icon-right .md-errors-spacer+md-icon{right:auto;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-right .md-errors-spacer+md-icon{right:auto;unicode-bidi:embed}md-input-container.md-icon-right .md-errors-spacer+md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-right .md-errors-spacer+md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-input-container.md-icon-right .md-errors-spacer+md-icon{left:2px;unicode-bidi:embed}body[dir=rtl] md-input-container.md-icon-right .md-errors-spacer+md-icon{left:2px;unicode-bidi:embed}md-input-container.md-icon-right .md-errors-spacer+md-icon bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-input-container.md-icon-right .md-errors-spacer+md-icon bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}@media screen and (-ms-high-contrast:active){md-input-container.md-default-theme>md-icon{fill:#fff}}md-toolbar.md-menu-toolbar h2.md-toolbar-tools{line-height:1rem;height:auto;padding:28px;padding-bottom:12px}md-menu-bar{padding:0 20px;display:block;position:relative;z-index:2}md-menu-bar .md-menu{display:inline-block;padding:0;position:relative}md-menu-bar button{font-size:14px;padding:0 10px;margin:0;border:0;background-color:transparent;height:40px}md-menu-bar md-backdrop.md-menu-backdrop{z-index:-2}md-menu-content.md-menu-bar-menu.md-dense{max-height:none;padding:16px 0}md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent{position:relative}md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent>md-icon{position:absolute;padding:0;width:24px;top:6px;left:24px}md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent .md-menu>.md-button,md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent>.md-button{padding:0 32px 0 64px}md-menu-content.md-menu-bar-menu.md-dense .md-button{min-height:0;height:32px;display:-webkit-flex;display:-ms-flexbox;display:flex}md-menu-content.md-menu-bar-menu.md-dense .md-button span{-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}md-menu-content.md-menu-bar-menu.md-dense .md-button span.md-alt-text{-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;margin:0 8px}md-menu-content.md-menu-bar-menu.md-dense md-menu-divider{margin:8px 0}md-menu-content.md-menu-bar-menu.md-dense .md-menu>.md-button,md-menu-content.md-menu-bar-menu.md-dense md-menu-item>.md-button{text-align:left;text-align:start}md-menu-content.md-menu-bar-menu.md-dense .md-menu{padding:0}md-menu-content.md-menu-bar-menu.md-dense .md-menu>.md-button{position:relative;margin:0;width:100%;text-transform:none;font-weight:400;border-radius:0;padding-left:16px}md-menu-content.md-menu-bar-menu.md-dense .md-menu>.md-button:after{display:block;content:'\\25BC';position:absolute;top:0;speak:none;-webkit-transform:rotate(270deg) scaleY(.45) scaleX(.9);transform:rotate(270deg) scaleY(.45) scaleX(.9);right:28px}md-list{display:block;padding:8px 0 8px 0}md-list .md-subheader{font-size:14px;font-weight:500;letter-spacing:.010em;line-height:1.2em}md-list-item{position:relative}md-list-item.md-proxy-focus.md-focused .md-no-style{transition:background-color .15s linear}md-list-item .md-no-style,md-list-item.md-no-proxy{position:relative;padding:0 16px;-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto}md-list-item .md-no-style.md-button,md-list-item.md-no-proxy.md-button{font-size:inherit;height:inherit;text-align:left;text-transform:none;width:100%;white-space:normal;-webkit-flex-direction:inherit;-ms-flex-direction:inherit;flex-direction:inherit;-webkit-align-items:inherit;-ms-flex-align:inherit;align-items:inherit;border-radius:0}md-list-item .md-no-style.md-button>.md-ripple-container,md-list-item.md-no-proxy.md-button>.md-ripple-container{border-radius:0}md-list-item .md-no-style:focus,md-list-item.md-no-proxy:focus{outline:0}md-list-item.md-with-secondary{position:relative}md-list-item.md-clickable:hover{cursor:pointer}md-list-item md-divider{position:absolute;bottom:0;left:0;width:100%}md-list-item md-divider[md-inset]{left:96px;width:calc(100% - 96px);margin:0}md-list-item,md-list-item .md-list-item-inner{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-items:center;-ms-flex-align:center;align-items:center;min-height:48px;height:auto}md-list-item .md-list-item-inner>div.md-primary>md-icon:not(.md-avatar-icon),md-list-item .md-list-item-inner>div.md-secondary>md-icon:not(.md-avatar-icon),md-list-item .md-list-item-inner>md-icon.md-secondary:not(.md-avatar-icon),md-list-item .md-list-item-inner>md-icon:first-child:not(.md-avatar-icon),md-list-item>div.md-primary>md-icon:not(.md-avatar-icon),md-list-item>div.md-secondary>md-icon:not(.md-avatar-icon),md-list-item>md-icon.md-secondary:not(.md-avatar-icon),md-list-item>md-icon:first-child:not(.md-avatar-icon){width:24px;margin-top:16px;margin-bottom:12px;box-sizing:content-box}md-list-item .md-list-item-inner md-checkbox.md-secondary,md-list-item .md-list-item-inner>div.md-primary>md-checkbox,md-list-item .md-list-item-inner>div.md-secondary>md-checkbox,md-list-item .md-list-item-inner>md-checkbox,md-list-item md-checkbox.md-secondary,md-list-item>div.md-primary>md-checkbox,md-list-item>div.md-secondary>md-checkbox,md-list-item>md-checkbox{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center}md-list-item .md-list-item-inner md-checkbox.md-secondary .md-label,md-list-item .md-list-item-inner>div.md-primary>md-checkbox .md-label,md-list-item .md-list-item-inner>div.md-secondary>md-checkbox .md-label,md-list-item .md-list-item-inner>md-checkbox .md-label,md-list-item md-checkbox.md-secondary .md-label,md-list-item>div.md-primary>md-checkbox .md-label,md-list-item>div.md-secondary>md-checkbox .md-label,md-list-item>md-checkbox .md-label{display:none}md-list-item .md-list-item-inner>md-icon:first-child:not(.md-avatar-icon),md-list-item>md-icon:first-child:not(.md-avatar-icon){margin-right:32px}md-list-item .md-list-item-inner>md-checkbox,md-list-item>md-checkbox{width:24px;margin-left:3px;margin-right:29px;margin-top:16px}md-list-item .md-avatar,md-list-item .md-avatar-icon,md-list-item .md-list-item-inner .md-avatar,md-list-item .md-list-item-inner .md-avatar-icon{margin-top:8px;margin-bottom:8px;margin-right:16px;border-radius:50%;box-sizing:content-box}md-list-item .md-avatar,md-list-item .md-list-item-inner .md-avatar{width:40px;height:40px}md-list-item .md-avatar-icon,md-list-item .md-list-item-inner .md-avatar-icon{padding:8px}md-list-item .md-list-item-inner md-checkbox.md-secondary,md-list-item .md-list-item-inner md-switch.md-secondary,md-list-item md-checkbox.md-secondary,md-list-item md-switch.md-secondary{margin-top:0;margin-bottom:0}md-list-item .md-list-item-inner md-checkbox.md-secondary,md-list-item md-checkbox.md-secondary{margin-right:0}md-list-item .md-list-item-inner md-switch.md-secondary,md-list-item md-switch.md-secondary{margin-right:-6px}md-list-item .md-list-item-inner button.md-button.md-secondary-container,md-list-item button.md-button.md-secondary-container{background-color:transparent;-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;border-radius:50%;margin:0;min-width:0}md-list-item .md-list-item-inner button.md-button.md-secondary-container .md-ripple,md-list-item .md-list-item-inner button.md-button.md-secondary-container .md-ripple-container,md-list-item button.md-button.md-secondary-container .md-ripple,md-list-item button.md-button.md-secondary-container .md-ripple-container{border-radius:50%}md-list-item .md-list-item-inner button.md-button.md-secondary-container.md-icon-button,md-list-item button.md-button.md-secondary-container.md-icon-button{margin-right:-12px}md-list-item .md-list-item-inner .md-secondary,md-list-item .md-list-item-inner .md-secondary-container,md-list-item .md-secondary,md-list-item .md-secondary-container{position:absolute;top:50%;right:16px;margin:0 0 0 16px;-webkit-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0)}md-list-item .md-list-item-inner>.md-button.md-secondary-container>.md-secondary,md-list-item>.md-button.md-secondary-container>.md-secondary{margin-left:0;position:static}md-list-item .md-list-item-inner>.md-list-item-inner>p,md-list-item .md-list-item-inner>p,md-list-item>.md-list-item-inner>p,md-list-item>p{-webkit-flex:1;-ms-flex:1;flex:1;margin:0}md-list-item.md-2-line,md-list-item.md-2-line>.md-no-style,md-list-item.md-3-line,md-list-item.md-3-line>.md-no-style{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}md-list-item.md-2-line .md-list-item-text,md-list-item.md-2-line>.md-no-style .md-list-item-text,md-list-item.md-3-line .md-list-item-text,md-list-item.md-3-line>.md-no-style .md-list-item-text{-webkit-flex:1;-ms-flex:1;flex:1;margin:auto;text-overflow:ellipsis}md-list-item.md-2-line .md-list-item-text.md-offset,md-list-item.md-2-line>.md-no-style .md-list-item-text.md-offset,md-list-item.md-3-line .md-list-item-text.md-offset,md-list-item.md-3-line>.md-no-style .md-list-item-text.md-offset{margin-left:56px}md-list-item.md-2-line .md-list-item-text h3,md-list-item.md-2-line>.md-no-style .md-list-item-text h3,md-list-item.md-3-line .md-list-item-text h3,md-list-item.md-3-line>.md-no-style .md-list-item-text h3{font-size:16px;font-weight:400;letter-spacing:.010em;margin:0;line-height:1.2em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}md-list-item.md-2-line .md-list-item-text h4,md-list-item.md-2-line>.md-no-style .md-list-item-text h4,md-list-item.md-3-line .md-list-item-text h4,md-list-item.md-3-line>.md-no-style .md-list-item-text h4{font-size:14px;letter-spacing:.010em;margin:3px 0 1px 0;font-weight:400;line-height:1.2em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}md-list-item.md-2-line .md-list-item-text p,md-list-item.md-2-line>.md-no-style .md-list-item-text p,md-list-item.md-3-line .md-list-item-text p,md-list-item.md-3-line>.md-no-style .md-list-item-text p{font-size:14px;font-weight:500;letter-spacing:.010em;margin:0;line-height:1.6em}md-list-item.md-2-line,md-list-item.md-2-line>.md-no-style{height:auto;min-height:72px}md-list-item.md-2-line.md-long-text,md-list-item.md-2-line>.md-no-style.md-long-text{margin:1.6em}md-list-item.md-2-line .md-avatar-icon,md-list-item.md-2-line>.md-avatar,md-list-item.md-2-line>.md-no-style .md-avatar-icon,md-list-item.md-2-line>.md-no-style>.md-avatar{margin-top:12px}md-list-item.md-2-line>.md-no-style>md-icon:first-child,md-list-item.md-2-line>md-icon:first-child{-webkit-align-self:flex-start;-ms-flex-item-align:start;align-self:flex-start}md-list-item.md-2-line .md-list-item-text,md-list-item.md-2-line>.md-no-style .md-list-item-text{-webkit-flex:1;-ms-flex:1;flex:1}md-list-item.md-3-line,md-list-item.md-3-line>.md-no-style{height:auto;min-height:88px}md-list-item.md-3-line.md-long-text,md-list-item.md-3-line>.md-no-style.md-long-text{margin:1.6em}md-list-item.md-3-line>.md-avatar,md-list-item.md-3-line>.md-no-style>.md-avatar,md-list-item.md-3-line>.md-no-style>md-icon:first-child,md-list-item.md-3-line>md-icon:first-child{margin-top:16px}.md-open-menu-container{position:fixed;left:0;top:0;z-index:100;opacity:0;border-radius:2px}.md-open-menu-container md-menu-divider{margin-top:4px;margin-bottom:4px;height:1px;min-height:1px;max-height:1px;width:100%}.md-open-menu-container md-menu-content>*{opacity:0}.md-open-menu-container:not(.md-clickable){pointer-events:none}.md-open-menu-container.md-active{opacity:1;transition:all .4s cubic-bezier(.25,.8,.25,1);transition-duration:.2s}.md-open-menu-container.md-active>md-menu-content>*{opacity:1;transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:.2s;transition-delay:.1s}.md-open-menu-container.md-leave{opacity:0;transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:250ms}md-menu-content{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding:8px 0;max-height:304px;overflow-y:auto}md-menu-content.md-dense{max-height:208px}md-menu-content.md-dense md-menu-item{height:32px;min-height:0}md-menu-item{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;min-height:48px;height:48px;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}md-menu-item>*{width:100%;margin:auto 0;padding-left:16px;padding-right:16px}md-menu-item>a.md-button{display:-webkit-flex;display:-ms-flexbox;display:flex}md-menu-item>.md-button{border-radius:0;margin:auto 0;font-size:15px;text-transform:none;font-weight:400;text-align:left;text-align:start;height:100%;padding-left:16px;padding-right:16px;display:inline-block;-webkit-align-items:baseline;-ms-flex-align:baseline;align-items:baseline;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start;width:100%}md-menu-item>.md-button md-icon{margin:auto 16px auto 0}md-menu-item>.md-button p{display:inline-block;margin:auto}md-menu-item>.md-button span{margin-top:auto;margin-bottom:auto}md-menu-item>.md-button .md-ripple-container{border-radius:inherit}.md-menu{padding:8px 0}md-toolbar .md-menu{height:auto;margin:auto;padding:0}@media (max-width:959px){md-menu-content{min-width:112px}md-menu-content[width=\"3\"]{min-width:168px}md-menu-content[width=\"4\"]{min-width:224px}md-menu-content[width=\"5\"]{min-width:280px}md-menu-content[width=\"6\"]{min-width:336px}md-menu-content[width=\"7\"]{min-width:392px}}@media (min-width:960px){md-menu-content{min-width:96px}md-menu-content[width=\"3\"]{min-width:192px}md-menu-content[width=\"4\"]{min-width:256px}md-menu-content[width=\"5\"]{min-width:320px}md-menu-content[width=\"6\"]{min-width:384px}md-menu-content[width=\"7\"]{min-width:448px}}md-progress-circular{display:block;position:relative;width:100px;height:100px;padding-top:0!important;margin-bottom:0!important;z-index:2}md-progress-circular .md-spinner-wrapper{display:block;position:absolute;overflow:hidden;top:50%;left:50%}md-progress-circular .md-spinner-wrapper .md-inner{width:100px;height:100px;position:relative}md-progress-circular .md-spinner-wrapper .md-inner .md-gap{position:absolute;left:49px;right:49px;top:0;bottom:0;border-top-width:10px;border-top-style:solid;box-sizing:border-box}md-progress-circular .md-spinner-wrapper .md-inner .md-left,md-progress-circular .md-spinner-wrapper .md-inner .md-right{position:absolute;top:0;height:100px;width:50px;overflow:hidden}md-progress-circular .md-spinner-wrapper .md-inner .md-left .md-half-circle,md-progress-circular .md-spinner-wrapper .md-inner .md-right .md-half-circle{position:absolute;top:0;width:100px;height:100px;box-sizing:border-box;border-width:10px;border-style:solid;border-bottom-color:transparent;border-radius:50%}md-progress-circular .md-spinner-wrapper .md-inner .md-left{left:0}md-progress-circular .md-spinner-wrapper .md-inner .md-left .md-half-circle{left:0;border-right-color:transparent}md-progress-circular .md-spinner-wrapper .md-inner .md-right{right:0}md-progress-circular .md-spinner-wrapper .md-inner .md-right .md-half-circle{right:0;border-left-color:transparent}md-progress-circular .md-mode-indeterminate .md-spinner-wrapper{-webkit-animation:outer-rotate 2.91667s linear infinite;animation:outer-rotate 2.91667s linear infinite}md-progress-circular .md-mode-indeterminate .md-spinner-wrapper .md-inner{-webkit-animation:sporadic-rotate 5.25s cubic-bezier(.35,0,.25,1) infinite;animation:sporadic-rotate 5.25s cubic-bezier(.35,0,.25,1) infinite}md-progress-circular .md-mode-indeterminate .md-spinner-wrapper .md-inner .md-left .md-half-circle,md-progress-circular .md-mode-indeterminate .md-spinner-wrapper .md-inner .md-right .md-half-circle{-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-duration:1.3125s;animation-duration:1.3125s;-webkit-animation-timing-function:cubic-bezier(.35,0,.25,1);animation-timing-function:cubic-bezier(.35,0,.25,1)}md-progress-circular .md-mode-indeterminate .md-spinner-wrapper .md-inner .md-left .md-half-circle{-webkit-animation-name:left-wobble;animation-name:left-wobble}md-progress-circular .md-mode-indeterminate .md-spinner-wrapper .md-inner .md-right .md-half-circle{-webkit-animation-name:right-wobble;animation-name:right-wobble}md-progress-circular md-progress-circular.ng-hide .md-spinner-wrapper{-webkit-animation:none;animation:none}md-progress-circular md-progress-circular.ng-hide .md-spinner-wrapper .md-inner{-webkit-animation:none;animation:none}md-progress-circular md-progress-circular.ng-hide .md-spinner-wrapper .md-inner .md-left .md-half-circle{-webkit-animation-name:none;animation-name:none}md-progress-circular md-progress-circular.ng-hide .md-spinner-wrapper .md-inner .md-right .md-half-circle{-webkit-animation-name:none;animation-name:none}md-progress-circular .md-spinner-wrapper.ng-hide{-webkit-animation:none;animation:none}md-progress-circular .md-spinner-wrapper.ng-hide .md-inner{-webkit-animation:none;animation:none}md-progress-circular .md-spinner-wrapper.ng-hide .md-inner .md-left .md-half-circle{-webkit-animation-name:none;animation-name:none}md-progress-circular .md-spinner-wrapper.ng-hide .md-inner .md-right .md-half-circle{-webkit-animation-name:none;animation-name:none}@-webkit-keyframes outer-rotate{0%{-webkit-transform:rotate(0) scale(.5);transform:rotate(0) scale(.5)}100%{-webkit-transform:rotate(360deg) scale(.5);transform:rotate(360deg) scale(.5)}}@keyframes outer-rotate{0%{-webkit-transform:rotate(0) scale(.5);transform:rotate(0) scale(.5)}100%{-webkit-transform:rotate(360deg) scale(.5);transform:rotate(360deg) scale(.5)}}@-webkit-keyframes left-wobble{0%,100%{-webkit-transform:rotate(130deg);transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}}@keyframes left-wobble{0%,100%{-webkit-transform:rotate(130deg);transform:rotate(130deg)}50%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}}@-webkit-keyframes right-wobble{0%,100%{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}}@keyframes right-wobble{0%,100%{-webkit-transform:rotate(-130deg);transform:rotate(-130deg)}50%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}}@-webkit-keyframes sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}@keyframes sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}md-progress-linear{display:block;position:relative;width:100%;height:5px;padding-top:0!important;margin-bottom:0!important}md-progress-linear .md-container{display:block;position:relative;overflow:hidden;width:100%;height:5px;-webkit-transform:translate(0,0) scale(1,1);transform:translate(0,0) scale(1,1)}md-progress-linear .md-container .md-bar{position:absolute;left:0;top:0;bottom:0;width:100%;height:5px}md-progress-linear .md-container .md-dashed:before{content:\"\";display:none;position:absolute;margin-top:0;height:5px;width:100%;background-color:transparent;background-size:10px 10px!important;background-position:0 -23px}md-progress-linear .md-container .md-bar1,md-progress-linear .md-container .md-bar2{transition:-webkit-transform .2s linear;transition:transform .2s linear}md-progress-linear .md-container.md-mode-query .md-bar1{display:none}md-progress-linear .md-container.md-mode-query .md-bar2{transition:all .2s linear;-webkit-animation:query .8s infinite cubic-bezier(.39,.575,.565,1);animation:query .8s infinite cubic-bezier(.39,.575,.565,1)}md-progress-linear .md-container.md-mode-determinate .md-bar1{display:none}md-progress-linear .md-container.md-mode-indeterminate .md-bar1{-webkit-animation:md-progress-linear-indeterminate-scale-1 4s infinite,md-progress-linear-indeterminate-1 4s infinite;animation:md-progress-linear-indeterminate-scale-1 4s infinite,md-progress-linear-indeterminate-1 4s infinite}md-progress-linear .md-container.md-mode-indeterminate .md-bar2{-webkit-animation:md-progress-linear-indeterminate-scale-2 4s infinite,md-progress-linear-indeterminate-2 4s infinite;animation:md-progress-linear-indeterminate-scale-2 4s infinite,md-progress-linear-indeterminate-2 4s infinite}md-progress-linear .md-container.ng-hide{-webkit-animation:none;animation:none}md-progress-linear .md-container.ng-hide .md-bar1{-webkit-animation-name:none;animation-name:none}md-progress-linear .md-container.ng-hide .md-bar2{-webkit-animation-name:none;animation-name:none}md-progress-linear .md-container.md-mode-buffer{background-color:transparent!important;transition:all .2s linear}md-progress-linear .md-container.md-mode-buffer .md-dashed:before{display:block;-webkit-animation:buffer 3s infinite linear;animation:buffer 3s infinite linear}@-webkit-keyframes query{0%{opacity:1;-webkit-transform:translateX(35%) scale(.3,1);transform:translateX(35%) scale(.3,1)}100%{opacity:0;-webkit-transform:translateX(-50%) scale(0,1);transform:translateX(-50%) scale(0,1)}}@keyframes query{0%{opacity:1;-webkit-transform:translateX(35%) scale(.3,1);transform:translateX(35%) scale(.3,1)}100%{opacity:0;-webkit-transform:translateX(-50%) scale(0,1);transform:translateX(-50%) scale(0,1)}}@-webkit-keyframes buffer{0%{opacity:1;background-position:0 -23px}50%{opacity:0}100%{opacity:1;background-position:-200px -23px}}@keyframes buffer{0%{opacity:1;background-position:0 -23px}50%{opacity:0}100%{opacity:1;background-position:-200px -23px}}@-webkit-keyframes md-progress-linear-indeterminate-scale-1{0%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:linear;animation-timing-function:linear}36.6%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);animation-timing-function:cubic-bezier(.33473,.12482,.78584,1)}69.15%{-webkit-transform:scaleX(.83);transform:scaleX(.83);-webkit-animation-timing-function:cubic-bezier(.22573,0,.23365,1.37098);animation-timing-function:cubic-bezier(.22573,0,.23365,1.37098)}100%{-webkit-transform:scaleX(.1);transform:scaleX(.1)}}@keyframes md-progress-linear-indeterminate-scale-1{0%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:linear;animation-timing-function:linear}36.6%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);animation-timing-function:cubic-bezier(.33473,.12482,.78584,1)}69.15%{-webkit-transform:scaleX(.83);transform:scaleX(.83);-webkit-animation-timing-function:cubic-bezier(.22573,0,.23365,1.37098);animation-timing-function:cubic-bezier(.22573,0,.23365,1.37098)}100%{-webkit-transform:scaleX(.1);transform:scaleX(.1)}}@-webkit-keyframes md-progress-linear-indeterminate-1{0%{left:-105.16667%;-webkit-animation-timing-function:linear;animation-timing-function:linear}20%{left:-105.16667%;-webkit-animation-timing-function:cubic-bezier(.5,0,.70173,.49582);animation-timing-function:cubic-bezier(.5,0,.70173,.49582)}69.15%{left:21.5%;-webkit-animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635)}100%{left:95.44444%}}@keyframes md-progress-linear-indeterminate-1{0%{left:-105.16667%;-webkit-animation-timing-function:linear;animation-timing-function:linear}20%{left:-105.16667%;-webkit-animation-timing-function:cubic-bezier(.5,0,.70173,.49582);animation-timing-function:cubic-bezier(.5,0,.70173,.49582)}69.15%{left:21.5%;-webkit-animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635)}100%{left:95.44444%}}@-webkit-keyframes md-progress-linear-indeterminate-scale-2{0%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:cubic-bezier(.20503,.05705,.57661,.45397);animation-timing-function:cubic-bezier(.20503,.05705,.57661,.45397)}19.15%{-webkit-transform:scaleX(.57);transform:scaleX(.57);-webkit-animation-timing-function:cubic-bezier(.15231,.19643,.64837,1.00432);animation-timing-function:cubic-bezier(.15231,.19643,.64837,1.00432)}44.15%{-webkit-transform:scaleX(.91);transform:scaleX(.91);-webkit-animation-timing-function:cubic-bezier(.25776,-.00316,.21176,1.38179);animation-timing-function:cubic-bezier(.25776,-.00316,.21176,1.38179)}100%{-webkit-transform:scaleX(.1);transform:scaleX(.1)}}@keyframes md-progress-linear-indeterminate-scale-2{0%{-webkit-transform:scaleX(.1);transform:scaleX(.1);-webkit-animation-timing-function:cubic-bezier(.20503,.05705,.57661,.45397);animation-timing-function:cubic-bezier(.20503,.05705,.57661,.45397)}19.15%{-webkit-transform:scaleX(.57);transform:scaleX(.57);-webkit-animation-timing-function:cubic-bezier(.15231,.19643,.64837,1.00432);animation-timing-function:cubic-bezier(.15231,.19643,.64837,1.00432)}44.15%{-webkit-transform:scaleX(.91);transform:scaleX(.91);-webkit-animation-timing-function:cubic-bezier(.25776,-.00316,.21176,1.38179);animation-timing-function:cubic-bezier(.25776,-.00316,.21176,1.38179)}100%{-webkit-transform:scaleX(.1);transform:scaleX(.1)}}@-webkit-keyframes md-progress-linear-indeterminate-2{0%{left:-54.88889%;-webkit-animation-timing-function:cubic-bezier(.15,0,.51506,.40968);animation-timing-function:cubic-bezier(.15,0,.51506,.40968)}25%{left:-17.25%;-webkit-animation-timing-function:cubic-bezier(.31033,.28406,.8,.73372);animation-timing-function:cubic-bezier(.31033,.28406,.8,.73372)}48.35%{left:29.5%;-webkit-animation-timing-function:cubic-bezier(.4,.62703,.6,.90203);animation-timing-function:cubic-bezier(.4,.62703,.6,.90203)}100%{left:117.38889%}}@keyframes md-progress-linear-indeterminate-2{0%{left:-54.88889%;-webkit-animation-timing-function:cubic-bezier(.15,0,.51506,.40968);animation-timing-function:cubic-bezier(.15,0,.51506,.40968)}25%{left:-17.25%;-webkit-animation-timing-function:cubic-bezier(.31033,.28406,.8,.73372);animation-timing-function:cubic-bezier(.31033,.28406,.8,.73372)}48.35%{left:29.5%;-webkit-animation-timing-function:cubic-bezier(.4,.62703,.6,.90203);animation-timing-function:cubic-bezier(.4,.62703,.6,.90203)}100%{left:117.38889%}}md-radio-button{box-sizing:border-box;display:block;margin-bottom:16px;white-space:nowrap;cursor:pointer;position:relative}md-radio-button[disabled]{cursor:default}md-radio-button[disabled] .md-container{cursor:default}md-radio-button .md-container{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);box-sizing:border-box;display:inline-block;width:20px;height:20px;cursor:pointer;left:0;right:auto}html[dir=rtl] md-radio-button .md-container{left:auto;unicode-bidi:embed}body[dir=rtl] md-radio-button .md-container{left:auto;unicode-bidi:embed}md-radio-button .md-container bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-button .md-container bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-radio-button .md-container{right:0;unicode-bidi:embed}body[dir=rtl] md-radio-button .md-container{right:0;unicode-bidi:embed}md-radio-button .md-container bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-button .md-container bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-radio-button .md-container .md-ripple-container{position:absolute;display:block;width:auto;height:auto;left:-15px;top:-15px;right:-15px;bottom:-15px}md-radio-button .md-container:before{box-sizing:border-box;background-color:transparent;border-radius:50%;content:'';position:absolute;display:block;height:auto;left:0;top:0;right:0;bottom:0;transition:all .5s;width:auto}md-radio-button.md-align-top-left>div.md-container{top:12px}md-radio-button .md-off{box-sizing:border-box;position:absolute;top:0;left:0;width:20px;height:20px;border-style:solid;border-width:2px;border-radius:50%;transition:border-color ease .28s}md-radio-button .md-on{box-sizing:border-box;position:absolute;top:0;left:0;width:20px;height:20px;border-radius:50%;transition:-webkit-transform ease .28s;transition:transform ease .28s;-webkit-transform:scale(0);transform:scale(0)}md-radio-button.md-checked .md-on{-webkit-transform:scale(.5);transform:scale(.5)}md-radio-button .md-label{box-sizing:border-box;position:relative;display:inline-block;margin-left:30px;margin-right:0;vertical-align:middle;white-space:normal;pointer-events:none;width:auto}html[dir=rtl] md-radio-button .md-label{margin-left:0;unicode-bidi:embed}body[dir=rtl] md-radio-button .md-label{margin-left:0;unicode-bidi:embed}md-radio-button .md-label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-button .md-label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-radio-button .md-label{margin-right:30px;unicode-bidi:embed}body[dir=rtl] md-radio-button .md-label{margin-right:30px;unicode-bidi:embed}md-radio-button .md-label bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-button .md-label bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-radio-button .circle{border-radius:50%}md-radio-group md-radio-button:not(:first-child){margin-top:16px}md-radio-group.layout-row md-radio-button{margin-top:0;margin-bottom:0;margin-left:inherit;margin-right:16px}html[dir=rtl] md-radio-group.layout-row md-radio-button{margin-left:16px;unicode-bidi:embed}body[dir=rtl] md-radio-group.layout-row md-radio-button{margin-left:16px;unicode-bidi:embed}md-radio-group.layout-row md-radio-button bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-group.layout-row md-radio-button bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-radio-group.layout-row md-radio-button{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-radio-group.layout-row md-radio-button{margin-right:inherit;unicode-bidi:embed}md-radio-group.layout-row md-radio-button bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-group.layout-row md-radio-button bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-radio-group.layout-row md-radio-button:last-of-type{margin-left:inherit;margin-right:0}html[dir=rtl] md-radio-group.layout-row md-radio-button:last-of-type{margin-left:0;unicode-bidi:embed}body[dir=rtl] md-radio-group.layout-row md-radio-button:last-of-type{margin-left:0;unicode-bidi:embed}md-radio-group.layout-row md-radio-button:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-group.layout-row md-radio-button:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-radio-group.layout-row md-radio-button:last-of-type{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-radio-group.layout-row md-radio-button:last-of-type{margin-right:inherit;unicode-bidi:embed}md-radio-group.layout-row md-radio-button:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-radio-group.layout-row md-radio-button:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-radio-group:focus{outline:0}md-radio-group.md-focused .md-checked .md-container:before{left:-8px;top:-8px;right:-8px;bottom:-8px}.md-inline-form md-radio-group{margin:18px 0 19px}.md-inline-form md-radio-group md-radio-button{display:inline-block;height:30px;padding:2px;box-sizing:border-box;margin-top:0;margin-bottom:0}@media screen and (-ms-high-contrast:active){md-radio-button.md-default-theme .md-on{background-color:#fff}}.md-select-menu-container{position:fixed;left:0;top:0;z-index:90;opacity:0;display:none}.md-select-menu-container:not(.md-clickable){pointer-events:none}.md-select-menu-container md-progress-circular{display:table;margin:24px auto!important}.md-select-menu-container.md-active{display:block;opacity:1}.md-select-menu-container.md-active md-select-menu{transition:all .4s cubic-bezier(.25,.8,.25,1);transition-duration:150ms}.md-select-menu-container.md-active md-select-menu>*{opacity:1;transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:150ms;transition-delay:.1s}.md-select-menu-container.md-leave{opacity:0;transition:all .3s cubic-bezier(.55,0,.55,.2);transition-duration:250ms}md-input-container>md-select{margin:0;-webkit-order:2;-ms-flex-order:2;order:2}md-select{display:-webkit-flex;display:-ms-flexbox;display:flex;margin:20px 0 26px 0}md-select[disabled] .md-select-value{background-position:0 bottom;background-size:4px 1px;background-repeat:repeat-x;margin-bottom:-1px}md-select:focus{outline:0}md-select[disabled]:hover{cursor:default}md-select:not([disabled]):hover{cursor:pointer}md-select:not([disabled]).ng-invalid.ng-dirty .md-select-value{border-bottom:2px solid;padding-bottom:0}md-select:not([disabled]):focus .md-select-value{border-bottom-width:2px;border-bottom-style:solid;padding-bottom:0}.md-select-value{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;padding:2px 2px 1px;border-bottom-width:1px;border-bottom-style:solid;background-color:transparent;position:relative;box-sizing:content-box;min-width:64px;min-height:26px;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}.md-select-value .md-text{display:inline}.md-select-value :first-child{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-transform:translate3d(0,2px,0);transform:translate3d(0,2px,0)}.md-select-value .md-select-icon{display:block;-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;text-align:end;width:24px;margin:0 4px;-webkit-transform:translate3d(0,1px,0);transform:translate3d(0,1px,0)}.md-select-value .md-select-icon:after{display:block;content:'\\25BC';position:relative;top:2px;speak:none;-webkit-transform:scaleY(.6) scaleX(1);transform:scaleY(.6) scaleX(1)}.md-select-value.md-select-placeholder{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-order:1;-ms-flex-order:1;order:1;pointer-events:none;-webkit-font-smoothing:antialiased;padding-left:2px;z-index:1}md-select-menu{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);max-height:256px;min-height:48px;overflow-y:hidden;-webkit-transform-origin:left top;transform-origin:left top;-webkit-transform:scale(1);transform:scale(1)}md-select-menu.md-reverse{-webkit-flex-direction:column-reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}md-select-menu:not(.md-overflow) md-content{padding-top:8px;padding-bottom:8px}html[dir=rtl] md-select-menu{-webkit-transform-origin:right top;transform-origin:right top;unicode-bidi:embed}body[dir=rtl] md-select-menu{-webkit-transform-origin:right top;transform-origin:right top;unicode-bidi:embed}md-select-menu bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-select-menu bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-select-menu md-content{min-width:136px;min-height:48px;max-height:256px;overflow-y:auto}md-select-menu>*{opacity:0}md-option{cursor:pointer;position:relative;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;width:auto;padding:0 16px 0 16px;height:48px}md-option[disabled]{cursor:default}md-option:focus{outline:0}md-option .md-text{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:16px}md-optgroup{display:block}md-optgroup label{display:block;font-size:14px;text-transform:uppercase;padding:16px;font-weight:500}md-optgroup md-option{padding-left:32px;padding-right:32px}@media screen and (-ms-high-contrast:active){.md-select-backdrop{background-color:transparent}md-select-menu{border:1px solid #fff}}md-sidenav{box-sizing:border-box;position:absolute;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;z-index:60;width:320px;max-width:320px;bottom:0;overflow:auto}md-sidenav ul{list-style:none}md-sidenav.md-closed{display:none}md-sidenav.md-closed-add,md-sidenav.md-closed-remove{display:-webkit-flex;display:-ms-flexbox;display:flex;transition:.2s ease-in all}md-sidenav.md-closed-add.md-closed-add-active,md-sidenav.md-closed-remove.md-closed-remove-active{transition:all .4s cubic-bezier(.25,.8,.25,1)}md-sidenav.md-locked-open-add,md-sidenav.md-locked-open-remove{position:static;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-sidenav.md-locked-open,md-sidenav.md-locked-open-remove.md-closed,md-sidenav.md-locked-open.md-closed,md-sidenav.md-locked-open.md-closed.md-sidenav-left,md-sidenav.md-locked-open.md-closed.md-sidenav-right{position:static;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-sidenav.md-locked-open-remove-active{transition:width .3s cubic-bezier(.55,0,.55,.2),min-width .3s cubic-bezier(.55,0,.55,.2);width:0;min-width:0}md-sidenav.md-closed.md-locked-open-add{width:0;min-width:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-sidenav.md-closed.md-locked-open-add-active{transition:width .3s cubic-bezier(.55,0,.55,.2),min-width .3s cubic-bezier(.55,0,.55,.2);width:320px;min-width:320px;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.md-sidenav-backdrop.md-locked-open{display:none}.md-sidenav-left,md-sidenav{left:0;top:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.md-sidenav-left.md-closed,md-sidenav.md-closed{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.md-sidenav-right{left:100%;top:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.md-sidenav-right.md-closed{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}@media screen and (min-width:600px){md-sidenav{max-width:400px}}@media screen and (max-width:456px){md-sidenav{width:calc(100% - 56px);min-width:calc(100% - 56px);max-width:calc(100% - 56px)}}@media screen and (-ms-high-contrast:active){.md-sidenav-left,md-sidenav{border-right:1px solid #fff}.md-sidenav-right{border-left:1px solid #fff}}@-webkit-keyframes sliderFocusThumb{0%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{opacity:0}}@keyframes sliderFocusThumb{0%{opacity:0;-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{opacity:0}}md-slider{height:48px;position:relative;display:block;margin-left:4px;margin-right:4px;padding:0}md-slider *,md-slider :after{box-sizing:border-box}md-slider .md-slider-wrapper{position:relative}md-slider .md-track-container{width:100%;position:absolute;top:23px;height:2px}md-slider .md-track{position:absolute;left:0;right:0;height:100%}md-slider .md-track-fill{transition:width 50ms linear}md-slider .md-track-ticks{position:absolute;left:0;right:0;height:100%}md-slider .md-track-ticks canvas{width:100%}md-slider .md-thumb-container{position:absolute;left:0;top:50%;-webkit-transform:translate3d(-50%,-50%,0);transform:translate3d(-50%,-50%,0);transition:left .1s linear}md-slider .md-thumb{z-index:1;position:absolute;left:-19px;top:5px;width:38px;height:38px;border-radius:38px;-webkit-transform:scale(.5);transform:scale(.5);transition:all .1s linear}md-slider .md-thumb:after{content:'';position:absolute;left:3px;top:3px;width:32px;height:32px;border-radius:32px;border-width:3px;border-style:solid}md-slider .md-sign{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;position:absolute;left:-14px;top:-20px;width:28px;height:28px;border-radius:28px;-webkit-transform:scale(.4) translate3d(0,70px,0);transform:scale(.4) translate3d(0,70px,0);transition:all .2s ease-in-out}md-slider .md-sign:after{position:absolute;content:'';left:0;border-radius:16px;top:19px;border-left:14px solid transparent;border-right:14px solid transparent;border-top-width:16px;border-top-style:solid;opacity:0;-webkit-transform:translate3d(0,-8px,0);transform:translate3d(0,-8px,0);transition:all .2s ease-in-out}md-slider .md-sign .md-thumb-text{z-index:1;font-size:12px;font-weight:700}md-slider .md-focus-thumb{position:absolute;left:-24px;top:0;width:48px;height:48px;border-radius:48px;display:none;opacity:0;background-color:silver;-webkit-animation:sliderFocusThumb .4s linear;animation:sliderFocusThumb .4s linear}md-slider .md-focus-ring{position:absolute;left:-24px;top:0;width:48px;height:48px;border-radius:48px;-webkit-transform:scale(0);transform:scale(0);transition:all .2s linear;opacity:.26}md-slider .md-disabled-thumb{position:absolute;left:-22px;top:2px;width:44px;height:44px;border-radius:44px;-webkit-transform:scale(.35);transform:scale(.35);border-width:6px;border-style:solid;display:none}md-slider.md-min .md-thumb:after{background-color:#fff}md-slider.md-min .md-sign{opacity:0}md-slider:focus{outline:0}md-slider.md-dragging .md-thumb-container,md-slider.md-dragging .md-track-fill{transition:none}md-slider:not([md-discrete]) .md-sign,md-slider:not([md-discrete]) .md-track-ticks{display:none}md-slider:not([md-discrete]):not([disabled]):hover .md-thumb{-webkit-transform:scale(.6);transform:scale(.6)}md-slider:not([md-discrete]):not([disabled]).md-active .md-focus-thumb,md-slider:not([md-discrete]):not([disabled]):focus .md-focus-thumb{display:block}md-slider:not([md-discrete]):not([disabled]).md-active .md-focus-ring,md-slider:not([md-discrete]):not([disabled]):focus .md-focus-ring{-webkit-transform:scale(1);transform:scale(1)}md-slider:not([md-discrete]):not([disabled]).md-active .md-thumb,md-slider:not([md-discrete]):not([disabled]):focus .md-thumb{-webkit-transform:scale(.85);transform:scale(.85)}md-slider[md-discrete] .md-focus-ring,md-slider[md-discrete] .md-focus-thumb{display:none}md-slider[md-discrete]:not([disabled]).md-active .md-sign,md-slider[md-discrete]:not([disabled]).md-active .md-sign:after,md-slider[md-discrete]:not([disabled]):focus .md-sign,md-slider[md-discrete]:not([disabled]):focus .md-sign:after{opacity:1;-webkit-transform:translate3d(0,0,0) scale(1);transform:translate3d(0,0,0) scale(1)}md-slider[disabled] .md-track-fill{display:none}md-slider[disabled] .md-sign{display:none}md-slider[disabled] .md-thumb{-webkit-transform:scale(.35);transform:scale(.35)}md-slider[disabled] .md-disabled-thumb{display:block}@media screen and (-ms-high-contrast:active){md-slider.md-default-theme .md-track{border-bottom:1px solid #fff}}.md-sticky-clone{z-index:2;top:0;left:0;right:0;position:absolute!important;-webkit-transform:translate3d(-9999px,-9999px,0);transform:translate3d(-9999px,-9999px,0)}.md-sticky-clone[sticky-state=active]{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.md-sticky-clone[sticky-state=active]:not(.md-sticky-no-effect) .md-subheader-inner{-webkit-animation:subheaderStickyHoverIn .3s ease-out both;animation:subheaderStickyHoverIn .3s ease-out both}@-webkit-keyframes subheaderStickyHoverIn{0%{box-shadow:0 0 0 0 transparent}100%{box-shadow:0 2px 4px 0 rgba(0,0,0,.16)}}@keyframes subheaderStickyHoverIn{0%{box-shadow:0 0 0 0 transparent}100%{box-shadow:0 2px 4px 0 rgba(0,0,0,.16)}}@-webkit-keyframes subheaderStickyHoverOut{0%{box-shadow:0 2px 4px 0 rgba(0,0,0,.16)}100%{box-shadow:0 0 0 0 transparent}}@keyframes subheaderStickyHoverOut{0%{box-shadow:0 2px 4px 0 rgba(0,0,0,.16)}100%{box-shadow:0 0 0 0 transparent}}.md-subheader-wrapper:not(.md-sticky-no-effect){transition:.2s ease-out margin}.md-subheader-wrapper:not(.md-sticky-no-effect) .md-subheader{margin:0}.md-subheader-wrapper:not(.md-sticky-no-effect).md-sticky-clone{z-index:2}.md-subheader-wrapper:not(.md-sticky-no-effect)[sticky-state=active]{margin-top:-2px}.md-subheader-wrapper:not(.md-sticky-no-effect):not(.md-sticky-clone)[sticky-prev-state=active] .md-subheader-inner:after{-webkit-animation:subheaderStickyHoverOut .3s ease-out both;animation:subheaderStickyHoverOut .3s ease-out both}.md-subheader{display:block;font-size:14px;font-weight:500;line-height:1em;margin:0;position:relative}.md-subheader .md-subheader-inner{display:block;padding:16px}.md-subheader .md-subheader-content{display:block;z-index:1;position:relative}.md-inline-form md-switch{margin-top:18px;margin-bottom:19px}md-switch{margin:16px 0;white-space:nowrap;cursor:pointer;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;height:30px;line-height:28px;-webkit-align-items:center;-ms-flex-align:center;align-items:center;display:-webkit-flex;display:-ms-flexbox;display:flex;margin-left:inherit;margin-right:16px}html[dir=rtl] md-switch{margin-left:16px;unicode-bidi:embed}body[dir=rtl] md-switch{margin-left:16px;unicode-bidi:embed}md-switch bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-switch bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-switch{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-switch{margin-right:inherit;unicode-bidi:embed}md-switch bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-switch bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-switch:last-of-type{margin-left:inherit;margin-right:0}html[dir=rtl] md-switch:last-of-type{margin-left:0;unicode-bidi:embed}body[dir=rtl] md-switch:last-of-type{margin-left:0;unicode-bidi:embed}md-switch:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-switch:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}html[dir=rtl] md-switch:last-of-type{margin-right:inherit;unicode-bidi:embed}body[dir=rtl] md-switch:last-of-type{margin-right:inherit;unicode-bidi:embed}md-switch:last-of-type bdo[dir=rtl]{direction:rtl;unicode-bidi:bidi-override}md-switch:last-of-type bdo[dir=ltr]{direction:ltr;unicode-bidi:bidi-override}md-switch[disabled]{cursor:default}md-switch[disabled] .md-container{cursor:default}md-switch .md-container{cursor:-webkit-grab;cursor:grab;width:36px;height:24px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:8px;float:left}md-switch:not([disabled]) .md-dragging,md-switch:not([disabled]).md-dragging .md-container{cursor:-webkit-grabbing;cursor:grabbing}md-switch.md-focused:not([disabled]) .md-thumb:before{left:-8px;top:-8px;right:-8px;bottom:-8px}md-switch.md-focused:not([disabled]):not(.md-checked) .md-thumb:before{background-color:rgba(0,0,0,.12)}md-switch .md-label{border-color:transparent;border-width:0;float:left}md-switch .md-bar{left:1px;width:34px;top:5px;height:14px;border-radius:8px;position:absolute}md-switch .md-thumb-container{top:2px;left:0;width:16px;position:absolute;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);z-index:1}md-switch.md-checked .md-thumb-container{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}md-switch .md-thumb{position:absolute;margin:0;left:0;top:0;outline:0;height:20px;width:20px;border-radius:50%;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12)}md-switch .md-thumb:before{background-color:transparent;border-radius:50%;content:'';position:absolute;display:block;height:auto;left:0;top:0;right:0;bottom:0;transition:all .5s;width:auto}md-switch .md-thumb .md-ripple-container{position:absolute;display:block;width:auto;height:auto;left:-20px;top:-20px;right:-20px;bottom:-20px}md-switch:not(.md-dragging) .md-bar,md-switch:not(.md-dragging) .md-thumb,md-switch:not(.md-dragging) .md-thumb-container{transition:all 80ms linear;transition-property:-webkit-transform,background-color;transition-property:transform,background-color}md-switch:not(.md-dragging) .md-bar,md-switch:not(.md-dragging) .md-thumb{transition-delay:50ms}@media screen and (-ms-high-contrast:active){md-switch.md-default-theme .md-bar{background-color:#666}md-switch.md-default-theme.md-checked .md-bar{background-color:#9E9E9E}md-switch.md-default-theme .md-thumb{background-color:#fff}}md-toast{position:absolute;z-index:105;box-sizing:border-box;cursor:default;overflow:hidden;padding:8px;opacity:1;transition:all .4s cubic-bezier(.25,.8,.25,1)}md-toast .md-toast-content{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;height:0;max-height:168px;max-width:100%;min-height:48px;padding-left:24px;padding-right:24px;box-shadow:0 2px 5px 0 rgba(0,0,0,.26);border-radius:2px;font-size:14px;overflow:hidden;-webkit-transform:translate3d(0,0,0) rotateZ(0);transform:translate3d(0,0,0) rotateZ(0);transition:all .4s cubic-bezier(.25,.8,.25,1)}md-toast.md-capsule{border-radius:24px}md-toast.md-capsule .md-toast-content{border-radius:24px}md-toast.ng-leave-active .md-toast-content{transition:all .3s cubic-bezier(.55,0,.55,.2)}md-toast.md-swipedown .md-toast-content,md-toast.md-swipeleft .md-toast-content,md-toast.md-swiperight .md-toast-content,md-toast.md-swipeup .md-toast-content{transition:all .4s cubic-bezier(.25,.8,.25,1)}md-toast.ng-enter{opacity:0}md-toast.ng-enter .md-toast-content{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}md-toast.ng-enter.md-top .md-toast-content{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}md-toast.ng-enter.ng-enter-active{opacity:1}md-toast.ng-enter.ng-enter-active .md-toast-content{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-toast.ng-leave.ng-leave-active .md-toast-content{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}md-toast.ng-leave.ng-leave-active.md-swipeup .md-toast-content{-webkit-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0)}md-toast.ng-leave.ng-leave-active.md-swipedown .md-toast-content{-webkit-transform:translate3d(0,50%,0);transform:translate3d(0,50%,0)}md-toast.ng-leave.ng-leave-active.md-top .md-toast-content{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}md-toast .md-action{line-height:19px;margin-left:24px;margin-right:0;cursor:pointer;text-transform:uppercase;float:right}md-toast .md-action.md-button{min-width:0}@media (max-width:959px){md-toast{left:0;right:0;width:100%;max-width:100%;min-width:0;border-radius:0;bottom:0}md-toast.ng-leave.ng-leave-active.md-swipeup .md-toast-content{-webkit-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0)}md-toast.ng-leave.ng-leave-active.md-swipedown .md-toast-content{-webkit-transform:translate3d(0,50%,0);transform:translate3d(0,50%,0)}}@media (min-width:960px){md-toast{min-width:304px}md-toast.md-bottom{bottom:0}md-toast.md-left{left:0}md-toast.md-right{right:0}md-toast.md-top{top:0}md-toast.ng-leave.ng-leave-active.md-swipeleft .md-toast-content{-webkit-transform:translate3d(-50%,0,0);transform:translate3d(-50%,0,0)}md-toast.ng-leave.ng-leave-active.md-swiperight .md-toast-content{-webkit-transform:translate3d(50%,0,0);transform:translate3d(50%,0,0)}}@media (min-width:1920px){md-toast .md-toast-content{max-width:568px}}@media screen and (-ms-high-contrast:active){md-toast{border:1px solid #fff}}.md-toast-animating{overflow:hidden!important}@-webkit-keyframes md-tab-content-hide{0%{opacity:1}50%{opacity:1}100%{opacity:0}}@keyframes md-tab-content-hide{0%{opacity:1}50%{opacity:1}100%{opacity:0}}md-tab-data{position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1;opacity:0}md-tabs{display:block;margin:0;border-radius:2px;overflow:hidden;position:relative;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0}md-tabs:not(.md-no-tab-content):not(.md-dynamic-height){min-height:248px}md-tabs[md-align-tabs=bottom]{padding-bottom:48px}md-tabs[md-align-tabs=bottom] md-tabs-wrapper{position:absolute;bottom:0;left:0;right:0;height:48px;z-index:2}md-tabs[md-align-tabs=bottom] md-tabs-content-wrapper{top:0;bottom:48px}md-tabs.md-dynamic-height md-tabs-content-wrapper{min-height:0;position:relative;top:auto;left:auto;right:auto;bottom:auto;overflow:visible}md-tabs.md-dynamic-height md-tab-content.md-active{position:relative}md-tabs[md-border-bottom] md-tabs-wrapper{border-width:0 0 1px;border-style:solid}md-tabs[md-border-bottom]:not(.md-dynamic-height) md-tabs-content-wrapper{top:49px}md-tabs-wrapper{display:block;position:relative;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-tabs-wrapper md-next-button,md-tabs-wrapper md-prev-button{height:100%;width:32px;position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);line-height:1em;z-index:2;cursor:pointer;font-size:16px;background:transparent no-repeat center center;transition:all .5s cubic-bezier(.35,0,.25,1)}md-tabs-wrapper md-next-button:focus,md-tabs-wrapper md-prev-button:focus{outline:0}md-tabs-wrapper md-next-button.md-disabled,md-tabs-wrapper md-prev-button.md-disabled{opacity:.25;cursor:default}md-tabs-wrapper md-next-button.ng-leave,md-tabs-wrapper md-prev-button.ng-leave{transition:none}md-tabs-wrapper md-next-button md-icon,md-tabs-wrapper md-prev-button md-icon{position:absolute;top:50%;left:50%;-webkit-transform:translate3d(-50%,-50%,0);transform:translate3d(-50%,-50%,0)}md-tabs-wrapper md-prev-button{left:0;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE3LjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPiA8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPiA8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjQgMjQiIHhtbDpzcGFjZT0icHJlc2VydmUiPiA8ZyBpZD0iSGVhZGVyIj4gPGc+IDxyZWN0IHg9Ii02MTgiIHk9Ii0xMjA4IiBmaWxsPSJub25lIiB3aWR0aD0iMTQwMCIgaGVpZ2h0PSIzNjAwIi8+IDwvZz4gPC9nPiA8ZyBpZD0iTGFiZWwiPiA8L2c+IDxnIGlkPSJJY29uIj4gPGc+IDxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyIAkJIiBzdHlsZT0iZmlsbDp3aGl0ZTsiLz4gPHJlY3QgZmlsbD0ibm9uZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ii8+IDwvZz4gPC9nPiA8ZyBpZD0iR3JpZCIgZGlzcGxheT0ibm9uZSI+IDxnIGRpc3BsYXk9ImlubGluZSI+IDwvZz4gPC9nPiA8L3N2Zz4NCg==)}md-tabs-wrapper md-next-button{right:0;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE3LjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPiA8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPiA8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjQgMjQiIHhtbDpzcGFjZT0icHJlc2VydmUiPiA8ZyBpZD0iSGVhZGVyIj4gPGc+IDxyZWN0IHg9Ii02MTgiIHk9Ii0xMzM2IiBmaWxsPSJub25lIiB3aWR0aD0iMTQwMCIgaGVpZ2h0PSIzNjAwIi8+IDwvZz4gPC9nPiA8ZyBpZD0iTGFiZWwiPiA8L2c+IDxnIGlkPSJJY29uIj4gPGc+IDxwb2x5Z29uIHBvaW50cz0iMTAsNiA4LjYsNy40IDEzLjIsMTIgOC42LDE2LjYgMTAsMTggMTYsMTIgCQkiIHN0eWxlPSJmaWxsOndoaXRlOyIvPiA8cmVjdCBmaWxsPSJub25lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiLz4gPC9nPiA8L2c+IDxnIGlkPSJHcmlkIiBkaXNwbGF5PSJub25lIj4gPGcgZGlzcGxheT0iaW5saW5lIj4gPC9nPiA8L2c+IDwvc3ZnPg0K)}md-tabs-wrapper md-next-button md-icon{-webkit-transform:translate3d(-50%,-50%,0) rotate(180deg);transform:translate3d(-50%,-50%,0) rotate(180deg)}md-tabs-wrapper.md-stretch-tabs md-pagination-wrapper{width:100%;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}md-tabs-wrapper.md-stretch-tabs md-pagination-wrapper md-tab-item{-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}md-tabs-canvas{position:relative;overflow:hidden;display:block;height:48px}md-tabs-canvas:after{content:'';display:table;clear:both}md-tabs-canvas .md-dummy-wrapper{position:absolute;top:0;left:0}md-tabs-canvas.md-paginated{margin:0 32px}md-tabs-canvas.md-center-tabs{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;text-align:center}md-tabs-canvas.md-center-tabs .md-tab{float:none;display:inline-block}md-pagination-wrapper{height:48px;display:block;transition:-webkit-transform .5s cubic-bezier(.35,0,.25,1);transition:transform .5s cubic-bezier(.35,0,.25,1);position:absolute;width:999999px;left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-pagination-wrapper:after{content:'';display:table;clear:both}md-pagination-wrapper.md-center-tabs{position:relative;width:initial;margin:0 auto}md-tabs-content-wrapper{display:block;position:absolute;top:48px;left:0;right:0;bottom:0;overflow:hidden}md-tab-content{display:block;position:absolute;top:0;left:0;right:0;bottom:0;transition:-webkit-transform .5s cubic-bezier(.35,0,.25,1);transition:transform .5s cubic-bezier(.35,0,.25,1);overflow:auto;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}md-tab-content.md-no-scroll{bottom:auto;overflow:hidden}md-tab-content.md-no-transition,md-tab-content.ng-leave{transition:none}md-tab-content.md-left:not(.md-active){-webkit-transform:translateX(-100%);transform:translateX(-100%);-webkit-animation:1s md-tab-content-hide;animation:1s md-tab-content-hide;opacity:0}md-tab-content.md-left:not(.md-active) *{transition:visibility 0s linear;transition-delay:.5s;visibility:hidden}md-tab-content.md-right:not(.md-active){-webkit-transform:translateX(100%);transform:translateX(100%);-webkit-animation:1s md-tab-content-hide;animation:1s md-tab-content-hide;opacity:0}md-tab-content.md-right:not(.md-active) *{transition:visibility 0s linear;transition-delay:.5s;visibility:hidden}md-tab-content>div.ng-leave{-webkit-animation:1s md-tab-content-hide;animation:1s md-tab-content-hide}md-ink-bar{position:absolute;left:auto;right:auto;bottom:0;height:2px}md-ink-bar.md-left{transition:left 125ms cubic-bezier(.35,0,.25,1),right .25s cubic-bezier(.35,0,.25,1)}md-ink-bar.md-right{transition:left .25s cubic-bezier(.35,0,.25,1),right 125ms cubic-bezier(.35,0,.25,1)}md-tab{position:absolute;z-index:-1;left:-9999px}.md-tab{font-size:14px;text-align:center;line-height:24px;padding:12px 24px;transition:background-color .35s cubic-bezier(.35,0,.25,1);cursor:pointer;white-space:nowrap;position:relative;text-transform:uppercase;float:left;font-weight:500;box-sizing:border-box;overflow:hidden;text-overflow:ellipsis}.md-tab.md-focused{box-shadow:none;outline:0}.md-tab.md-active{cursor:default}.md-tab.md-disabled{pointer-events:none;-ms-touch-action:pan-y;touch-action:pan-y;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none;opacity:.5;cursor:default}.md-tab.ng-leave{transition:none}md-toolbar+md-tabs{border-top-left-radius:0;border-top-right-radius:0}md-toolbar{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;position:relative;z-index:2;font-size:20px;min-height:64px;width:100%}md-toolbar.md-whiteframe-z1-add,md-toolbar.md-whiteframe-z1-remove{transition:box-shadow .5s linear}md-toolbar md-toolbar-filler{width:72px}md-toolbar *,md-toolbar :after,md-toolbar :before{box-sizing:border-box}md-toolbar.md-tall{height:128px;min-height:128px;max-height:128px}md-toolbar.md-medium-tall{height:88px;min-height:88px;max-height:88px}md-toolbar.md-medium-tall .md-toolbar-tools{height:48px;min-height:48px;max-height:48px}md-toolbar>.md-indent{margin-left:64px}md-toolbar~md-content>md-list{padding:0}md-toolbar~md-content>md-list md-list-item:last-child md-divider{display:none}.md-toolbar-tools{font-size:20px;letter-spacing:.005em;box-sizing:border-box;font-weight:400;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;width:100%;height:64px;max-height:64px;padding:0 16px;margin:0}.md-toolbar-tools h1,.md-toolbar-tools h2,.md-toolbar-tools h3{font-size:inherit;font-weight:inherit;margin:inherit}.md-toolbar-tools a{color:inherit;text-decoration:none}.md-toolbar-tools .fill-height{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center}.md-toolbar-tools .md-button{margin-top:0;margin-bottom:0}.md-toolbar-tools>.md-button:first-child{margin-left:-8px}.md-toolbar-tools>.md-button:last-child{margin-right:-8px}.md-toolbar-tools>md-menu:last-child{margin-right:-8px}.md-toolbar-tools>md-menu:last-child>.md-button{margin-right:0}@media screen and (-ms-high-contrast:active){.md-toolbar-tools{border-bottom:1px solid #fff}}@media only screen and (min-width:0) and (max-width:959px) and (orientation:portrait){md-toolbar{min-height:56px}.md-toolbar-tools{height:56px;max-height:56px}}@media only screen and (min-width:0) and (max-width:959px) and (orientation:landscape){md-toolbar{min-height:48px}.md-toolbar-tools{height:48px;max-height:48px}}md-tooltip{position:absolute;z-index:100;overflow:hidden;pointer-events:none;border-radius:4px;font-weight:500;font-size:14px}@media screen and (min-width:960px){md-tooltip{font-size:10px}}md-tooltip .md-content{position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;-webkit-transform-origin:center top;transform-origin:center top;-webkit-transform:scale(0);transform:scale(0);opacity:0;height:32px;line-height:32px;padding-left:16px;padding-right:16px}@media screen and (min-width:960px){md-tooltip .md-content{height:22px;line-height:22px;padding-left:8px;padding-right:8px}}md-tooltip .md-content.md-show-add{transition:all .4s cubic-bezier(.25,.8,.25,1);transition-duration:.2s;-webkit-transform:scale(0);transform:scale(0);opacity:0}md-tooltip .md-content.md-show,md-tooltip .md-content.md-show-add-active{-webkit-transform:scale(1);transform:scale(1);opacity:1;-webkit-transform-origin:center top;transform-origin:center top}md-tooltip .md-content.md-show-remove{transition:all .4s cubic-bezier(.25,.8,.25,1);transition-duration:.2s}md-tooltip .md-content.md-show-remove.md-show-remove-active{-webkit-transform:scale(0);transform:scale(0);opacity:0}md-tooltip.md-hide{transition:all .3s cubic-bezier(.55,0,.55,.2)}md-tooltip.md-show{transition:all .4s cubic-bezier(.25,.8,.25,1);pointer-events:auto;will-change:opacity,height,width}.md-virtual-repeat-container{box-sizing:border-box;display:block;margin:0;overflow:hidden;padding:0;position:relative}.md-virtual-repeat-container .md-virtual-repeat-scroller{bottom:0;box-sizing:border-box;left:0;margin:0;overflow-x:hidden;padding:0;position:absolute;right:0;top:0}.md-virtual-repeat-container .md-virtual-repeat-sizer{box-sizing:border-box;height:1px;display:block;margin:0;padding:0;width:1px}.md-virtual-repeat-container .md-virtual-repeat-offsetter{box-sizing:border-box;left:0;margin:0;padding:0;position:absolute;right:0;top:0}.md-virtual-repeat-container.md-orient-horizontal .md-virtual-repeat-scroller{overflow-x:auto;overflow-y:hidden}.md-virtual-repeat-container.md-orient-horizontal .md-virtual-repeat-offsetter{bottom:16px;right:auto;white-space:nowrap}.md-whiteframe-1dp,.md-whiteframe-z1{box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12)}.md-whiteframe-2dp{box-shadow:0 1px 5px 0 rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.12)}.md-whiteframe-3dp{box-shadow:0 1px 8px 0 rgba(0,0,0,.2),0 3px 4px 0 rgba(0,0,0,.14),0 3px 3px -2px rgba(0,0,0,.12)}.md-whiteframe-4dp,.md-whiteframe-z2{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.md-whiteframe-5dp{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 5px 8px 0 rgba(0,0,0,.14),0 1px 14px 0 rgba(0,0,0,.12)}.md-whiteframe-6dp{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.md-whiteframe-7dp,.md-whiteframe-z3{box-shadow:0 4px 5px -2px rgba(0,0,0,.2),0 7px 10px 1px rgba(0,0,0,.14),0 2px 16px 1px rgba(0,0,0,.12)}.md-whiteframe-8dp{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.md-whiteframe-9dp{box-shadow:0 5px 6px -3px rgba(0,0,0,.2),0 9px 12px 1px rgba(0,0,0,.14),0 3px 16px 2px rgba(0,0,0,.12)}.md-whiteframe-10dp,.md-whiteframe-z4{box-shadow:0 6px 6px -3px rgba(0,0,0,.2),0 10px 14px 1px rgba(0,0,0,.14),0 4px 18px 3px rgba(0,0,0,.12)}.md-whiteframe-11dp{box-shadow:0 6px 7px -4px rgba(0,0,0,.2),0 11px 15px 1px rgba(0,0,0,.14),0 4px 20px 3px rgba(0,0,0,.12)}.md-whiteframe-12dp{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.md-whiteframe-13dp,.md-whiteframe-z5{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 13px 19px 2px rgba(0,0,0,.14),0 5px 24px 4px rgba(0,0,0,.12)}.md-whiteframe-14dp{box-shadow:0 7px 9px -4px rgba(0,0,0,.2),0 14px 21px 2px rgba(0,0,0,.14),0 5px 26px 4px rgba(0,0,0,.12)}.md-whiteframe-15dp{box-shadow:0 8px 9px -5px rgba(0,0,0,.2),0 15px 22px 2px rgba(0,0,0,.14),0 6px 28px 5px rgba(0,0,0,.12)}.md-whiteframe-16dp{box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.md-whiteframe-17dp{box-shadow:0 8px 11px -5px rgba(0,0,0,.2),0 17px 26px 2px rgba(0,0,0,.14),0 6px 32px 5px rgba(0,0,0,.12)}.md-whiteframe-18dp{box-shadow:0 9px 11px -5px rgba(0,0,0,.2),0 18px 28px 2px rgba(0,0,0,.14),0 7px 34px 6px rgba(0,0,0,.12)}.md-whiteframe-19dp{box-shadow:0 9px 12px -6px rgba(0,0,0,.2),0 19px 29px 2px rgba(0,0,0,.14),0 7px 36px 6px rgba(0,0,0,.12)}.md-whiteframe-20dp{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 20px 31px 3px rgba(0,0,0,.14),0 8px 38px 7px rgba(0,0,0,.12)}.md-whiteframe-21dp{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 21px 33px 3px rgba(0,0,0,.14),0 8px 40px 7px rgba(0,0,0,.12)}.md-whiteframe-22dp{box-shadow:0 10px 14px -6px rgba(0,0,0,.2),0 22px 35px 3px rgba(0,0,0,.14),0 8px 42px 7px rgba(0,0,0,.12)}.md-whiteframe-23dp{box-shadow:0 11px 14px -7px rgba(0,0,0,.2),0 23px 36px 3px rgba(0,0,0,.14),0 9px 44px 8px rgba(0,0,0,.12)}.md-whiteframe-24dp{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){md-whiteframe{border:1px solid #fff}}@-moz-document url-prefix(){[layout-fill]{margin:0;width:100%;min-height:100%;height:100%}}[flex-order]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset=\"0\"]{margin-left:0}[flex-offset=\"5\"]{margin-left:5%}[flex-offset=\"10\"]{margin-left:10%}[flex-offset=\"15\"]{margin-left:15%}[flex-offset=\"20\"]{margin-left:20%}[flex-offset=\"25\"]{margin-left:25%}[flex-offset=\"30\"]{margin-left:30%}[flex-offset=\"35\"]{margin-left:35%}[flex-offset=\"40\"]{margin-left:40%}[flex-offset=\"45\"]{margin-left:45%}[flex-offset=\"50\"]{margin-left:50%}[flex-offset=\"55\"]{margin-left:55%}[flex-offset=\"60\"]{margin-left:60%}[flex-offset=\"65\"]{margin-left:65%}[flex-offset=\"70\"]{margin-left:70%}[flex-offset=\"75\"]{margin-left:75%}[flex-offset=\"80\"]{margin-left:80%}[flex-offset=\"85\"]{margin-left:85%}[flex-offset=\"90\"]{margin-left:90%}[flex-offset=\"95\"]{margin-left:95%}[flex-offset=\"33\"]{margin-left:calc(100% / 3)}[flex-offset=\"66\"]{margin-left:calc(200% / 3)}[layout-align]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align=start],[layout-align=\"start start\"],[layout-align=\"start center\"],[layout-align=\"start end\"],[layout-align=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align=center],[layout-align=\"center start\"],[layout-align=\"center center\"],[layout-align=\"center end\"],[layout-align=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align=end],[layout-align=\"end center\"],[layout-align=\"end start\"],[layout-align=\"end end\"],[layout-align=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align=\"space-around end\"],[layout-align=\"space-around stretch\"],[layout-align=space-around],[layout-align=\"space-around center\"],[layout-align=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align=space-between],[layout-align=\"space-between center\"],[layout-align=\"space-between start\"],[layout-align=\"space-between end\"],[layout-align=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align=\"space-between start\"],[layout-align=\"start start\"],[layout-align=\"center start\"],[layout-align=\"end start\"],[layout-align=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align=\"space-between center\"],[layout-align=\"start center\"],[layout-align=\"center center\"],[layout-align=\"end center\"],[layout-align=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align=\"space-between center\"]>*,[layout-align=\"start center\"]>*,[layout-align=\"center center\"]>*,[layout-align=\"end center\"]>*,[layout-align=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align=\"space-around end\"],[layout-align=\"space-between end\"],[layout-align=\"start end\"],[layout-align=\"center end\"],[layout-align=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align=\"space-around stretch\"],[layout-align=\"space-between stretch\"],[layout-align=\"start stretch\"],[layout-align=\"center stretch\"],[layout-align=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}@media screen\\0{[flex]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}[flex-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout=row]>[flex=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout=column]>[flex=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout=column]>[flex=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout=row],[layout=column],[layout]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}[layout-padding]>[flex-lt-md],[layout-padding]>[flex-sm]{padding:4px}[layout-padding],[layout-padding]>[flex-gt-sm],[layout-padding]>[flex-lt-lg],[layout-padding]>[flex-md],[layout-padding]>[flex]{padding:8px}[layout-padding]>[flex-gt-md],[layout-padding]>[flex-lg]{padding:16px}[layout-margin]>[flex-lt-md],[layout-margin]>[flex-sm]{margin:4px}[layout-margin],[layout-margin]>[flex-gt-sm],[layout-margin]>[flex-lt-lg],[layout-margin]>[flex-md],[layout-margin]>[flex]{margin:8px}[layout-margin]>[flex-gt-md],[layout-margin]>[flex-lg]{margin:16px}[layout-wrap]{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}[layout-nowrap]{-webkit-flex-wrap:nowrap;-ms-flex-wrap:nowrap;flex-wrap:nowrap}[layout-fill]{margin:0;width:100%;min-height:100%;height:100%}@media (max-width:599px){[hide-xs]:not([show-xs]):not([show]),[hide]:not([show-xs]):not([show]){display:none}[flex-order-xs=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-xs=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-xs=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-xs=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-xs=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-xs=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-xs=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-xs=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-xs=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-xs=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-xs=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-xs=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-xs=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-xs=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-xs=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-xs=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-xs=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-xs=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-xs=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-xs=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-xs=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-xs=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-xs=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-xs=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-xs=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-xs=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-xs=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-xs=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-xs=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-xs=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-xs=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-xs=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-xs=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-xs=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-xs=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-xs=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-xs=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-xs=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-xs=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-xs=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-xs=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-xs=\"0\"]{margin-left:0}[flex-offset-xs=\"5\"]{margin-left:5%}[flex-offset-xs=\"10\"]{margin-left:10%}[flex-offset-xs=\"15\"]{margin-left:15%}[flex-offset-xs=\"20\"]{margin-left:20%}[flex-offset-xs=\"25\"]{margin-left:25%}[flex-offset-xs=\"30\"]{margin-left:30%}[flex-offset-xs=\"35\"]{margin-left:35%}[flex-offset-xs=\"40\"]{margin-left:40%}[flex-offset-xs=\"45\"]{margin-left:45%}[flex-offset-xs=\"50\"]{margin-left:50%}[flex-offset-xs=\"55\"]{margin-left:55%}[flex-offset-xs=\"60\"]{margin-left:60%}[flex-offset-xs=\"65\"]{margin-left:65%}[flex-offset-xs=\"70\"]{margin-left:70%}[flex-offset-xs=\"75\"]{margin-left:75%}[flex-offset-xs=\"80\"]{margin-left:80%}[flex-offset-xs=\"85\"]{margin-left:85%}[flex-offset-xs=\"90\"]{margin-left:90%}[flex-offset-xs=\"95\"]{margin-left:95%}[flex-offset-xs=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-xs=\"66\"]{margin-left:calc(200% / 3)}[layout-align-xs]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-xs=start],[layout-align-xs=\"start start\"],[layout-align-xs=\"start center\"],[layout-align-xs=\"start end\"],[layout-align-xs=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-xs=center],[layout-align-xs=\"center start\"],[layout-align-xs=\"center center\"],[layout-align-xs=\"center end\"],[layout-align-xs=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-xs=end],[layout-align-xs=\"end center\"],[layout-align-xs=\"end start\"],[layout-align-xs=\"end end\"],[layout-align-xs=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-xs=\"space-around end\"],[layout-align-xs=\"space-around stretch\"],[layout-align-xs=space-around],[layout-align-xs=\"space-around center\"],[layout-align-xs=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-xs=space-between],[layout-align-xs=\"space-between center\"],[layout-align-xs=\"space-between start\"],[layout-align-xs=\"space-between end\"],[layout-align-xs=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-xs=\"space-between start\"],[layout-align-xs=\"start start\"],[layout-align-xs=\"center start\"],[layout-align-xs=\"end start\"],[layout-align-xs=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-xs=\"space-between center\"],[layout-align-xs=\"start center\"],[layout-align-xs=\"center center\"],[layout-align-xs=\"end center\"],[layout-align-xs=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-xs=\"space-between center\"]>*,[layout-align-xs=\"start center\"]>*,[layout-align-xs=\"center center\"]>*,[layout-align-xs=\"end center\"]>*,[layout-align-xs=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-xs=\"space-around end\"],[layout-align-xs=\"space-between end\"],[layout-align-xs=\"start end\"],[layout-align-xs=\"center end\"],[layout-align-xs=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-xs=\"space-around stretch\"],[layout-align-xs=\"space-between stretch\"],[layout-align-xs=\"start stretch\"],[layout-align-xs=\"center stretch\"],[layout-align-xs=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-xs]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (max-width:599px){[flex-xs]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (max-width:599px){[flex-xs-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-xs-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-xs-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-xs-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"0\"],[layout=row]>[flex-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"0\"],[layout=column]>[flex-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"5\"],[layout=row]>[flex-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"5\"],[layout=column]>[flex-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"10\"],[layout=row]>[flex-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"10\"],[layout=column]>[flex-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"15\"],[layout=row]>[flex-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"15\"],[layout=column]>[flex-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"20\"],[layout=row]>[flex-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"20\"],[layout=column]>[flex-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"25\"],[layout=row]>[flex-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"25\"],[layout=column]>[flex-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"30\"],[layout=row]>[flex-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"30\"],[layout=column]>[flex-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"35\"],[layout=row]>[flex-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"35\"],[layout=column]>[flex-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"40\"],[layout=row]>[flex-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"40\"],[layout=column]>[flex-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"45\"],[layout=row]>[flex-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"45\"],[layout=column]>[flex-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"50\"],[layout=row]>[flex-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"50\"],[layout=column]>[flex-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"55\"],[layout=row]>[flex-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"55\"],[layout=column]>[flex-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"60\"],[layout=row]>[flex-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"60\"],[layout=column]>[flex-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"65\"],[layout=row]>[flex-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"65\"],[layout=column]>[flex-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"70\"],[layout=row]>[flex-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"70\"],[layout=column]>[flex-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"75\"],[layout=row]>[flex-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"75\"],[layout=column]>[flex-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"80\"],[layout=row]>[flex-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"80\"],[layout=column]>[flex-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"85\"],[layout=row]>[flex-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"85\"],[layout=column]>[flex-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"90\"],[layout=row]>[flex-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"90\"],[layout=column]>[flex-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"95\"],[layout=row]>[flex-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"95\"],[layout=column]>[flex-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"100\"],[layout=row]>[flex-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"100\"],[layout=column]>[flex-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"33\"],[layout=row]>[flex-xs=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-xs=row]>[flex-xs=\"66\"],[layout=row]>[flex-xs=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"33\"],[layout=column]>[flex-xs=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-xs=column]>[flex-xs=\"66\"],[layout=column]>[flex-xs=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-xs=row],[layout-xs=column],[layout-xs]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-xs=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-xs=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:600px){[flex-order-gt-xs=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-gt-xs=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-gt-xs=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-gt-xs=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-gt-xs=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-gt-xs=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-gt-xs=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-gt-xs=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-gt-xs=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-gt-xs=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-gt-xs=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-gt-xs=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-gt-xs=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-gt-xs=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-gt-xs=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-gt-xs=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-gt-xs=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-gt-xs=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-gt-xs=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-gt-xs=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-gt-xs=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-gt-xs=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-gt-xs=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-gt-xs=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-gt-xs=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-gt-xs=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-gt-xs=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-gt-xs=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-gt-xs=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-gt-xs=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-gt-xs=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-gt-xs=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-gt-xs=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-gt-xs=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-gt-xs=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-gt-xs=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-gt-xs=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-gt-xs=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-gt-xs=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-gt-xs=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-gt-xs=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-gt-xs=\"0\"]{margin-left:0}[flex-offset-gt-xs=\"5\"]{margin-left:5%}[flex-offset-gt-xs=\"10\"]{margin-left:10%}[flex-offset-gt-xs=\"15\"]{margin-left:15%}[flex-offset-gt-xs=\"20\"]{margin-left:20%}[flex-offset-gt-xs=\"25\"]{margin-left:25%}[flex-offset-gt-xs=\"30\"]{margin-left:30%}[flex-offset-gt-xs=\"35\"]{margin-left:35%}[flex-offset-gt-xs=\"40\"]{margin-left:40%}[flex-offset-gt-xs=\"45\"]{margin-left:45%}[flex-offset-gt-xs=\"50\"]{margin-left:50%}[flex-offset-gt-xs=\"55\"]{margin-left:55%}[flex-offset-gt-xs=\"60\"]{margin-left:60%}[flex-offset-gt-xs=\"65\"]{margin-left:65%}[flex-offset-gt-xs=\"70\"]{margin-left:70%}[flex-offset-gt-xs=\"75\"]{margin-left:75%}[flex-offset-gt-xs=\"80\"]{margin-left:80%}[flex-offset-gt-xs=\"85\"]{margin-left:85%}[flex-offset-gt-xs=\"90\"]{margin-left:90%}[flex-offset-gt-xs=\"95\"]{margin-left:95%}[flex-offset-gt-xs=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-gt-xs=\"66\"]{margin-left:calc(200% / 3)}[layout-align-gt-xs]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-gt-xs=start],[layout-align-gt-xs=\"start start\"],[layout-align-gt-xs=\"start center\"],[layout-align-gt-xs=\"start end\"],[layout-align-gt-xs=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-gt-xs=center],[layout-align-gt-xs=\"center start\"],[layout-align-gt-xs=\"center center\"],[layout-align-gt-xs=\"center end\"],[layout-align-gt-xs=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-gt-xs=end],[layout-align-gt-xs=\"end center\"],[layout-align-gt-xs=\"end start\"],[layout-align-gt-xs=\"end end\"],[layout-align-gt-xs=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-gt-xs=\"space-around end\"],[layout-align-gt-xs=\"space-around stretch\"],[layout-align-gt-xs=space-around],[layout-align-gt-xs=\"space-around center\"],[layout-align-gt-xs=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-gt-xs=space-between],[layout-align-gt-xs=\"space-between center\"],[layout-align-gt-xs=\"space-between start\"],[layout-align-gt-xs=\"space-between end\"],[layout-align-gt-xs=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-gt-xs=\"space-between start\"],[layout-align-gt-xs=\"start start\"],[layout-align-gt-xs=\"center start\"],[layout-align-gt-xs=\"end start\"],[layout-align-gt-xs=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-gt-xs=\"space-between center\"],[layout-align-gt-xs=\"start center\"],[layout-align-gt-xs=\"center center\"],[layout-align-gt-xs=\"end center\"],[layout-align-gt-xs=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-gt-xs=\"space-between center\"]>*,[layout-align-gt-xs=\"start center\"]>*,[layout-align-gt-xs=\"center center\"]>*,[layout-align-gt-xs=\"end center\"]>*,[layout-align-gt-xs=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-gt-xs=\"space-around end\"],[layout-align-gt-xs=\"space-between end\"],[layout-align-gt-xs=\"start end\"],[layout-align-gt-xs=\"center end\"],[layout-align-gt-xs=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-gt-xs=\"space-around stretch\"],[layout-align-gt-xs=\"space-between stretch\"],[layout-align-gt-xs=\"start stretch\"],[layout-align-gt-xs=\"center stretch\"],[layout-align-gt-xs=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-gt-xs]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:600px){[flex-gt-xs]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:600px){[flex-gt-xs-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-gt-xs-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-gt-xs-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-gt-xs-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-gt-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"0\"],[layout=row]>[flex-gt-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"0\"],[layout=column]>[flex-gt-xs=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-gt-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"5\"],[layout=row]>[flex-gt-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"5\"],[layout=column]>[flex-gt-xs=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-gt-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"10\"],[layout=row]>[flex-gt-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"10\"],[layout=column]>[flex-gt-xs=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-gt-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"15\"],[layout=row]>[flex-gt-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"15\"],[layout=column]>[flex-gt-xs=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-gt-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"20\"],[layout=row]>[flex-gt-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"20\"],[layout=column]>[flex-gt-xs=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-gt-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"25\"],[layout=row]>[flex-gt-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"25\"],[layout=column]>[flex-gt-xs=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-gt-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"30\"],[layout=row]>[flex-gt-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"30\"],[layout=column]>[flex-gt-xs=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-gt-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"35\"],[layout=row]>[flex-gt-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"35\"],[layout=column]>[flex-gt-xs=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-gt-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"40\"],[layout=row]>[flex-gt-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"40\"],[layout=column]>[flex-gt-xs=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-gt-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"45\"],[layout=row]>[flex-gt-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"45\"],[layout=column]>[flex-gt-xs=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-gt-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"50\"],[layout=row]>[flex-gt-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"50\"],[layout=column]>[flex-gt-xs=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-gt-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"55\"],[layout=row]>[flex-gt-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"55\"],[layout=column]>[flex-gt-xs=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-gt-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"60\"],[layout=row]>[flex-gt-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"60\"],[layout=column]>[flex-gt-xs=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-gt-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"65\"],[layout=row]>[flex-gt-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"65\"],[layout=column]>[flex-gt-xs=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-gt-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"70\"],[layout=row]>[flex-gt-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"70\"],[layout=column]>[flex-gt-xs=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-gt-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"75\"],[layout=row]>[flex-gt-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"75\"],[layout=column]>[flex-gt-xs=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-gt-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"80\"],[layout=row]>[flex-gt-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"80\"],[layout=column]>[flex-gt-xs=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-gt-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"85\"],[layout=row]>[flex-gt-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"85\"],[layout=column]>[flex-gt-xs=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-gt-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"90\"],[layout=row]>[flex-gt-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"90\"],[layout=column]>[flex-gt-xs=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-gt-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"95\"],[layout=row]>[flex-gt-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"95\"],[layout=column]>[flex-gt-xs=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-gt-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"100\"],[layout=row]>[flex-gt-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"100\"],[layout=column]>[flex-gt-xs=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"33\"],[layout=row]>[flex-gt-xs=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-gt-xs=row]>[flex-gt-xs=\"66\"],[layout=row]>[flex-gt-xs=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"33\"],[layout=column]>[flex-gt-xs=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-gt-xs=column]>[flex-gt-xs=\"66\"],[layout=column]>[flex-gt-xs=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-gt-xs=row],[layout-gt-xs=column],[layout-gt-xs]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-gt-xs=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-gt-xs=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:600px) and (max-width:959px){[hide-gt-xs]:not([show-gt-xs]):not([show-sm]):not([show]),[hide-sm]:not([show-gt-xs]):not([show-sm]):not([show]){display:none}[hide-sm]:not([show-sm]):not([show]){display:none}[flex-order-sm=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-sm=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-sm=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-sm=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-sm=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-sm=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-sm=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-sm=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-sm=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-sm=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-sm=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-sm=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-sm=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-sm=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-sm=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-sm=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-sm=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-sm=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-sm=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-sm=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-sm=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-sm=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-sm=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-sm=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-sm=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-sm=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-sm=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-sm=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-sm=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-sm=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-sm=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-sm=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-sm=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-sm=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-sm=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-sm=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-sm=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-sm=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-sm=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-sm=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-sm=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-sm=\"0\"]{margin-left:0}[flex-offset-sm=\"5\"]{margin-left:5%}[flex-offset-sm=\"10\"]{margin-left:10%}[flex-offset-sm=\"15\"]{margin-left:15%}[flex-offset-sm=\"20\"]{margin-left:20%}[flex-offset-sm=\"25\"]{margin-left:25%}[flex-offset-sm=\"30\"]{margin-left:30%}[flex-offset-sm=\"35\"]{margin-left:35%}[flex-offset-sm=\"40\"]{margin-left:40%}[flex-offset-sm=\"45\"]{margin-left:45%}[flex-offset-sm=\"50\"]{margin-left:50%}[flex-offset-sm=\"55\"]{margin-left:55%}[flex-offset-sm=\"60\"]{margin-left:60%}[flex-offset-sm=\"65\"]{margin-left:65%}[flex-offset-sm=\"70\"]{margin-left:70%}[flex-offset-sm=\"75\"]{margin-left:75%}[flex-offset-sm=\"80\"]{margin-left:80%}[flex-offset-sm=\"85\"]{margin-left:85%}[flex-offset-sm=\"90\"]{margin-left:90%}[flex-offset-sm=\"95\"]{margin-left:95%}[flex-offset-sm=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-sm=\"66\"]{margin-left:calc(200% / 3)}[layout-align-sm]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-sm=start],[layout-align-sm=\"start start\"],[layout-align-sm=\"start center\"],[layout-align-sm=\"start end\"],[layout-align-sm=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-sm=center],[layout-align-sm=\"center start\"],[layout-align-sm=\"center center\"],[layout-align-sm=\"center end\"],[layout-align-sm=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-sm=end],[layout-align-sm=\"end center\"],[layout-align-sm=\"end start\"],[layout-align-sm=\"end end\"],[layout-align-sm=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-sm=\"space-around end\"],[layout-align-sm=\"space-around stretch\"],[layout-align-sm=space-around],[layout-align-sm=\"space-around center\"],[layout-align-sm=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-sm=space-between],[layout-align-sm=\"space-between center\"],[layout-align-sm=\"space-between start\"],[layout-align-sm=\"space-between end\"],[layout-align-sm=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-sm=\"space-between start\"],[layout-align-sm=\"start start\"],[layout-align-sm=\"center start\"],[layout-align-sm=\"end start\"],[layout-align-sm=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-sm=\"space-between center\"],[layout-align-sm=\"start center\"],[layout-align-sm=\"center center\"],[layout-align-sm=\"end center\"],[layout-align-sm=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-sm=\"space-between center\"]>*,[layout-align-sm=\"start center\"]>*,[layout-align-sm=\"center center\"]>*,[layout-align-sm=\"end center\"]>*,[layout-align-sm=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-sm=\"space-around end\"],[layout-align-sm=\"space-between end\"],[layout-align-sm=\"start end\"],[layout-align-sm=\"center end\"],[layout-align-sm=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-sm=\"space-around stretch\"],[layout-align-sm=\"space-between stretch\"],[layout-align-sm=\"start stretch\"],[layout-align-sm=\"center stretch\"],[layout-align-sm=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-sm]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:600px) and (max-width:959px){[flex-sm]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:600px) and (max-width:959px){[flex-sm-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-sm-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-sm-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-sm-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"0\"],[layout=row]>[flex-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"0\"],[layout=column]>[flex-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"5\"],[layout=row]>[flex-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"5\"],[layout=column]>[flex-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"10\"],[layout=row]>[flex-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"10\"],[layout=column]>[flex-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"15\"],[layout=row]>[flex-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"15\"],[layout=column]>[flex-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"20\"],[layout=row]>[flex-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"20\"],[layout=column]>[flex-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"25\"],[layout=row]>[flex-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"25\"],[layout=column]>[flex-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"30\"],[layout=row]>[flex-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"30\"],[layout=column]>[flex-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"35\"],[layout=row]>[flex-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"35\"],[layout=column]>[flex-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"40\"],[layout=row]>[flex-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"40\"],[layout=column]>[flex-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"45\"],[layout=row]>[flex-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"45\"],[layout=column]>[flex-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"50\"],[layout=row]>[flex-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"50\"],[layout=column]>[flex-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"55\"],[layout=row]>[flex-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"55\"],[layout=column]>[flex-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"60\"],[layout=row]>[flex-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"60\"],[layout=column]>[flex-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"65\"],[layout=row]>[flex-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"65\"],[layout=column]>[flex-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"70\"],[layout=row]>[flex-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"70\"],[layout=column]>[flex-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"75\"],[layout=row]>[flex-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"75\"],[layout=column]>[flex-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"80\"],[layout=row]>[flex-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"80\"],[layout=column]>[flex-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"85\"],[layout=row]>[flex-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"85\"],[layout=column]>[flex-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"90\"],[layout=row]>[flex-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"90\"],[layout=column]>[flex-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"95\"],[layout=row]>[flex-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"95\"],[layout=column]>[flex-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"100\"],[layout=row]>[flex-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"100\"],[layout=column]>[flex-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"33\"],[layout=row]>[flex-sm=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-sm=row]>[flex-sm=\"66\"],[layout=row]>[flex-sm=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"33\"],[layout=column]>[flex-sm=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-sm=column]>[flex-sm=\"66\"],[layout=column]>[flex-sm=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-sm=row],[layout-sm=column],[layout-sm]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-sm=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-sm=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:960px){[flex-order-gt-sm=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-gt-sm=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-gt-sm=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-gt-sm=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-gt-sm=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-gt-sm=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-gt-sm=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-gt-sm=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-gt-sm=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-gt-sm=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-gt-sm=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-gt-sm=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-gt-sm=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-gt-sm=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-gt-sm=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-gt-sm=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-gt-sm=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-gt-sm=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-gt-sm=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-gt-sm=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-gt-sm=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-gt-sm=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-gt-sm=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-gt-sm=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-gt-sm=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-gt-sm=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-gt-sm=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-gt-sm=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-gt-sm=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-gt-sm=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-gt-sm=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-gt-sm=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-gt-sm=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-gt-sm=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-gt-sm=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-gt-sm=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-gt-sm=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-gt-sm=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-gt-sm=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-gt-sm=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-gt-sm=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-gt-sm=\"0\"]{margin-left:0}[flex-offset-gt-sm=\"5\"]{margin-left:5%}[flex-offset-gt-sm=\"10\"]{margin-left:10%}[flex-offset-gt-sm=\"15\"]{margin-left:15%}[flex-offset-gt-sm=\"20\"]{margin-left:20%}[flex-offset-gt-sm=\"25\"]{margin-left:25%}[flex-offset-gt-sm=\"30\"]{margin-left:30%}[flex-offset-gt-sm=\"35\"]{margin-left:35%}[flex-offset-gt-sm=\"40\"]{margin-left:40%}[flex-offset-gt-sm=\"45\"]{margin-left:45%}[flex-offset-gt-sm=\"50\"]{margin-left:50%}[flex-offset-gt-sm=\"55\"]{margin-left:55%}[flex-offset-gt-sm=\"60\"]{margin-left:60%}[flex-offset-gt-sm=\"65\"]{margin-left:65%}[flex-offset-gt-sm=\"70\"]{margin-left:70%}[flex-offset-gt-sm=\"75\"]{margin-left:75%}[flex-offset-gt-sm=\"80\"]{margin-left:80%}[flex-offset-gt-sm=\"85\"]{margin-left:85%}[flex-offset-gt-sm=\"90\"]{margin-left:90%}[flex-offset-gt-sm=\"95\"]{margin-left:95%}[flex-offset-gt-sm=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-gt-sm=\"66\"]{margin-left:calc(200% / 3)}[layout-align-gt-sm]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-gt-sm=start],[layout-align-gt-sm=\"start start\"],[layout-align-gt-sm=\"start center\"],[layout-align-gt-sm=\"start end\"],[layout-align-gt-sm=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-gt-sm=center],[layout-align-gt-sm=\"center start\"],[layout-align-gt-sm=\"center center\"],[layout-align-gt-sm=\"center end\"],[layout-align-gt-sm=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-gt-sm=end],[layout-align-gt-sm=\"end center\"],[layout-align-gt-sm=\"end start\"],[layout-align-gt-sm=\"end end\"],[layout-align-gt-sm=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-gt-sm=\"space-around end\"],[layout-align-gt-sm=\"space-around stretch\"],[layout-align-gt-sm=space-around],[layout-align-gt-sm=\"space-around center\"],[layout-align-gt-sm=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-gt-sm=space-between],[layout-align-gt-sm=\"space-between center\"],[layout-align-gt-sm=\"space-between start\"],[layout-align-gt-sm=\"space-between end\"],[layout-align-gt-sm=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-gt-sm=\"space-between start\"],[layout-align-gt-sm=\"start start\"],[layout-align-gt-sm=\"center start\"],[layout-align-gt-sm=\"end start\"],[layout-align-gt-sm=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-gt-sm=\"space-between center\"],[layout-align-gt-sm=\"start center\"],[layout-align-gt-sm=\"center center\"],[layout-align-gt-sm=\"end center\"],[layout-align-gt-sm=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-gt-sm=\"space-between center\"]>*,[layout-align-gt-sm=\"start center\"]>*,[layout-align-gt-sm=\"center center\"]>*,[layout-align-gt-sm=\"end center\"]>*,[layout-align-gt-sm=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-gt-sm=\"space-around end\"],[layout-align-gt-sm=\"space-between end\"],[layout-align-gt-sm=\"start end\"],[layout-align-gt-sm=\"center end\"],[layout-align-gt-sm=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-gt-sm=\"space-around stretch\"],[layout-align-gt-sm=\"space-between stretch\"],[layout-align-gt-sm=\"start stretch\"],[layout-align-gt-sm=\"center stretch\"],[layout-align-gt-sm=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-gt-sm]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:960px){[flex-gt-sm]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:960px){[flex-gt-sm-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-gt-sm-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-gt-sm-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-gt-sm-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-gt-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"0\"],[layout=row]>[flex-gt-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"0\"],[layout=column]>[flex-gt-sm=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-gt-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"5\"],[layout=row]>[flex-gt-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"5\"],[layout=column]>[flex-gt-sm=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-gt-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"10\"],[layout=row]>[flex-gt-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"10\"],[layout=column]>[flex-gt-sm=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-gt-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"15\"],[layout=row]>[flex-gt-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"15\"],[layout=column]>[flex-gt-sm=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-gt-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"20\"],[layout=row]>[flex-gt-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"20\"],[layout=column]>[flex-gt-sm=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-gt-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"25\"],[layout=row]>[flex-gt-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"25\"],[layout=column]>[flex-gt-sm=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-gt-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"30\"],[layout=row]>[flex-gt-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"30\"],[layout=column]>[flex-gt-sm=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-gt-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"35\"],[layout=row]>[flex-gt-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"35\"],[layout=column]>[flex-gt-sm=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-gt-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"40\"],[layout=row]>[flex-gt-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"40\"],[layout=column]>[flex-gt-sm=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-gt-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"45\"],[layout=row]>[flex-gt-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"45\"],[layout=column]>[flex-gt-sm=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-gt-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"50\"],[layout=row]>[flex-gt-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"50\"],[layout=column]>[flex-gt-sm=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-gt-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"55\"],[layout=row]>[flex-gt-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"55\"],[layout=column]>[flex-gt-sm=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-gt-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"60\"],[layout=row]>[flex-gt-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"60\"],[layout=column]>[flex-gt-sm=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-gt-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"65\"],[layout=row]>[flex-gt-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"65\"],[layout=column]>[flex-gt-sm=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-gt-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"70\"],[layout=row]>[flex-gt-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"70\"],[layout=column]>[flex-gt-sm=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-gt-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"75\"],[layout=row]>[flex-gt-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"75\"],[layout=column]>[flex-gt-sm=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-gt-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"80\"],[layout=row]>[flex-gt-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"80\"],[layout=column]>[flex-gt-sm=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-gt-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"85\"],[layout=row]>[flex-gt-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"85\"],[layout=column]>[flex-gt-sm=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-gt-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"90\"],[layout=row]>[flex-gt-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"90\"],[layout=column]>[flex-gt-sm=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-gt-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"95\"],[layout=row]>[flex-gt-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"95\"],[layout=column]>[flex-gt-sm=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-gt-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"100\"],[layout=row]>[flex-gt-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"100\"],[layout=column]>[flex-gt-sm=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"33\"],[layout=row]>[flex-gt-sm=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-gt-sm=row]>[flex-gt-sm=\"66\"],[layout=row]>[flex-gt-sm=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"33\"],[layout=column]>[flex-gt-sm=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-gt-sm=column]>[flex-gt-sm=\"66\"],[layout=column]>[flex-gt-sm=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-gt-sm=row],[layout-gt-sm=column],[layout-gt-sm]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-gt-sm=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-gt-sm=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:960px) and (max-width:1279px){[hide-gt-sm]:not([show-gt-xs]):not([show-gt-sm]):not([show-md]):not([show]),[hide-gt-xs]:not([show-gt-xs]):not([show-gt-sm]):not([show-md]):not([show]),[hide]:not([show-gt-xs]):not([show-gt-sm]):not([show-md]):not([show]){display:none}[hide-md]:not([show-md]):not([show]){display:none}[flex-order-md=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-md=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-md=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-md=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-md=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-md=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-md=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-md=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-md=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-md=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-md=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-md=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-md=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-md=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-md=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-md=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-md=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-md=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-md=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-md=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-md=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-md=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-md=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-md=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-md=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-md=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-md=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-md=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-md=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-md=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-md=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-md=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-md=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-md=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-md=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-md=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-md=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-md=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-md=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-md=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-md=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-md=\"0\"]{margin-left:0}[flex-offset-md=\"5\"]{margin-left:5%}[flex-offset-md=\"10\"]{margin-left:10%}[flex-offset-md=\"15\"]{margin-left:15%}[flex-offset-md=\"20\"]{margin-left:20%}[flex-offset-md=\"25\"]{margin-left:25%}[flex-offset-md=\"30\"]{margin-left:30%}[flex-offset-md=\"35\"]{margin-left:35%}[flex-offset-md=\"40\"]{margin-left:40%}[flex-offset-md=\"45\"]{margin-left:45%}[flex-offset-md=\"50\"]{margin-left:50%}[flex-offset-md=\"55\"]{margin-left:55%}[flex-offset-md=\"60\"]{margin-left:60%}[flex-offset-md=\"65\"]{margin-left:65%}[flex-offset-md=\"70\"]{margin-left:70%}[flex-offset-md=\"75\"]{margin-left:75%}[flex-offset-md=\"80\"]{margin-left:80%}[flex-offset-md=\"85\"]{margin-left:85%}[flex-offset-md=\"90\"]{margin-left:90%}[flex-offset-md=\"95\"]{margin-left:95%}[flex-offset-md=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-md=\"66\"]{margin-left:calc(200% / 3)}[layout-align-md]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-md=start],[layout-align-md=\"start start\"],[layout-align-md=\"start center\"],[layout-align-md=\"start end\"],[layout-align-md=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-md=center],[layout-align-md=\"center start\"],[layout-align-md=\"center center\"],[layout-align-md=\"center end\"],[layout-align-md=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-md=end],[layout-align-md=\"end center\"],[layout-align-md=\"end start\"],[layout-align-md=\"end end\"],[layout-align-md=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-md=\"space-around end\"],[layout-align-md=\"space-around stretch\"],[layout-align-md=space-around],[layout-align-md=\"space-around center\"],[layout-align-md=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-md=space-between],[layout-align-md=\"space-between center\"],[layout-align-md=\"space-between start\"],[layout-align-md=\"space-between end\"],[layout-align-md=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-md=\"space-between start\"],[layout-align-md=\"start start\"],[layout-align-md=\"center start\"],[layout-align-md=\"end start\"],[layout-align-md=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-md=\"space-between center\"],[layout-align-md=\"start center\"],[layout-align-md=\"center center\"],[layout-align-md=\"end center\"],[layout-align-md=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-md=\"space-between center\"]>*,[layout-align-md=\"start center\"]>*,[layout-align-md=\"center center\"]>*,[layout-align-md=\"end center\"]>*,[layout-align-md=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-md=\"space-around end\"],[layout-align-md=\"space-between end\"],[layout-align-md=\"start end\"],[layout-align-md=\"center end\"],[layout-align-md=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-md=\"space-around stretch\"],[layout-align-md=\"space-between stretch\"],[layout-align-md=\"start stretch\"],[layout-align-md=\"center stretch\"],[layout-align-md=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-md]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:960px) and (max-width:1279px){[flex-md]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:960px) and (max-width:1279px){[flex-md-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-md-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-md-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-md-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"0\"],[layout=row]>[flex-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"0\"],[layout=column]>[flex-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"5\"],[layout=row]>[flex-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"5\"],[layout=column]>[flex-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"10\"],[layout=row]>[flex-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"10\"],[layout=column]>[flex-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"15\"],[layout=row]>[flex-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"15\"],[layout=column]>[flex-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"20\"],[layout=row]>[flex-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"20\"],[layout=column]>[flex-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"25\"],[layout=row]>[flex-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"25\"],[layout=column]>[flex-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"30\"],[layout=row]>[flex-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"30\"],[layout=column]>[flex-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"35\"],[layout=row]>[flex-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"35\"],[layout=column]>[flex-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"40\"],[layout=row]>[flex-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"40\"],[layout=column]>[flex-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"45\"],[layout=row]>[flex-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"45\"],[layout=column]>[flex-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"50\"],[layout=row]>[flex-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"50\"],[layout=column]>[flex-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"55\"],[layout=row]>[flex-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"55\"],[layout=column]>[flex-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"60\"],[layout=row]>[flex-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"60\"],[layout=column]>[flex-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"65\"],[layout=row]>[flex-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"65\"],[layout=column]>[flex-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"70\"],[layout=row]>[flex-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"70\"],[layout=column]>[flex-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"75\"],[layout=row]>[flex-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"75\"],[layout=column]>[flex-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"80\"],[layout=row]>[flex-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"80\"],[layout=column]>[flex-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"85\"],[layout=row]>[flex-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"85\"],[layout=column]>[flex-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"90\"],[layout=row]>[flex-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"90\"],[layout=column]>[flex-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"95\"],[layout=row]>[flex-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"95\"],[layout=column]>[flex-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"100\"],[layout=row]>[flex-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"100\"],[layout=column]>[flex-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"33\"],[layout=row]>[flex-md=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-md=row]>[flex-md=\"66\"],[layout=row]>[flex-md=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-md=column]>[flex-md=\"33\"],[layout=column]>[flex-md=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-md=column]>[flex-md=\"66\"],[layout=column]>[flex-md=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-md=row],[layout-md=column],[layout-md]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-md=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-md=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1280px){[flex-order-gt-md=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-gt-md=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-gt-md=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-gt-md=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-gt-md=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-gt-md=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-gt-md=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-gt-md=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-gt-md=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-gt-md=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-gt-md=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-gt-md=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-gt-md=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-gt-md=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-gt-md=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-gt-md=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-gt-md=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-gt-md=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-gt-md=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-gt-md=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-gt-md=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-gt-md=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-gt-md=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-gt-md=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-gt-md=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-gt-md=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-gt-md=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-gt-md=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-gt-md=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-gt-md=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-gt-md=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-gt-md=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-gt-md=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-gt-md=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-gt-md=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-gt-md=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-gt-md=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-gt-md=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-gt-md=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-gt-md=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-gt-md=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-gt-md=\"0\"]{margin-left:0}[flex-offset-gt-md=\"5\"]{margin-left:5%}[flex-offset-gt-md=\"10\"]{margin-left:10%}[flex-offset-gt-md=\"15\"]{margin-left:15%}[flex-offset-gt-md=\"20\"]{margin-left:20%}[flex-offset-gt-md=\"25\"]{margin-left:25%}[flex-offset-gt-md=\"30\"]{margin-left:30%}[flex-offset-gt-md=\"35\"]{margin-left:35%}[flex-offset-gt-md=\"40\"]{margin-left:40%}[flex-offset-gt-md=\"45\"]{margin-left:45%}[flex-offset-gt-md=\"50\"]{margin-left:50%}[flex-offset-gt-md=\"55\"]{margin-left:55%}[flex-offset-gt-md=\"60\"]{margin-left:60%}[flex-offset-gt-md=\"65\"]{margin-left:65%}[flex-offset-gt-md=\"70\"]{margin-left:70%}[flex-offset-gt-md=\"75\"]{margin-left:75%}[flex-offset-gt-md=\"80\"]{margin-left:80%}[flex-offset-gt-md=\"85\"]{margin-left:85%}[flex-offset-gt-md=\"90\"]{margin-left:90%}[flex-offset-gt-md=\"95\"]{margin-left:95%}[flex-offset-gt-md=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-gt-md=\"66\"]{margin-left:calc(200% / 3)}[layout-align-gt-md]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-gt-md=start],[layout-align-gt-md=\"start start\"],[layout-align-gt-md=\"start center\"],[layout-align-gt-md=\"start end\"],[layout-align-gt-md=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-gt-md=center],[layout-align-gt-md=\"center start\"],[layout-align-gt-md=\"center center\"],[layout-align-gt-md=\"center end\"],[layout-align-gt-md=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-gt-md=end],[layout-align-gt-md=\"end center\"],[layout-align-gt-md=\"end start\"],[layout-align-gt-md=\"end end\"],[layout-align-gt-md=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-gt-md=\"space-around end\"],[layout-align-gt-md=\"space-around stretch\"],[layout-align-gt-md=space-around],[layout-align-gt-md=\"space-around center\"],[layout-align-gt-md=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-gt-md=space-between],[layout-align-gt-md=\"space-between center\"],[layout-align-gt-md=\"space-between start\"],[layout-align-gt-md=\"space-between end\"],[layout-align-gt-md=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-gt-md=\"space-between start\"],[layout-align-gt-md=\"start start\"],[layout-align-gt-md=\"center start\"],[layout-align-gt-md=\"end start\"],[layout-align-gt-md=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-gt-md=\"space-between center\"],[layout-align-gt-md=\"start center\"],[layout-align-gt-md=\"center center\"],[layout-align-gt-md=\"end center\"],[layout-align-gt-md=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-gt-md=\"space-between center\"]>*,[layout-align-gt-md=\"start center\"]>*,[layout-align-gt-md=\"center center\"]>*,[layout-align-gt-md=\"end center\"]>*,[layout-align-gt-md=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-gt-md=\"space-around end\"],[layout-align-gt-md=\"space-between end\"],[layout-align-gt-md=\"start end\"],[layout-align-gt-md=\"center end\"],[layout-align-gt-md=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-gt-md=\"space-around stretch\"],[layout-align-gt-md=\"space-between stretch\"],[layout-align-gt-md=\"start stretch\"],[layout-align-gt-md=\"center stretch\"],[layout-align-gt-md=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-gt-md]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1280px){[flex-gt-md]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1280px){[flex-gt-md-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-gt-md-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-gt-md-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-gt-md-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-gt-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"0\"],[layout=row]>[flex-gt-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"0\"],[layout=column]>[flex-gt-md=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-gt-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"5\"],[layout=row]>[flex-gt-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"5\"],[layout=column]>[flex-gt-md=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-gt-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"10\"],[layout=row]>[flex-gt-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"10\"],[layout=column]>[flex-gt-md=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-gt-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"15\"],[layout=row]>[flex-gt-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"15\"],[layout=column]>[flex-gt-md=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-gt-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"20\"],[layout=row]>[flex-gt-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"20\"],[layout=column]>[flex-gt-md=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-gt-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"25\"],[layout=row]>[flex-gt-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"25\"],[layout=column]>[flex-gt-md=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-gt-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"30\"],[layout=row]>[flex-gt-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"30\"],[layout=column]>[flex-gt-md=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-gt-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"35\"],[layout=row]>[flex-gt-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"35\"],[layout=column]>[flex-gt-md=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-gt-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"40\"],[layout=row]>[flex-gt-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"40\"],[layout=column]>[flex-gt-md=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-gt-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"45\"],[layout=row]>[flex-gt-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"45\"],[layout=column]>[flex-gt-md=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-gt-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"50\"],[layout=row]>[flex-gt-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"50\"],[layout=column]>[flex-gt-md=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-gt-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"55\"],[layout=row]>[flex-gt-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"55\"],[layout=column]>[flex-gt-md=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-gt-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"60\"],[layout=row]>[flex-gt-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"60\"],[layout=column]>[flex-gt-md=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-gt-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"65\"],[layout=row]>[flex-gt-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"65\"],[layout=column]>[flex-gt-md=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-gt-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"70\"],[layout=row]>[flex-gt-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"70\"],[layout=column]>[flex-gt-md=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-gt-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"75\"],[layout=row]>[flex-gt-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"75\"],[layout=column]>[flex-gt-md=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-gt-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"80\"],[layout=row]>[flex-gt-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"80\"],[layout=column]>[flex-gt-md=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-gt-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"85\"],[layout=row]>[flex-gt-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"85\"],[layout=column]>[flex-gt-md=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-gt-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"90\"],[layout=row]>[flex-gt-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"90\"],[layout=column]>[flex-gt-md=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-gt-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"95\"],[layout=row]>[flex-gt-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"95\"],[layout=column]>[flex-gt-md=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-gt-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"100\"],[layout=row]>[flex-gt-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"100\"],[layout=column]>[flex-gt-md=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"33\"],[layout=row]>[flex-gt-md=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-gt-md=row]>[flex-gt-md=\"66\"],[layout=row]>[flex-gt-md=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"33\"],[layout=column]>[flex-gt-md=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-gt-md=column]>[flex-gt-md=\"66\"],[layout=column]>[flex-gt-md=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-gt-md=row],[layout-gt-md=column],[layout-gt-md]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-gt-md=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-gt-md=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1280px) and (max-width:1919px){[hide-gt-md]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-lg]):not([show]),[hide-gt-sm]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-lg]):not([show]),[hide-gt-xs]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-lg]):not([show]),[hide]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-lg]):not([show]){display:none}[hide-lg]:not([show-lg]):not([show]){display:none}[flex-order-lg=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-lg=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-lg=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-lg=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-lg=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-lg=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-lg=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-lg=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-lg=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-lg=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-lg=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-lg=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-lg=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-lg=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-lg=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-lg=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-lg=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-lg=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-lg=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-lg=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-lg=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-lg=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-lg=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-lg=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-lg=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-lg=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-lg=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-lg=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-lg=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-lg=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-lg=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-lg=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-lg=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-lg=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-lg=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-lg=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-lg=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-lg=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-lg=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-lg=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-lg=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-lg=\"0\"]{margin-left:0}[flex-offset-lg=\"5\"]{margin-left:5%}[flex-offset-lg=\"10\"]{margin-left:10%}[flex-offset-lg=\"15\"]{margin-left:15%}[flex-offset-lg=\"20\"]{margin-left:20%}[flex-offset-lg=\"25\"]{margin-left:25%}[flex-offset-lg=\"30\"]{margin-left:30%}[flex-offset-lg=\"35\"]{margin-left:35%}[flex-offset-lg=\"40\"]{margin-left:40%}[flex-offset-lg=\"45\"]{margin-left:45%}[flex-offset-lg=\"50\"]{margin-left:50%}[flex-offset-lg=\"55\"]{margin-left:55%}[flex-offset-lg=\"60\"]{margin-left:60%}[flex-offset-lg=\"65\"]{margin-left:65%}[flex-offset-lg=\"70\"]{margin-left:70%}[flex-offset-lg=\"75\"]{margin-left:75%}[flex-offset-lg=\"80\"]{margin-left:80%}[flex-offset-lg=\"85\"]{margin-left:85%}[flex-offset-lg=\"90\"]{margin-left:90%}[flex-offset-lg=\"95\"]{margin-left:95%}[flex-offset-lg=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-lg=\"66\"]{margin-left:calc(200% / 3)}[layout-align-lg]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-lg=start],[layout-align-lg=\"start start\"],[layout-align-lg=\"start center\"],[layout-align-lg=\"start end\"],[layout-align-lg=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-lg=center],[layout-align-lg=\"center start\"],[layout-align-lg=\"center center\"],[layout-align-lg=\"center end\"],[layout-align-lg=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-lg=end],[layout-align-lg=\"end center\"],[layout-align-lg=\"end start\"],[layout-align-lg=\"end end\"],[layout-align-lg=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-lg=\"space-around end\"],[layout-align-lg=\"space-around stretch\"],[layout-align-lg=space-around],[layout-align-lg=\"space-around center\"],[layout-align-lg=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-lg=space-between],[layout-align-lg=\"space-between center\"],[layout-align-lg=\"space-between start\"],[layout-align-lg=\"space-between end\"],[layout-align-lg=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-lg=\"space-between start\"],[layout-align-lg=\"start start\"],[layout-align-lg=\"center start\"],[layout-align-lg=\"end start\"],[layout-align-lg=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-lg=\"space-between center\"],[layout-align-lg=\"start center\"],[layout-align-lg=\"center center\"],[layout-align-lg=\"end center\"],[layout-align-lg=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-lg=\"space-between center\"]>*,[layout-align-lg=\"start center\"]>*,[layout-align-lg=\"center center\"]>*,[layout-align-lg=\"end center\"]>*,[layout-align-lg=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-lg=\"space-around end\"],[layout-align-lg=\"space-between end\"],[layout-align-lg=\"start end\"],[layout-align-lg=\"center end\"],[layout-align-lg=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-lg=\"space-around stretch\"],[layout-align-lg=\"space-between stretch\"],[layout-align-lg=\"start stretch\"],[layout-align-lg=\"center stretch\"],[layout-align-lg=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-lg]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1280px) and (max-width:1919px){[flex-lg]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1280px) and (max-width:1919px){[flex-lg-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-lg-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-lg-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-lg-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"0\"],[layout=row]>[flex-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"0\"],[layout=column]>[flex-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"5\"],[layout=row]>[flex-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"5\"],[layout=column]>[flex-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"10\"],[layout=row]>[flex-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"10\"],[layout=column]>[flex-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"15\"],[layout=row]>[flex-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"15\"],[layout=column]>[flex-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"20\"],[layout=row]>[flex-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"20\"],[layout=column]>[flex-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"25\"],[layout=row]>[flex-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"25\"],[layout=column]>[flex-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"30\"],[layout=row]>[flex-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"30\"],[layout=column]>[flex-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"35\"],[layout=row]>[flex-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"35\"],[layout=column]>[flex-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"40\"],[layout=row]>[flex-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"40\"],[layout=column]>[flex-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"45\"],[layout=row]>[flex-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"45\"],[layout=column]>[flex-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"50\"],[layout=row]>[flex-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"50\"],[layout=column]>[flex-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"55\"],[layout=row]>[flex-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"55\"],[layout=column]>[flex-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"60\"],[layout=row]>[flex-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"60\"],[layout=column]>[flex-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"65\"],[layout=row]>[flex-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"65\"],[layout=column]>[flex-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"70\"],[layout=row]>[flex-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"70\"],[layout=column]>[flex-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"75\"],[layout=row]>[flex-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"75\"],[layout=column]>[flex-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"80\"],[layout=row]>[flex-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"80\"],[layout=column]>[flex-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"85\"],[layout=row]>[flex-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"85\"],[layout=column]>[flex-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"90\"],[layout=row]>[flex-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"90\"],[layout=column]>[flex-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"95\"],[layout=row]>[flex-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"95\"],[layout=column]>[flex-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"100\"],[layout=row]>[flex-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"100\"],[layout=column]>[flex-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"33\"],[layout=row]>[flex-lg=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-lg=row]>[flex-lg=\"66\"],[layout=row]>[flex-lg=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"33\"],[layout=column]>[flex-lg=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-lg=column]>[flex-lg=\"66\"],[layout=column]>[flex-lg=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-lg=row],[layout-lg=column],[layout-lg]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-lg=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-lg=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1920px){[flex-order-gt-lg=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-gt-lg=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-gt-lg=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-gt-lg=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-gt-lg=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-gt-lg=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-gt-lg=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-gt-lg=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-gt-lg=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-gt-lg=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-gt-lg=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-gt-lg=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-gt-lg=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-gt-lg=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-gt-lg=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-gt-lg=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-gt-lg=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-gt-lg=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-gt-lg=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-gt-lg=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-gt-lg=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-gt-lg=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-gt-lg=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-gt-lg=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-gt-lg=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-gt-lg=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-gt-lg=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-gt-lg=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-gt-lg=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-gt-lg=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-gt-lg=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-gt-lg=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-gt-lg=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-gt-lg=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-gt-lg=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-gt-lg=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-gt-lg=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-gt-lg=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-gt-lg=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-gt-lg=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-gt-lg=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-gt-lg=\"0\"]{margin-left:0}[flex-offset-gt-lg=\"5\"]{margin-left:5%}[flex-offset-gt-lg=\"10\"]{margin-left:10%}[flex-offset-gt-lg=\"15\"]{margin-left:15%}[flex-offset-gt-lg=\"20\"]{margin-left:20%}[flex-offset-gt-lg=\"25\"]{margin-left:25%}[flex-offset-gt-lg=\"30\"]{margin-left:30%}[flex-offset-gt-lg=\"35\"]{margin-left:35%}[flex-offset-gt-lg=\"40\"]{margin-left:40%}[flex-offset-gt-lg=\"45\"]{margin-left:45%}[flex-offset-gt-lg=\"50\"]{margin-left:50%}[flex-offset-gt-lg=\"55\"]{margin-left:55%}[flex-offset-gt-lg=\"60\"]{margin-left:60%}[flex-offset-gt-lg=\"65\"]{margin-left:65%}[flex-offset-gt-lg=\"70\"]{margin-left:70%}[flex-offset-gt-lg=\"75\"]{margin-left:75%}[flex-offset-gt-lg=\"80\"]{margin-left:80%}[flex-offset-gt-lg=\"85\"]{margin-left:85%}[flex-offset-gt-lg=\"90\"]{margin-left:90%}[flex-offset-gt-lg=\"95\"]{margin-left:95%}[flex-offset-gt-lg=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-gt-lg=\"66\"]{margin-left:calc(200% / 3)}[layout-align-gt-lg]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-gt-lg=start],[layout-align-gt-lg=\"start start\"],[layout-align-gt-lg=\"start center\"],[layout-align-gt-lg=\"start end\"],[layout-align-gt-lg=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-gt-lg=center],[layout-align-gt-lg=\"center start\"],[layout-align-gt-lg=\"center center\"],[layout-align-gt-lg=\"center end\"],[layout-align-gt-lg=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-gt-lg=end],[layout-align-gt-lg=\"end center\"],[layout-align-gt-lg=\"end start\"],[layout-align-gt-lg=\"end end\"],[layout-align-gt-lg=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-gt-lg=\"space-around end\"],[layout-align-gt-lg=\"space-around stretch\"],[layout-align-gt-lg=space-around],[layout-align-gt-lg=\"space-around center\"],[layout-align-gt-lg=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-gt-lg=space-between],[layout-align-gt-lg=\"space-between center\"],[layout-align-gt-lg=\"space-between start\"],[layout-align-gt-lg=\"space-between end\"],[layout-align-gt-lg=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-gt-lg=\"space-between start\"],[layout-align-gt-lg=\"start start\"],[layout-align-gt-lg=\"center start\"],[layout-align-gt-lg=\"end start\"],[layout-align-gt-lg=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-gt-lg=\"space-between center\"],[layout-align-gt-lg=\"start center\"],[layout-align-gt-lg=\"center center\"],[layout-align-gt-lg=\"end center\"],[layout-align-gt-lg=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-gt-lg=\"space-between center\"]>*,[layout-align-gt-lg=\"start center\"]>*,[layout-align-gt-lg=\"center center\"]>*,[layout-align-gt-lg=\"end center\"]>*,[layout-align-gt-lg=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-gt-lg=\"space-around end\"],[layout-align-gt-lg=\"space-between end\"],[layout-align-gt-lg=\"start end\"],[layout-align-gt-lg=\"center end\"],[layout-align-gt-lg=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-gt-lg=\"space-around stretch\"],[layout-align-gt-lg=\"space-between stretch\"],[layout-align-gt-lg=\"start stretch\"],[layout-align-gt-lg=\"center stretch\"],[layout-align-gt-lg=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-gt-lg]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1920px){[flex-gt-lg]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1920px){[flex-gt-lg-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-gt-lg-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-gt-lg-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-gt-lg-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-gt-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"0\"],[layout=row]>[flex-gt-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"0\"],[layout=column]>[flex-gt-lg=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-gt-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"5\"],[layout=row]>[flex-gt-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"5\"],[layout=column]>[flex-gt-lg=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-gt-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"10\"],[layout=row]>[flex-gt-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"10\"],[layout=column]>[flex-gt-lg=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-gt-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"15\"],[layout=row]>[flex-gt-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"15\"],[layout=column]>[flex-gt-lg=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-gt-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"20\"],[layout=row]>[flex-gt-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"20\"],[layout=column]>[flex-gt-lg=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-gt-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"25\"],[layout=row]>[flex-gt-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"25\"],[layout=column]>[flex-gt-lg=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-gt-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"30\"],[layout=row]>[flex-gt-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"30\"],[layout=column]>[flex-gt-lg=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-gt-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"35\"],[layout=row]>[flex-gt-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"35\"],[layout=column]>[flex-gt-lg=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-gt-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"40\"],[layout=row]>[flex-gt-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"40\"],[layout=column]>[flex-gt-lg=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-gt-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"45\"],[layout=row]>[flex-gt-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"45\"],[layout=column]>[flex-gt-lg=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-gt-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"50\"],[layout=row]>[flex-gt-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"50\"],[layout=column]>[flex-gt-lg=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-gt-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"55\"],[layout=row]>[flex-gt-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"55\"],[layout=column]>[flex-gt-lg=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-gt-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"60\"],[layout=row]>[flex-gt-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"60\"],[layout=column]>[flex-gt-lg=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-gt-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"65\"],[layout=row]>[flex-gt-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"65\"],[layout=column]>[flex-gt-lg=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-gt-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"70\"],[layout=row]>[flex-gt-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"70\"],[layout=column]>[flex-gt-lg=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-gt-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"75\"],[layout=row]>[flex-gt-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"75\"],[layout=column]>[flex-gt-lg=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-gt-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"80\"],[layout=row]>[flex-gt-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"80\"],[layout=column]>[flex-gt-lg=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-gt-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"85\"],[layout=row]>[flex-gt-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"85\"],[layout=column]>[flex-gt-lg=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-gt-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"90\"],[layout=row]>[flex-gt-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"90\"],[layout=column]>[flex-gt-lg=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-gt-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"95\"],[layout=row]>[flex-gt-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"95\"],[layout=column]>[flex-gt-lg=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-gt-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"100\"],[layout=row]>[flex-gt-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"100\"],[layout=column]>[flex-gt-lg=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"33\"],[layout=row]>[flex-gt-lg=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-gt-lg=row]>[flex-gt-lg=\"66\"],[layout=row]>[flex-gt-lg=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"33\"],[layout=column]>[flex-gt-lg=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-gt-lg=column]>[flex-gt-lg=\"66\"],[layout=column]>[flex-gt-lg=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-gt-lg=row],[layout-gt-lg=column],[layout-gt-lg]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-gt-lg=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-gt-lg=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}[flex-order-xl=\"-20\"]{-webkit-order:-20;-ms-flex-order:-20;order:-20}[flex-order-xl=\"-19\"]{-webkit-order:-19;-ms-flex-order:-19;order:-19}[flex-order-xl=\"-18\"]{-webkit-order:-18;-ms-flex-order:-18;order:-18}[flex-order-xl=\"-17\"]{-webkit-order:-17;-ms-flex-order:-17;order:-17}[flex-order-xl=\"-16\"]{-webkit-order:-16;-ms-flex-order:-16;order:-16}[flex-order-xl=\"-15\"]{-webkit-order:-15;-ms-flex-order:-15;order:-15}[flex-order-xl=\"-14\"]{-webkit-order:-14;-ms-flex-order:-14;order:-14}[flex-order-xl=\"-13\"]{-webkit-order:-13;-ms-flex-order:-13;order:-13}[flex-order-xl=\"-12\"]{-webkit-order:-12;-ms-flex-order:-12;order:-12}[flex-order-xl=\"-11\"]{-webkit-order:-11;-ms-flex-order:-11;order:-11}[flex-order-xl=\"-10\"]{-webkit-order:-10;-ms-flex-order:-10;order:-10}[flex-order-xl=\"-9\"]{-webkit-order:-9;-ms-flex-order:-9;order:-9}[flex-order-xl=\"-8\"]{-webkit-order:-8;-ms-flex-order:-8;order:-8}[flex-order-xl=\"-7\"]{-webkit-order:-7;-ms-flex-order:-7;order:-7}[flex-order-xl=\"-6\"]{-webkit-order:-6;-ms-flex-order:-6;order:-6}[flex-order-xl=\"-5\"]{-webkit-order:-5;-ms-flex-order:-5;order:-5}[flex-order-xl=\"-4\"]{-webkit-order:-4;-ms-flex-order:-4;order:-4}[flex-order-xl=\"-3\"]{-webkit-order:-3;-ms-flex-order:-3;order:-3}[flex-order-xl=\"-2\"]{-webkit-order:-2;-ms-flex-order:-2;order:-2}[flex-order-xl=\"-1\"]{-webkit-order:-1;-ms-flex-order:-1;order:-1}[flex-order-xl=\"0\"]{-webkit-order:0;-ms-flex-order:0;order:0}[flex-order-xl=\"1\"]{-webkit-order:1;-ms-flex-order:1;order:1}[flex-order-xl=\"2\"]{-webkit-order:2;-ms-flex-order:2;order:2}[flex-order-xl=\"3\"]{-webkit-order:3;-ms-flex-order:3;order:3}[flex-order-xl=\"4\"]{-webkit-order:4;-ms-flex-order:4;order:4}[flex-order-xl=\"5\"]{-webkit-order:5;-ms-flex-order:5;order:5}[flex-order-xl=\"6\"]{-webkit-order:6;-ms-flex-order:6;order:6}[flex-order-xl=\"7\"]{-webkit-order:7;-ms-flex-order:7;order:7}[flex-order-xl=\"8\"]{-webkit-order:8;-ms-flex-order:8;order:8}[flex-order-xl=\"9\"]{-webkit-order:9;-ms-flex-order:9;order:9}[flex-order-xl=\"10\"]{-webkit-order:10;-ms-flex-order:10;order:10}[flex-order-xl=\"11\"]{-webkit-order:11;-ms-flex-order:11;order:11}[flex-order-xl=\"12\"]{-webkit-order:12;-ms-flex-order:12;order:12}[flex-order-xl=\"13\"]{-webkit-order:13;-ms-flex-order:13;order:13}[flex-order-xl=\"14\"]{-webkit-order:14;-ms-flex-order:14;order:14}[flex-order-xl=\"15\"]{-webkit-order:15;-ms-flex-order:15;order:15}[flex-order-xl=\"16\"]{-webkit-order:16;-ms-flex-order:16;order:16}[flex-order-xl=\"17\"]{-webkit-order:17;-ms-flex-order:17;order:17}[flex-order-xl=\"18\"]{-webkit-order:18;-ms-flex-order:18;order:18}[flex-order-xl=\"19\"]{-webkit-order:19;-ms-flex-order:19;order:19}[flex-order-xl=\"20\"]{-webkit-order:20;-ms-flex-order:20;order:20}[flex-offset-xl=\"0\"]{margin-left:0}[flex-offset-xl=\"5\"]{margin-left:5%}[flex-offset-xl=\"10\"]{margin-left:10%}[flex-offset-xl=\"15\"]{margin-left:15%}[flex-offset-xl=\"20\"]{margin-left:20%}[flex-offset-xl=\"25\"]{margin-left:25%}[flex-offset-xl=\"30\"]{margin-left:30%}[flex-offset-xl=\"35\"]{margin-left:35%}[flex-offset-xl=\"40\"]{margin-left:40%}[flex-offset-xl=\"45\"]{margin-left:45%}[flex-offset-xl=\"50\"]{margin-left:50%}[flex-offset-xl=\"55\"]{margin-left:55%}[flex-offset-xl=\"60\"]{margin-left:60%}[flex-offset-xl=\"65\"]{margin-left:65%}[flex-offset-xl=\"70\"]{margin-left:70%}[flex-offset-xl=\"75\"]{margin-left:75%}[flex-offset-xl=\"80\"]{margin-left:80%}[flex-offset-xl=\"85\"]{margin-left:85%}[flex-offset-xl=\"90\"]{margin-left:90%}[flex-offset-xl=\"95\"]{margin-left:95%}[flex-offset-xl=\"33\"]{margin-left:calc(100% / 3)}[flex-offset-xl=\"66\"]{margin-left:calc(200% / 3)}[layout-align-xl]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}[layout-align-xl=start],[layout-align-xl=\"start start\"],[layout-align-xl=\"start center\"],[layout-align-xl=\"start end\"],[layout-align-xl=\"start stretch\"]{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}[layout-align-xl=center],[layout-align-xl=\"center start\"],[layout-align-xl=\"center center\"],[layout-align-xl=\"center end\"],[layout-align-xl=\"center stretch\"]{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}[layout-align-xl=end],[layout-align-xl=\"end center\"],[layout-align-xl=\"end start\"],[layout-align-xl=\"end end\"],[layout-align-xl=\"end stretch\"]{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}[layout-align-xl=\"space-around end\"],[layout-align-xl=\"space-around stretch\"],[layout-align-xl=space-around],[layout-align-xl=\"space-around center\"],[layout-align-xl=\"space-around start\"]{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}[layout-align-xl=space-between],[layout-align-xl=\"space-between center\"],[layout-align-xl=\"space-between start\"],[layout-align-xl=\"space-between end\"],[layout-align-xl=\"space-between stretch\"]{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}[layout-align-xl=\"space-between start\"],[layout-align-xl=\"start start\"],[layout-align-xl=\"center start\"],[layout-align-xl=\"end start\"],[layout-align-xl=\"space-around start\"]{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}[layout-align-xl=\"space-between center\"],[layout-align-xl=\"start center\"],[layout-align-xl=\"center center\"],[layout-align-xl=\"end center\"],[layout-align-xl=\"space-around center\"]{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}[layout-align-xl=\"space-between center\"]>*,[layout-align-xl=\"start center\"]>*,[layout-align-xl=\"center center\"]>*,[layout-align-xl=\"end center\"]>*,[layout-align-xl=\"space-around center\"]>*{max-width:100%;box-sizing:border-box}[layout-align-xl=\"space-around end\"],[layout-align-xl=\"space-between end\"],[layout-align-xl=\"start end\"],[layout-align-xl=\"center end\"],[layout-align-xl=\"end end\"]{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}[layout-align-xl=\"space-around stretch\"],[layout-align-xl=\"space-between stretch\"],[layout-align-xl=\"start stretch\"],[layout-align-xl=\"center stretch\"],[layout-align-xl=\"end stretch\"]{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}[flex-xl]{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1920px){[flex-xl]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1920px){[flex-xl-grow]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}[flex-xl-initial]{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}[flex-xl-auto]{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}[flex-xl-none]{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}[flex-xl=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"0\"],[layout=row]>[flex-xl=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"0\"],[layout=column]>[flex-xl=\"0\"]{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}[flex-xl=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"5\"],[layout=row]>[flex-xl=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"5\"],[layout=column]>[flex-xl=\"5\"]{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}[flex-xl=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"10\"],[layout=row]>[flex-xl=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"10\"],[layout=column]>[flex-xl=\"10\"]{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}[flex-xl=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"15\"],[layout=row]>[flex-xl=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"15\"],[layout=column]>[flex-xl=\"15\"]{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}[flex-xl=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"20\"],[layout=row]>[flex-xl=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"20\"],[layout=column]>[flex-xl=\"20\"]{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}[flex-xl=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"25\"],[layout=row]>[flex-xl=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"25\"],[layout=column]>[flex-xl=\"25\"]{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}[flex-xl=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"30\"],[layout=row]>[flex-xl=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"30\"],[layout=column]>[flex-xl=\"30\"]{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}[flex-xl=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"35\"],[layout=row]>[flex-xl=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"35\"],[layout=column]>[flex-xl=\"35\"]{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}[flex-xl=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"40\"],[layout=row]>[flex-xl=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"40\"],[layout=column]>[flex-xl=\"40\"]{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}[flex-xl=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"45\"],[layout=row]>[flex-xl=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"45\"],[layout=column]>[flex-xl=\"45\"]{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}[flex-xl=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"50\"],[layout=row]>[flex-xl=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"50\"],[layout=column]>[flex-xl=\"50\"]{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}[flex-xl=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"55\"],[layout=row]>[flex-xl=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"55\"],[layout=column]>[flex-xl=\"55\"]{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}[flex-xl=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"60\"],[layout=row]>[flex-xl=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"60\"],[layout=column]>[flex-xl=\"60\"]{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}[flex-xl=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"65\"],[layout=row]>[flex-xl=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"65\"],[layout=column]>[flex-xl=\"65\"]{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}[flex-xl=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"70\"],[layout=row]>[flex-xl=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"70\"],[layout=column]>[flex-xl=\"70\"]{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}[flex-xl=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"75\"],[layout=row]>[flex-xl=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"75\"],[layout=column]>[flex-xl=\"75\"]{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}[flex-xl=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"80\"],[layout=row]>[flex-xl=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"80\"],[layout=column]>[flex-xl=\"80\"]{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}[flex-xl=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"85\"],[layout=row]>[flex-xl=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"85\"],[layout=column]>[flex-xl=\"85\"]{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}[flex-xl=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"90\"],[layout=row]>[flex-xl=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"90\"],[layout=column]>[flex-xl=\"90\"]{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}[flex-xl=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"95\"],[layout=row]>[flex-xl=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"95\"],[layout=column]>[flex-xl=\"95\"]{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}[flex-xl=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"100\"],[layout=row]>[flex-xl=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"100\"],[layout=column]>[flex-xl=\"100\"]{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"33\"],[layout=row]>[flex-xl=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}[layout-xl=row]>[flex-xl=\"66\"],[layout=row]>[flex-xl=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"33\"],[layout=column]>[flex-xl=\"33\"]{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}[layout-xl=column]>[flex-xl=\"66\"],[layout=column]>[flex-xl=\"66\"]{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}[layout-xl=row],[layout-xl=column],[layout-xl]{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}[layout-xl=column]{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}[layout-xl=row]{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}[hide-gt-lg]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-gt-lg]):not([show-xl]):not([show]),[hide-gt-md]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-gt-lg]):not([show-xl]):not([show]),[hide-gt-sm]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-gt-lg]):not([show-xl]):not([show]),[hide-gt-xs]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-gt-lg]):not([show-xl]):not([show]),[hide]:not([show-gt-xs]):not([show-gt-sm]):not([show-gt-md]):not([show-gt-lg]):not([show-xl]):not([show]){display:none}[hide-xl]:not([show-xl]):not([show-gt-lg]):not([show]){display:none}}@-moz-document url-prefix(){.layout-fill{margin:0;width:100%;min-height:100%;height:100%}}.flex-order{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-0,.offset-0{margin-left:0}.flex-offset-5,.offset-5{margin-left:5%}.flex-offset-10,.offset-10{margin-left:10%}.flex-offset-15,.offset-15{margin-left:15%}.flex-offset-20,.offset-20{margin-left:20%}.flex-offset-25,.offset-25{margin-left:25%}.flex-offset-30,.offset-30{margin-left:30%}.flex-offset-35,.offset-35{margin-left:35%}.flex-offset-40,.offset-40{margin-left:40%}.flex-offset-45,.offset-45{margin-left:45%}.flex-offset-50,.offset-50{margin-left:50%}.flex-offset-55,.offset-55{margin-left:55%}.flex-offset-60,.offset-60{margin-left:60%}.flex-offset-65,.offset-65{margin-left:65%}.flex-offset-70,.offset-70{margin-left:70%}.flex-offset-75,.offset-75{margin-left:75%}.flex-offset-80,.offset-80{margin-left:80%}.flex-offset-85,.offset-85{margin-left:85%}.flex-offset-90,.offset-90{margin-left:90%}.flex-offset-95,.offset-95{margin-left:95%}.flex-offset-33,.offset-33{margin-left:calc(100% / 3)}.flex-offset-66,.offset-66{margin-left:calc(200% / 3)}.layout-align{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-start,.layout-align-start-center,.layout-align-start-end,.layout-align-start-start,.layout-align-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-center,.layout-align-center-center,.layout-align-center-end,.layout-align-center-start,.layout-align-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-end,.layout-align-end-center,.layout-align-end-end,.layout-align-end-start,.layout-align-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-space-around,.layout-align-space-around-center,.layout-align-space-around-end,.layout-align-space-around-start,.layout-align-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-space-between,.layout-align-space-between-center,.layout-align-space-between-end,.layout-align-space-between-start,.layout-align-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-center-start,.layout-align-end-start,.layout-align-space-around-start,.layout-align-space-between-start,.layout-align-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-center-center,.layout-align-end-center,.layout-align-space-around-center,.layout-align-space-between-center,.layout-align-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-center-center>*,.layout-align-end-center>*,.layout-align-space-around-center>*,.layout-align-space-between-center>*,.layout-align-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-center-end,.layout-align-end-end,.layout-align-space-around-end,.layout-align-space-between-end,.layout-align-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-center-stretch,.layout-align-end-stretch,.layout-align-space-around-stretch,.layout-align-space-between-stretch,.layout-align-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}@media screen\\0{.flex{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}.flex-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-row>.flex-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-row>.flex-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-row>.flex-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-row>.flex-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-row>.flex-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-row>.flex-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-row>.flex-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-row>.flex-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-row>.flex-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-row>.flex-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-row>.flex-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-row>.flex-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-row>.flex-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-row>.flex-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-row>.flex-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-row>.flex-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-row>.flex-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-row>.flex-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-row>.flex-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-row>.flex-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-row>.flex-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-row>.flex{min-width:0}.layout-column>.flex-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout,.layout-column,.layout-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.layout-padding-sm>*,.layout-padding>.flex-sm{padding:4px}.layout-padding,.layout-padding-gt-sm,.layout-padding-gt-sm>*,.layout-padding-md,.layout-padding-md>*,.layout-padding>*,.layout-padding>.flex,.layout-padding>.flex-gt-sm,.layout-padding>.flex-md{padding:8px}.layout-padding-gt-lg>*,.layout-padding-gt-md>*,.layout-padding-lg>*,.layout-padding>.flex-gt-lg,.layout-padding>.flex-gt-md,.layout-padding>.flex-lg{padding:16px}.layout-margin-sm>*,.layout-margin>.flex-sm{margin:4px}.layout-margin,.layout-margin-gt-sm,.layout-margin-gt-sm>*,.layout-margin-md,.layout-margin-md>*,.layout-margin>*,.layout-margin>.flex,.layout-margin>.flex-gt-sm,.layout-margin>.flex-md{margin:8px}.layout-margin-gt-lg>*,.layout-margin-gt-md>*,.layout-margin-lg>*,.layout-margin>.flex-gt-lg,.layout-margin>.flex-gt-md,.layout-margin>.flex-lg{margin:16px}.layout-wrap{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.layout-nowrap{-webkit-flex-wrap:nowrap;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.layout-fill{margin:0;width:100%;min-height:100%;height:100%}@media (max-width:599px){.hide-xs:not(.show-xs):not(.show),.hide:not(.show-xs):not(.show){display:none}.flex-order-xs--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-xs--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-xs--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-xs--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-xs--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-xs--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-xs--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-xs--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-xs--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-xs--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-xs--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-xs--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-xs--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-xs--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-xs--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-xs--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-xs--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-xs--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-xs--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-xs--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-xs-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-xs-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-xs-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-xs-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-xs-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-xs-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-xs-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-xs-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-xs-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-xs-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-xs-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-xs-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-xs-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-xs-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-xs-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-xs-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-xs-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-xs-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-xs-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-xs-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-xs-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-xs-0,.offset-xs-0{margin-left:0}.flex-offset-xs-5,.offset-xs-5{margin-left:5%}.flex-offset-xs-10,.offset-xs-10{margin-left:10%}.flex-offset-xs-15,.offset-xs-15{margin-left:15%}.flex-offset-xs-20,.offset-xs-20{margin-left:20%}.flex-offset-xs-25,.offset-xs-25{margin-left:25%}.flex-offset-xs-30,.offset-xs-30{margin-left:30%}.flex-offset-xs-35,.offset-xs-35{margin-left:35%}.flex-offset-xs-40,.offset-xs-40{margin-left:40%}.flex-offset-xs-45,.offset-xs-45{margin-left:45%}.flex-offset-xs-50,.offset-xs-50{margin-left:50%}.flex-offset-xs-55,.offset-xs-55{margin-left:55%}.flex-offset-xs-60,.offset-xs-60{margin-left:60%}.flex-offset-xs-65,.offset-xs-65{margin-left:65%}.flex-offset-xs-70,.offset-xs-70{margin-left:70%}.flex-offset-xs-75,.offset-xs-75{margin-left:75%}.flex-offset-xs-80,.offset-xs-80{margin-left:80%}.flex-offset-xs-85,.offset-xs-85{margin-left:85%}.flex-offset-xs-90,.offset-xs-90{margin-left:90%}.flex-offset-xs-95,.offset-xs-95{margin-left:95%}.flex-offset-xs-33,.offset-xs-33{margin-left:calc(100% / 3)}.flex-offset-xs-66,.offset-xs-66{margin-left:calc(200% / 3)}.layout-align-xs{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-xs-start,.layout-align-xs-start-center,.layout-align-xs-start-end,.layout-align-xs-start-start,.layout-align-xs-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-xs-center,.layout-align-xs-center-center,.layout-align-xs-center-end,.layout-align-xs-center-start,.layout-align-xs-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-xs-end,.layout-align-xs-end-center,.layout-align-xs-end-end,.layout-align-xs-end-start,.layout-align-xs-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-xs-space-around,.layout-align-xs-space-around-center,.layout-align-xs-space-around-end,.layout-align-xs-space-around-start,.layout-align-xs-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-xs-space-between,.layout-align-xs-space-between-center,.layout-align-xs-space-between-end,.layout-align-xs-space-between-start,.layout-align-xs-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-xs-center-start,.layout-align-xs-end-start,.layout-align-xs-space-around-start,.layout-align-xs-space-between-start,.layout-align-xs-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-xs-center-center,.layout-align-xs-end-center,.layout-align-xs-space-around-center,.layout-align-xs-space-between-center,.layout-align-xs-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-xs-center-center>*,.layout-align-xs-end-center>*,.layout-align-xs-space-around-center>*,.layout-align-xs-space-between-center>*,.layout-align-xs-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-xs-center-end,.layout-align-xs-end-end,.layout-align-xs-space-around-end,.layout-align-xs-space-between-end,.layout-align-xs-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-xs-center-stretch,.layout-align-xs-end-stretch,.layout-align-xs-space-around-stretch,.layout-align-xs-space-between-stretch,.layout-align-xs-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-xs{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (max-width:599px){.flex-xs{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (max-width:599px){.flex-xs-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-xs-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-xs-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-xs-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-xs-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-xs-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-0,.layout-xs-row>.flex-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-0,.layout-xs-column>.flex-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-5,.layout-xs-row>.flex-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-5,.layout-xs-column>.flex-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-10,.layout-xs-row>.flex-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-10,.layout-xs-column>.flex-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-15,.layout-xs-row>.flex-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-15,.layout-xs-column>.flex-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-20,.layout-xs-row>.flex-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-20,.layout-xs-column>.flex-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-25,.layout-xs-row>.flex-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-25,.layout-xs-column>.flex-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-30,.layout-xs-row>.flex-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-30,.layout-xs-column>.flex-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-35,.layout-xs-row>.flex-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-35,.layout-xs-column>.flex-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-40,.layout-xs-row>.flex-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-40,.layout-xs-column>.flex-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-45,.layout-xs-row>.flex-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-45,.layout-xs-column>.flex-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-50,.layout-xs-row>.flex-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-50,.layout-xs-column>.flex-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-55,.layout-xs-row>.flex-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-55,.layout-xs-column>.flex-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-60,.layout-xs-row>.flex-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-60,.layout-xs-column>.flex-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-65,.layout-xs-row>.flex-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-65,.layout-xs-column>.flex-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-70,.layout-xs-row>.flex-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-70,.layout-xs-column>.flex-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-75,.layout-xs-row>.flex-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-75,.layout-xs-column>.flex-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-80,.layout-xs-row>.flex-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-80,.layout-xs-column>.flex-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-85,.layout-xs-row>.flex-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-85,.layout-xs-column>.flex-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-90,.layout-xs-row>.flex-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-90,.layout-xs-column>.flex-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-95,.layout-xs-row>.flex-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-95,.layout-xs-column>.flex-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-100,.layout-xs-row>.flex-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xs-100,.layout-xs-column>.flex-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-33,.layout-xs-row>.flex-xs-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xs-66,.layout-xs-row>.flex-xs-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-row>.flex,.layout-xs-row>.flex{min-width:0}.layout-column>.flex-xs-33,.layout-xs-column>.flex-xs-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-xs-66,.layout-xs-column>.flex-xs-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-xs,.layout-xs-column,.layout-xs-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-xs-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-xs-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:600px){.flex-order-gt-xs--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-gt-xs--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-gt-xs--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-gt-xs--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-gt-xs--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-gt-xs--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-gt-xs--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-gt-xs--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-gt-xs--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-gt-xs--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-gt-xs--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-gt-xs--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-gt-xs--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-gt-xs--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-gt-xs--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-gt-xs--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-gt-xs--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-gt-xs--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-gt-xs--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-gt-xs--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-gt-xs-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-gt-xs-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-gt-xs-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-gt-xs-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-gt-xs-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-gt-xs-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-gt-xs-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-gt-xs-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-gt-xs-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-gt-xs-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-gt-xs-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-gt-xs-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-gt-xs-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-gt-xs-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-gt-xs-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-gt-xs-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-gt-xs-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-gt-xs-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-gt-xs-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-gt-xs-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-gt-xs-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-gt-xs-0,.offset-gt-xs-0{margin-left:0}.flex-offset-gt-xs-5,.offset-gt-xs-5{margin-left:5%}.flex-offset-gt-xs-10,.offset-gt-xs-10{margin-left:10%}.flex-offset-gt-xs-15,.offset-gt-xs-15{margin-left:15%}.flex-offset-gt-xs-20,.offset-gt-xs-20{margin-left:20%}.flex-offset-gt-xs-25,.offset-gt-xs-25{margin-left:25%}.flex-offset-gt-xs-30,.offset-gt-xs-30{margin-left:30%}.flex-offset-gt-xs-35,.offset-gt-xs-35{margin-left:35%}.flex-offset-gt-xs-40,.offset-gt-xs-40{margin-left:40%}.flex-offset-gt-xs-45,.offset-gt-xs-45{margin-left:45%}.flex-offset-gt-xs-50,.offset-gt-xs-50{margin-left:50%}.flex-offset-gt-xs-55,.offset-gt-xs-55{margin-left:55%}.flex-offset-gt-xs-60,.offset-gt-xs-60{margin-left:60%}.flex-offset-gt-xs-65,.offset-gt-xs-65{margin-left:65%}.flex-offset-gt-xs-70,.offset-gt-xs-70{margin-left:70%}.flex-offset-gt-xs-75,.offset-gt-xs-75{margin-left:75%}.flex-offset-gt-xs-80,.offset-gt-xs-80{margin-left:80%}.flex-offset-gt-xs-85,.offset-gt-xs-85{margin-left:85%}.flex-offset-gt-xs-90,.offset-gt-xs-90{margin-left:90%}.flex-offset-gt-xs-95,.offset-gt-xs-95{margin-left:95%}.flex-offset-gt-xs-33,.offset-gt-xs-33{margin-left:calc(100% / 3)}.flex-offset-gt-xs-66,.offset-gt-xs-66{margin-left:calc(200% / 3)}.layout-align-gt-xs{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-gt-xs-start,.layout-align-gt-xs-start-center,.layout-align-gt-xs-start-end,.layout-align-gt-xs-start-start,.layout-align-gt-xs-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-gt-xs-center,.layout-align-gt-xs-center-center,.layout-align-gt-xs-center-end,.layout-align-gt-xs-center-start,.layout-align-gt-xs-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-gt-xs-end,.layout-align-gt-xs-end-center,.layout-align-gt-xs-end-end,.layout-align-gt-xs-end-start,.layout-align-gt-xs-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-gt-xs-space-around,.layout-align-gt-xs-space-around-center,.layout-align-gt-xs-space-around-end,.layout-align-gt-xs-space-around-start,.layout-align-gt-xs-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-gt-xs-space-between,.layout-align-gt-xs-space-between-center,.layout-align-gt-xs-space-between-end,.layout-align-gt-xs-space-between-start,.layout-align-gt-xs-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-gt-xs-center-start,.layout-align-gt-xs-end-start,.layout-align-gt-xs-space-around-start,.layout-align-gt-xs-space-between-start,.layout-align-gt-xs-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-gt-xs-center-center,.layout-align-gt-xs-end-center,.layout-align-gt-xs-space-around-center,.layout-align-gt-xs-space-between-center,.layout-align-gt-xs-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-gt-xs-center-center>*,.layout-align-gt-xs-end-center>*,.layout-align-gt-xs-space-around-center>*,.layout-align-gt-xs-space-between-center>*,.layout-align-gt-xs-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-gt-xs-center-end,.layout-align-gt-xs-end-end,.layout-align-gt-xs-space-around-end,.layout-align-gt-xs-space-between-end,.layout-align-gt-xs-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-gt-xs-center-stretch,.layout-align-gt-xs-end-stretch,.layout-align-gt-xs-space-around-stretch,.layout-align-gt-xs-space-between-stretch,.layout-align-gt-xs-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-gt-xs{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:600px){.flex-gt-xs{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:600px){.flex-gt-xs-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-gt-xs-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-xs-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-gt-xs-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-gt-xs-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-gt-xs-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-0,.layout-row>.flex-gt-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-0,.layout-gt-xs-column>.flex-gt-xs-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-gt-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-5,.layout-row>.flex-gt-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-5,.layout-gt-xs-column>.flex-gt-xs-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-gt-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-10,.layout-row>.flex-gt-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-10,.layout-gt-xs-column>.flex-gt-xs-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-gt-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-15,.layout-row>.flex-gt-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-15,.layout-gt-xs-column>.flex-gt-xs-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-gt-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-20,.layout-row>.flex-gt-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-20,.layout-gt-xs-column>.flex-gt-xs-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-gt-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-25,.layout-row>.flex-gt-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-25,.layout-gt-xs-column>.flex-gt-xs-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-gt-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-30,.layout-row>.flex-gt-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-30,.layout-gt-xs-column>.flex-gt-xs-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-gt-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-35,.layout-row>.flex-gt-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-35,.layout-gt-xs-column>.flex-gt-xs-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-gt-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-40,.layout-row>.flex-gt-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-40,.layout-gt-xs-column>.flex-gt-xs-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-gt-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-45,.layout-row>.flex-gt-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-45,.layout-gt-xs-column>.flex-gt-xs-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-gt-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-50,.layout-row>.flex-gt-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-50,.layout-gt-xs-column>.flex-gt-xs-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-gt-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-55,.layout-row>.flex-gt-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-55,.layout-gt-xs-column>.flex-gt-xs-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-gt-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-60,.layout-row>.flex-gt-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-60,.layout-gt-xs-column>.flex-gt-xs-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-gt-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-65,.layout-row>.flex-gt-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-65,.layout-gt-xs-column>.flex-gt-xs-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-gt-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-70,.layout-row>.flex-gt-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-70,.layout-gt-xs-column>.flex-gt-xs-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-gt-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-75,.layout-row>.flex-gt-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-75,.layout-gt-xs-column>.flex-gt-xs-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-gt-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-80,.layout-row>.flex-gt-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-80,.layout-gt-xs-column>.flex-gt-xs-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-gt-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-85,.layout-row>.flex-gt-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-85,.layout-gt-xs-column>.flex-gt-xs-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-gt-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-90,.layout-row>.flex-gt-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-90,.layout-gt-xs-column>.flex-gt-xs-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-gt-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-95,.layout-row>.flex-gt-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-95,.layout-gt-xs-column>.flex-gt-xs-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-gt-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-100,.layout-row>.flex-gt-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-xs-100,.layout-gt-xs-column>.flex-gt-xs-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-33,.layout-row>.flex-gt-xs-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex-gt-xs-66,.layout-row>.flex-gt-xs-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-gt-xs-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-gt-xs-33,.layout-gt-xs-column>.flex-gt-xs-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-gt-xs-66,.layout-gt-xs-column>.flex-gt-xs-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-gt-xs,.layout-gt-xs-column,.layout-gt-xs-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-gt-xs-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-gt-xs-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:600px) and (max-width:959px){.hide-gt-xs:not(.show-gt-xs):not(.show-sm):not(.show),.hide:not(.show-gt-xs):not(.show-sm):not(.show){display:none}.hide-sm:not(.show-gt-xs):not(.show-sm):not(.show){display:none}.flex-order-sm--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-sm--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-sm--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-sm--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-sm--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-sm--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-sm--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-sm--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-sm--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-sm--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-sm--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-sm--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-sm--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-sm--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-sm--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-sm--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-sm--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-sm--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-sm--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-sm--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-sm-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-sm-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-sm-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-sm-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-sm-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-sm-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-sm-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-sm-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-sm-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-sm-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-sm-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-sm-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-sm-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-sm-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-sm-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-sm-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-sm-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-sm-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-sm-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-sm-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-sm-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-sm-0,.offset-sm-0{margin-left:0}.flex-offset-sm-5,.offset-sm-5{margin-left:5%}.flex-offset-sm-10,.offset-sm-10{margin-left:10%}.flex-offset-sm-15,.offset-sm-15{margin-left:15%}.flex-offset-sm-20,.offset-sm-20{margin-left:20%}.flex-offset-sm-25,.offset-sm-25{margin-left:25%}.flex-offset-sm-30,.offset-sm-30{margin-left:30%}.flex-offset-sm-35,.offset-sm-35{margin-left:35%}.flex-offset-sm-40,.offset-sm-40{margin-left:40%}.flex-offset-sm-45,.offset-sm-45{margin-left:45%}.flex-offset-sm-50,.offset-sm-50{margin-left:50%}.flex-offset-sm-55,.offset-sm-55{margin-left:55%}.flex-offset-sm-60,.offset-sm-60{margin-left:60%}.flex-offset-sm-65,.offset-sm-65{margin-left:65%}.flex-offset-sm-70,.offset-sm-70{margin-left:70%}.flex-offset-sm-75,.offset-sm-75{margin-left:75%}.flex-offset-sm-80,.offset-sm-80{margin-left:80%}.flex-offset-sm-85,.offset-sm-85{margin-left:85%}.flex-offset-sm-90,.offset-sm-90{margin-left:90%}.flex-offset-sm-95,.offset-sm-95{margin-left:95%}.flex-offset-sm-33,.offset-sm-33{margin-left:calc(100% / 3)}.flex-offset-sm-66,.offset-sm-66{margin-left:calc(200% / 3)}.layout-align-sm{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-sm-start,.layout-align-sm-start-center,.layout-align-sm-start-end,.layout-align-sm-start-start,.layout-align-sm-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-sm-center,.layout-align-sm-center-center,.layout-align-sm-center-end,.layout-align-sm-center-start,.layout-align-sm-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-sm-end,.layout-align-sm-end-center,.layout-align-sm-end-end,.layout-align-sm-end-start,.layout-align-sm-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-sm-space-around,.layout-align-sm-space-around-center,.layout-align-sm-space-around-end,.layout-align-sm-space-around-start,.layout-align-sm-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-sm-space-between,.layout-align-sm-space-between-center,.layout-align-sm-space-between-end,.layout-align-sm-space-between-start,.layout-align-sm-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-sm-center-start,.layout-align-sm-end-start,.layout-align-sm-space-around-start,.layout-align-sm-space-between-start,.layout-align-sm-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-sm-center-center,.layout-align-sm-end-center,.layout-align-sm-space-around-center,.layout-align-sm-space-between-center,.layout-align-sm-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-sm-center-center>*,.layout-align-sm-end-center>*,.layout-align-sm-space-around-center>*,.layout-align-sm-space-between-center>*,.layout-align-sm-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-sm-center-end,.layout-align-sm-end-end,.layout-align-sm-space-around-end,.layout-align-sm-space-between-end,.layout-align-sm-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-sm-center-stretch,.layout-align-sm-end-stretch,.layout-align-sm-space-around-stretch,.layout-align-sm-space-between-stretch,.layout-align-sm-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-sm{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:600px) and (max-width:959px){.flex-sm{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:600px) and (max-width:959px){.flex-sm-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-sm-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-sm-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-sm-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-sm-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-sm-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-0,.layout-sm-row>.flex-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-0,.layout-sm-column>.flex-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-5,.layout-sm-row>.flex-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-5,.layout-sm-column>.flex-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-10,.layout-sm-row>.flex-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-10,.layout-sm-column>.flex-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-15,.layout-sm-row>.flex-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-15,.layout-sm-column>.flex-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-20,.layout-sm-row>.flex-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-20,.layout-sm-column>.flex-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-25,.layout-sm-row>.flex-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-25,.layout-sm-column>.flex-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-30,.layout-sm-row>.flex-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-30,.layout-sm-column>.flex-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-35,.layout-sm-row>.flex-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-35,.layout-sm-column>.flex-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-40,.layout-sm-row>.flex-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-40,.layout-sm-column>.flex-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-45,.layout-sm-row>.flex-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-45,.layout-sm-column>.flex-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-50,.layout-sm-row>.flex-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-50,.layout-sm-column>.flex-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-55,.layout-sm-row>.flex-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-55,.layout-sm-column>.flex-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-60,.layout-sm-row>.flex-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-60,.layout-sm-column>.flex-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-65,.layout-sm-row>.flex-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-65,.layout-sm-column>.flex-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-70,.layout-sm-row>.flex-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-70,.layout-sm-column>.flex-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-75,.layout-sm-row>.flex-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-75,.layout-sm-column>.flex-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-80,.layout-sm-row>.flex-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-80,.layout-sm-column>.flex-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-85,.layout-sm-row>.flex-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-85,.layout-sm-column>.flex-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-90,.layout-sm-row>.flex-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-90,.layout-sm-column>.flex-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-95,.layout-sm-row>.flex-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-95,.layout-sm-column>.flex-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-100,.layout-sm-row>.flex-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-sm-100,.layout-sm-column>.flex-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-33,.layout-sm-row>.flex-sm-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-row>.flex-sm-66,.layout-sm-row>.flex-sm-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-row>.flex,.layout-sm-row>.flex{min-width:0}.layout-column>.flex-sm-33,.layout-sm-column>.flex-sm-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-sm-66,.layout-sm-column>.flex-sm-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-sm,.layout-sm-column,.layout-sm-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-sm-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-sm-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:960px){.flex-order-gt-sm--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-gt-sm--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-gt-sm--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-gt-sm--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-gt-sm--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-gt-sm--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-gt-sm--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-gt-sm--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-gt-sm--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-gt-sm--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-gt-sm--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-gt-sm--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-gt-sm--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-gt-sm--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-gt-sm--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-gt-sm--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-gt-sm--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-gt-sm--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-gt-sm--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-gt-sm--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-gt-sm-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-gt-sm-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-gt-sm-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-gt-sm-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-gt-sm-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-gt-sm-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-gt-sm-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-gt-sm-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-gt-sm-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-gt-sm-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-gt-sm-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-gt-sm-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-gt-sm-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-gt-sm-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-gt-sm-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-gt-sm-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-gt-sm-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-gt-sm-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-gt-sm-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-gt-sm-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-gt-sm-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-gt-sm-0,.offset-gt-sm-0{margin-left:0}.flex-offset-gt-sm-5,.offset-gt-sm-5{margin-left:5%}.flex-offset-gt-sm-10,.offset-gt-sm-10{margin-left:10%}.flex-offset-gt-sm-15,.offset-gt-sm-15{margin-left:15%}.flex-offset-gt-sm-20,.offset-gt-sm-20{margin-left:20%}.flex-offset-gt-sm-25,.offset-gt-sm-25{margin-left:25%}.flex-offset-gt-sm-30,.offset-gt-sm-30{margin-left:30%}.flex-offset-gt-sm-35,.offset-gt-sm-35{margin-left:35%}.flex-offset-gt-sm-40,.offset-gt-sm-40{margin-left:40%}.flex-offset-gt-sm-45,.offset-gt-sm-45{margin-left:45%}.flex-offset-gt-sm-50,.offset-gt-sm-50{margin-left:50%}.flex-offset-gt-sm-55,.offset-gt-sm-55{margin-left:55%}.flex-offset-gt-sm-60,.offset-gt-sm-60{margin-left:60%}.flex-offset-gt-sm-65,.offset-gt-sm-65{margin-left:65%}.flex-offset-gt-sm-70,.offset-gt-sm-70{margin-left:70%}.flex-offset-gt-sm-75,.offset-gt-sm-75{margin-left:75%}.flex-offset-gt-sm-80,.offset-gt-sm-80{margin-left:80%}.flex-offset-gt-sm-85,.offset-gt-sm-85{margin-left:85%}.flex-offset-gt-sm-90,.offset-gt-sm-90{margin-left:90%}.flex-offset-gt-sm-95,.offset-gt-sm-95{margin-left:95%}.flex-offset-gt-sm-33,.offset-gt-sm-33{margin-left:calc(100% / 3)}.flex-offset-gt-sm-66,.offset-gt-sm-66{margin-left:calc(200% / 3)}.layout-align-gt-sm{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-gt-sm-start,.layout-align-gt-sm-start-center,.layout-align-gt-sm-start-end,.layout-align-gt-sm-start-start,.layout-align-gt-sm-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-gt-sm-center,.layout-align-gt-sm-center-center,.layout-align-gt-sm-center-end,.layout-align-gt-sm-center-start,.layout-align-gt-sm-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-gt-sm-end,.layout-align-gt-sm-end-center,.layout-align-gt-sm-end-end,.layout-align-gt-sm-end-start,.layout-align-gt-sm-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-gt-sm-space-around,.layout-align-gt-sm-space-around-center,.layout-align-gt-sm-space-around-end,.layout-align-gt-sm-space-around-start,.layout-align-gt-sm-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-gt-sm-space-between,.layout-align-gt-sm-space-between-center,.layout-align-gt-sm-space-between-end,.layout-align-gt-sm-space-between-start,.layout-align-gt-sm-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-gt-sm-center-start,.layout-align-gt-sm-end-start,.layout-align-gt-sm-space-around-start,.layout-align-gt-sm-space-between-start,.layout-align-gt-sm-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-gt-sm-center-center,.layout-align-gt-sm-end-center,.layout-align-gt-sm-space-around-center,.layout-align-gt-sm-space-between-center,.layout-align-gt-sm-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-gt-sm-center-center>*,.layout-align-gt-sm-end-center>*,.layout-align-gt-sm-space-around-center>*,.layout-align-gt-sm-space-between-center>*,.layout-align-gt-sm-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-gt-sm-center-end,.layout-align-gt-sm-end-end,.layout-align-gt-sm-space-around-end,.layout-align-gt-sm-space-between-end,.layout-align-gt-sm-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-gt-sm-center-stretch,.layout-align-gt-sm-end-stretch,.layout-align-gt-sm-space-around-stretch,.layout-align-gt-sm-space-between-stretch,.layout-align-gt-sm-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-gt-sm{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:960px){.flex-gt-sm{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:960px){.flex-gt-sm-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-gt-sm-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-sm-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-gt-sm-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-gt-sm-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-gt-sm-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-0,.layout-row>.flex-gt-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-0,.layout-gt-sm-column>.flex-gt-sm-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-gt-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-5,.layout-row>.flex-gt-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-5,.layout-gt-sm-column>.flex-gt-sm-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-gt-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-10,.layout-row>.flex-gt-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-10,.layout-gt-sm-column>.flex-gt-sm-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-gt-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-15,.layout-row>.flex-gt-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-15,.layout-gt-sm-column>.flex-gt-sm-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-gt-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-20,.layout-row>.flex-gt-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-20,.layout-gt-sm-column>.flex-gt-sm-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-gt-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-25,.layout-row>.flex-gt-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-25,.layout-gt-sm-column>.flex-gt-sm-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-gt-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-30,.layout-row>.flex-gt-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-30,.layout-gt-sm-column>.flex-gt-sm-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-gt-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-35,.layout-row>.flex-gt-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-35,.layout-gt-sm-column>.flex-gt-sm-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-gt-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-40,.layout-row>.flex-gt-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-40,.layout-gt-sm-column>.flex-gt-sm-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-gt-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-45,.layout-row>.flex-gt-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-45,.layout-gt-sm-column>.flex-gt-sm-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-gt-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-50,.layout-row>.flex-gt-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-50,.layout-gt-sm-column>.flex-gt-sm-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-gt-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-55,.layout-row>.flex-gt-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-55,.layout-gt-sm-column>.flex-gt-sm-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-gt-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-60,.layout-row>.flex-gt-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-60,.layout-gt-sm-column>.flex-gt-sm-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-gt-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-65,.layout-row>.flex-gt-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-65,.layout-gt-sm-column>.flex-gt-sm-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-gt-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-70,.layout-row>.flex-gt-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-70,.layout-gt-sm-column>.flex-gt-sm-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-gt-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-75,.layout-row>.flex-gt-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-75,.layout-gt-sm-column>.flex-gt-sm-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-gt-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-80,.layout-row>.flex-gt-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-80,.layout-gt-sm-column>.flex-gt-sm-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-gt-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-85,.layout-row>.flex-gt-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-85,.layout-gt-sm-column>.flex-gt-sm-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-gt-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-90,.layout-row>.flex-gt-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-90,.layout-gt-sm-column>.flex-gt-sm-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-gt-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-95,.layout-row>.flex-gt-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-95,.layout-gt-sm-column>.flex-gt-sm-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-gt-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-100,.layout-row>.flex-gt-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-sm-100,.layout-gt-sm-column>.flex-gt-sm-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-33,.layout-row>.flex-gt-sm-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex-gt-sm-66,.layout-row>.flex-gt-sm-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-gt-sm-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-gt-sm-33,.layout-gt-sm-column>.flex-gt-sm-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-gt-sm-66,.layout-gt-sm-column>.flex-gt-sm-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-gt-sm,.layout-gt-sm-column,.layout-gt-sm-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-gt-sm-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-gt-sm-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:960px) and (max-width:1279px){.hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show),.hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show),.hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show){display:none}.hide-md:not(.show-md):not(.show-gt-sm):not(.show-gt-xs):not(.show){display:none}.flex-order-md--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-md--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-md--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-md--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-md--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-md--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-md--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-md--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-md--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-md--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-md--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-md--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-md--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-md--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-md--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-md--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-md--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-md--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-md--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-md--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-md-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-md-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-md-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-md-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-md-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-md-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-md-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-md-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-md-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-md-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-md-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-md-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-md-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-md-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-md-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-md-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-md-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-md-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-md-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-md-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-md-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-md-0,.offset-md-0{margin-left:0}.flex-offset-md-5,.offset-md-5{margin-left:5%}.flex-offset-md-10,.offset-md-10{margin-left:10%}.flex-offset-md-15,.offset-md-15{margin-left:15%}.flex-offset-md-20,.offset-md-20{margin-left:20%}.flex-offset-md-25,.offset-md-25{margin-left:25%}.flex-offset-md-30,.offset-md-30{margin-left:30%}.flex-offset-md-35,.offset-md-35{margin-left:35%}.flex-offset-md-40,.offset-md-40{margin-left:40%}.flex-offset-md-45,.offset-md-45{margin-left:45%}.flex-offset-md-50,.offset-md-50{margin-left:50%}.flex-offset-md-55,.offset-md-55{margin-left:55%}.flex-offset-md-60,.offset-md-60{margin-left:60%}.flex-offset-md-65,.offset-md-65{margin-left:65%}.flex-offset-md-70,.offset-md-70{margin-left:70%}.flex-offset-md-75,.offset-md-75{margin-left:75%}.flex-offset-md-80,.offset-md-80{margin-left:80%}.flex-offset-md-85,.offset-md-85{margin-left:85%}.flex-offset-md-90,.offset-md-90{margin-left:90%}.flex-offset-md-95,.offset-md-95{margin-left:95%}.flex-offset-md-33,.offset-md-33{margin-left:calc(100% / 3)}.flex-offset-md-66,.offset-md-66{margin-left:calc(200% / 3)}.layout-align-md{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-md-start,.layout-align-md-start-center,.layout-align-md-start-end,.layout-align-md-start-start,.layout-align-md-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-md-center,.layout-align-md-center-center,.layout-align-md-center-end,.layout-align-md-center-start,.layout-align-md-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-md-end,.layout-align-md-end-center,.layout-align-md-end-end,.layout-align-md-end-start,.layout-align-md-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-md-space-around,.layout-align-md-space-around-center,.layout-align-md-space-around-end,.layout-align-md-space-around-start,.layout-align-md-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-md-space-between,.layout-align-md-space-between-center,.layout-align-md-space-between-end,.layout-align-md-space-between-start,.layout-align-md-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-md-center-start,.layout-align-md-end-start,.layout-align-md-space-around-start,.layout-align-md-space-between-start,.layout-align-md-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-md-center-center,.layout-align-md-end-center,.layout-align-md-space-around-center,.layout-align-md-space-between-center,.layout-align-md-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-md-center-center>*,.layout-align-md-end-center>*,.layout-align-md-space-around-center>*,.layout-align-md-space-between-center>*,.layout-align-md-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-md-center-end,.layout-align-md-end-end,.layout-align-md-space-around-end,.layout-align-md-space-between-end,.layout-align-md-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-md-center-stretch,.layout-align-md-end-stretch,.layout-align-md-space-around-stretch,.layout-align-md-space-between-stretch,.layout-align-md-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-md{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:960px) and (max-width:1279px){.flex-md{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:960px) and (max-width:1279px){.flex-md-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-md-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-md-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-md-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-md-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-md-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-0,.layout-row>.flex-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-0,.layout-md-column>.flex-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-5,.layout-row>.flex-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-5,.layout-md-column>.flex-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-10,.layout-row>.flex-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-10,.layout-md-column>.flex-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-15,.layout-row>.flex-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-15,.layout-md-column>.flex-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-20,.layout-row>.flex-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-20,.layout-md-column>.flex-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-25,.layout-row>.flex-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-25,.layout-md-column>.flex-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-30,.layout-row>.flex-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-30,.layout-md-column>.flex-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-35,.layout-row>.flex-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-35,.layout-md-column>.flex-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-40,.layout-row>.flex-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-40,.layout-md-column>.flex-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-45,.layout-row>.flex-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-45,.layout-md-column>.flex-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-50,.layout-row>.flex-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-50,.layout-md-column>.flex-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-55,.layout-row>.flex-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-55,.layout-md-column>.flex-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-60,.layout-row>.flex-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-60,.layout-md-column>.flex-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-65,.layout-row>.flex-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-65,.layout-md-column>.flex-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-70,.layout-row>.flex-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-70,.layout-md-column>.flex-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-75,.layout-row>.flex-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-75,.layout-md-column>.flex-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-80,.layout-row>.flex-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-80,.layout-md-column>.flex-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-85,.layout-row>.flex-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-85,.layout-md-column>.flex-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-90,.layout-row>.flex-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-90,.layout-md-column>.flex-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-95,.layout-row>.flex-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-95,.layout-md-column>.flex-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-100,.layout-row>.flex-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-md-100,.layout-md-column>.flex-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-33,.layout-row>.flex-md-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex-md-66,.layout-row>.flex-md-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-md-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-md-33,.layout-md-column>.flex-md-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-md-66,.layout-md-column>.flex-md-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-md,.layout-md-column,.layout-md-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-md-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-md-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1280px){.flex-order-gt-md--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-gt-md--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-gt-md--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-gt-md--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-gt-md--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-gt-md--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-gt-md--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-gt-md--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-gt-md--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-gt-md--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-gt-md--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-gt-md--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-gt-md--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-gt-md--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-gt-md--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-gt-md--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-gt-md--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-gt-md--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-gt-md--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-gt-md--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-gt-md-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-gt-md-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-gt-md-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-gt-md-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-gt-md-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-gt-md-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-gt-md-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-gt-md-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-gt-md-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-gt-md-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-gt-md-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-gt-md-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-gt-md-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-gt-md-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-gt-md-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-gt-md-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-gt-md-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-gt-md-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-gt-md-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-gt-md-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-gt-md-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-gt-md-0,.offset-gt-md-0{margin-left:0}.flex-offset-gt-md-5,.offset-gt-md-5{margin-left:5%}.flex-offset-gt-md-10,.offset-gt-md-10{margin-left:10%}.flex-offset-gt-md-15,.offset-gt-md-15{margin-left:15%}.flex-offset-gt-md-20,.offset-gt-md-20{margin-left:20%}.flex-offset-gt-md-25,.offset-gt-md-25{margin-left:25%}.flex-offset-gt-md-30,.offset-gt-md-30{margin-left:30%}.flex-offset-gt-md-35,.offset-gt-md-35{margin-left:35%}.flex-offset-gt-md-40,.offset-gt-md-40{margin-left:40%}.flex-offset-gt-md-45,.offset-gt-md-45{margin-left:45%}.flex-offset-gt-md-50,.offset-gt-md-50{margin-left:50%}.flex-offset-gt-md-55,.offset-gt-md-55{margin-left:55%}.flex-offset-gt-md-60,.offset-gt-md-60{margin-left:60%}.flex-offset-gt-md-65,.offset-gt-md-65{margin-left:65%}.flex-offset-gt-md-70,.offset-gt-md-70{margin-left:70%}.flex-offset-gt-md-75,.offset-gt-md-75{margin-left:75%}.flex-offset-gt-md-80,.offset-gt-md-80{margin-left:80%}.flex-offset-gt-md-85,.offset-gt-md-85{margin-left:85%}.flex-offset-gt-md-90,.offset-gt-md-90{margin-left:90%}.flex-offset-gt-md-95,.offset-gt-md-95{margin-left:95%}.flex-offset-gt-md-33,.offset-gt-md-33{margin-left:calc(100% / 3)}.flex-offset-gt-md-66,.offset-gt-md-66{margin-left:calc(200% / 3)}.layout-align-gt-md{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-gt-md-start,.layout-align-gt-md-start-center,.layout-align-gt-md-start-end,.layout-align-gt-md-start-start,.layout-align-gt-md-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-gt-md-center,.layout-align-gt-md-center-center,.layout-align-gt-md-center-end,.layout-align-gt-md-center-start,.layout-align-gt-md-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-gt-md-end,.layout-align-gt-md-end-center,.layout-align-gt-md-end-end,.layout-align-gt-md-end-start,.layout-align-gt-md-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-gt-md-space-around,.layout-align-gt-md-space-around-center,.layout-align-gt-md-space-around-end,.layout-align-gt-md-space-around-start,.layout-align-gt-md-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-gt-md-space-between,.layout-align-gt-md-space-between-center,.layout-align-gt-md-space-between-end,.layout-align-gt-md-space-between-start,.layout-align-gt-md-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-gt-md-center-start,.layout-align-gt-md-end-start,.layout-align-gt-md-space-around-start,.layout-align-gt-md-space-between-start,.layout-align-gt-md-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-gt-md-center-center,.layout-align-gt-md-end-center,.layout-align-gt-md-space-around-center,.layout-align-gt-md-space-between-center,.layout-align-gt-md-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-gt-md-center-center>*,.layout-align-gt-md-end-center>*,.layout-align-gt-md-space-around-center>*,.layout-align-gt-md-space-between-center>*,.layout-align-gt-md-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-gt-md-center-end,.layout-align-gt-md-end-end,.layout-align-gt-md-space-around-end,.layout-align-gt-md-space-between-end,.layout-align-gt-md-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-gt-md-center-stretch,.layout-align-gt-md-end-stretch,.layout-align-gt-md-space-around-stretch,.layout-align-gt-md-space-between-stretch,.layout-align-gt-md-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-gt-md{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1280px){.flex-gt-md{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1280px){.flex-gt-md-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-gt-md-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-md-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-gt-md-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-gt-md-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-gt-md-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-0,.layout-row>.flex-gt-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-0,.layout-gt-md-column>.flex-gt-md-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-gt-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-5,.layout-row>.flex-gt-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-5,.layout-gt-md-column>.flex-gt-md-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-gt-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-10,.layout-row>.flex-gt-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-10,.layout-gt-md-column>.flex-gt-md-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-gt-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-15,.layout-row>.flex-gt-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-15,.layout-gt-md-column>.flex-gt-md-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-gt-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-20,.layout-row>.flex-gt-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-20,.layout-gt-md-column>.flex-gt-md-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-gt-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-25,.layout-row>.flex-gt-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-25,.layout-gt-md-column>.flex-gt-md-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-gt-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-30,.layout-row>.flex-gt-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-30,.layout-gt-md-column>.flex-gt-md-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-gt-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-35,.layout-row>.flex-gt-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-35,.layout-gt-md-column>.flex-gt-md-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-gt-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-40,.layout-row>.flex-gt-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-40,.layout-gt-md-column>.flex-gt-md-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-gt-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-45,.layout-row>.flex-gt-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-45,.layout-gt-md-column>.flex-gt-md-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-gt-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-50,.layout-row>.flex-gt-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-50,.layout-gt-md-column>.flex-gt-md-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-gt-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-55,.layout-row>.flex-gt-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-55,.layout-gt-md-column>.flex-gt-md-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-gt-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-60,.layout-row>.flex-gt-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-60,.layout-gt-md-column>.flex-gt-md-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-gt-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-65,.layout-row>.flex-gt-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-65,.layout-gt-md-column>.flex-gt-md-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-gt-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-70,.layout-row>.flex-gt-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-70,.layout-gt-md-column>.flex-gt-md-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-gt-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-75,.layout-row>.flex-gt-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-75,.layout-gt-md-column>.flex-gt-md-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-gt-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-80,.layout-row>.flex-gt-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-80,.layout-gt-md-column>.flex-gt-md-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-gt-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-85,.layout-row>.flex-gt-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-85,.layout-gt-md-column>.flex-gt-md-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-gt-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-90,.layout-row>.flex-gt-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-90,.layout-gt-md-column>.flex-gt-md-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-gt-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-95,.layout-row>.flex-gt-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-95,.layout-gt-md-column>.flex-gt-md-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-gt-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-100,.layout-row>.flex-gt-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-md-100,.layout-gt-md-column>.flex-gt-md-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-33,.layout-row>.flex-gt-md-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex-gt-md-66,.layout-row>.flex-gt-md-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-gt-md-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-gt-md-33,.layout-gt-md-column>.flex-gt-md-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-gt-md-66,.layout-gt-md-column>.flex-gt-md-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-gt-md,.layout-gt-md-column,.layout-gt-md-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-gt-md-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-gt-md-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1280px) and (max-width:1919px){.hide-gt-md:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show),.hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show),.hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show),.hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show){display:none}.hide-lg:not(.show-lg):not(.show-gt-md):not(.show-gt-sm):not(.show-gt-xs):not(.show){display:none}.flex-order-lg--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-lg--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-lg--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-lg--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-lg--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-lg--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-lg--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-lg--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-lg--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-lg--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-lg--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-lg--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-lg--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-lg--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-lg--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-lg--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-lg--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-lg--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-lg--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-lg--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-lg-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-lg-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-lg-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-lg-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-lg-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-lg-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-lg-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-lg-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-lg-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-lg-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-lg-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-lg-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-lg-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-lg-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-lg-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-lg-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-lg-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-lg-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-lg-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-lg-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-lg-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-lg-0,.offset-lg-0{margin-left:0}.flex-offset-lg-5,.offset-lg-5{margin-left:5%}.flex-offset-lg-10,.offset-lg-10{margin-left:10%}.flex-offset-lg-15,.offset-lg-15{margin-left:15%}.flex-offset-lg-20,.offset-lg-20{margin-left:20%}.flex-offset-lg-25,.offset-lg-25{margin-left:25%}.flex-offset-lg-30,.offset-lg-30{margin-left:30%}.flex-offset-lg-35,.offset-lg-35{margin-left:35%}.flex-offset-lg-40,.offset-lg-40{margin-left:40%}.flex-offset-lg-45,.offset-lg-45{margin-left:45%}.flex-offset-lg-50,.offset-lg-50{margin-left:50%}.flex-offset-lg-55,.offset-lg-55{margin-left:55%}.flex-offset-lg-60,.offset-lg-60{margin-left:60%}.flex-offset-lg-65,.offset-lg-65{margin-left:65%}.flex-offset-lg-70,.offset-lg-70{margin-left:70%}.flex-offset-lg-75,.offset-lg-75{margin-left:75%}.flex-offset-lg-80,.offset-lg-80{margin-left:80%}.flex-offset-lg-85,.offset-lg-85{margin-left:85%}.flex-offset-lg-90,.offset-lg-90{margin-left:90%}.flex-offset-lg-95,.offset-lg-95{margin-left:95%}.flex-offset-lg-33,.offset-lg-33{margin-left:calc(100% / 3)}.flex-offset-lg-66,.offset-lg-66{margin-left:calc(200% / 3)}.layout-align-lg{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-lg-start,.layout-align-lg-start-center,.layout-align-lg-start-end,.layout-align-lg-start-start,.layout-align-lg-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-lg-center,.layout-align-lg-center-center,.layout-align-lg-center-end,.layout-align-lg-center-start,.layout-align-lg-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-lg-end,.layout-align-lg-end-center,.layout-align-lg-end-end,.layout-align-lg-end-start,.layout-align-lg-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-lg-space-around,.layout-align-lg-space-around-center,.layout-align-lg-space-around-end,.layout-align-lg-space-around-start,.layout-align-lg-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-lg-space-between,.layout-align-lg-space-between-center,.layout-align-lg-space-between-end,.layout-align-lg-space-between-start,.layout-align-lg-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-lg-center-start,.layout-align-lg-end-start,.layout-align-lg-space-around-start,.layout-align-lg-space-between-start,.layout-align-lg-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-lg-center-center,.layout-align-lg-end-center,.layout-align-lg-space-around-center,.layout-align-lg-space-between-center,.layout-align-lg-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-lg-center-center>*,.layout-align-lg-end-center>*,.layout-align-lg-space-around-center>*,.layout-align-lg-space-between-center>*,.layout-align-lg-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-lg-center-end,.layout-align-lg-end-end,.layout-align-lg-space-around-end,.layout-align-lg-space-between-end,.layout-align-lg-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-lg-center-stretch,.layout-align-lg-end-stretch,.layout-align-lg-space-around-stretch,.layout-align-lg-space-between-stretch,.layout-align-lg-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-lg{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1280px) and (max-width:1919px){.flex-lg{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1280px) and (max-width:1919px){.flex-lg-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-lg-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-lg-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-lg-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-lg-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-lg-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-0,.layout-row>.flex-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-0,.layout-lg-column>.flex-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-5,.layout-row>.flex-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-5,.layout-lg-column>.flex-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-10,.layout-row>.flex-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-10,.layout-lg-column>.flex-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-15,.layout-row>.flex-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-15,.layout-lg-column>.flex-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-20,.layout-row>.flex-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-20,.layout-lg-column>.flex-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-25,.layout-row>.flex-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-25,.layout-lg-column>.flex-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-30,.layout-row>.flex-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-30,.layout-lg-column>.flex-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-35,.layout-row>.flex-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-35,.layout-lg-column>.flex-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-40,.layout-row>.flex-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-40,.layout-lg-column>.flex-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-45,.layout-row>.flex-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-45,.layout-lg-column>.flex-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-50,.layout-row>.flex-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-50,.layout-lg-column>.flex-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-55,.layout-row>.flex-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-55,.layout-lg-column>.flex-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-60,.layout-row>.flex-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-60,.layout-lg-column>.flex-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-65,.layout-row>.flex-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-65,.layout-lg-column>.flex-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-70,.layout-row>.flex-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-70,.layout-lg-column>.flex-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-75,.layout-row>.flex-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-75,.layout-lg-column>.flex-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-80,.layout-row>.flex-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-80,.layout-lg-column>.flex-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-85,.layout-row>.flex-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-85,.layout-lg-column>.flex-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-90,.layout-row>.flex-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-90,.layout-lg-column>.flex-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-95,.layout-row>.flex-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-95,.layout-lg-column>.flex-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-100,.layout-row>.flex-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-lg-100,.layout-lg-column>.flex-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-33,.layout-row>.flex-lg-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex-lg-66,.layout-row>.flex-lg-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-lg-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-lg-33,.layout-lg-column>.flex-lg-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-lg-66,.layout-lg-column>.flex-lg-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-lg,.layout-lg-column,.layout-lg-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-lg-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-lg-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}}@media (min-width:1920px){.flex-order-gt-lg--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-gt-lg--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-gt-lg--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-gt-lg--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-gt-lg--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-gt-lg--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-gt-lg--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-gt-lg--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-gt-lg--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-gt-lg--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-gt-lg--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-gt-lg--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-gt-lg--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-gt-lg--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-gt-lg--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-gt-lg--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-gt-lg--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-gt-lg--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-gt-lg--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-gt-lg--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-gt-lg-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-gt-lg-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-gt-lg-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-gt-lg-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-gt-lg-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-gt-lg-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-gt-lg-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-gt-lg-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-gt-lg-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-gt-lg-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-gt-lg-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-gt-lg-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-gt-lg-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-gt-lg-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-gt-lg-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-gt-lg-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-gt-lg-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-gt-lg-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-gt-lg-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-gt-lg-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-gt-lg-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-gt-lg-0,.offset-gt-lg-0{margin-left:0}.flex-offset-gt-lg-5,.offset-gt-lg-5{margin-left:5%}.flex-offset-gt-lg-10,.offset-gt-lg-10{margin-left:10%}.flex-offset-gt-lg-15,.offset-gt-lg-15{margin-left:15%}.flex-offset-gt-lg-20,.offset-gt-lg-20{margin-left:20%}.flex-offset-gt-lg-25,.offset-gt-lg-25{margin-left:25%}.flex-offset-gt-lg-30,.offset-gt-lg-30{margin-left:30%}.flex-offset-gt-lg-35,.offset-gt-lg-35{margin-left:35%}.flex-offset-gt-lg-40,.offset-gt-lg-40{margin-left:40%}.flex-offset-gt-lg-45,.offset-gt-lg-45{margin-left:45%}.flex-offset-gt-lg-50,.offset-gt-lg-50{margin-left:50%}.flex-offset-gt-lg-55,.offset-gt-lg-55{margin-left:55%}.flex-offset-gt-lg-60,.offset-gt-lg-60{margin-left:60%}.flex-offset-gt-lg-65,.offset-gt-lg-65{margin-left:65%}.flex-offset-gt-lg-70,.offset-gt-lg-70{margin-left:70%}.flex-offset-gt-lg-75,.offset-gt-lg-75{margin-left:75%}.flex-offset-gt-lg-80,.offset-gt-lg-80{margin-left:80%}.flex-offset-gt-lg-85,.offset-gt-lg-85{margin-left:85%}.flex-offset-gt-lg-90,.offset-gt-lg-90{margin-left:90%}.flex-offset-gt-lg-95,.offset-gt-lg-95{margin-left:95%}.flex-offset-gt-lg-33,.offset-gt-lg-33{margin-left:calc(100% / 3)}.flex-offset-gt-lg-66,.offset-gt-lg-66{margin-left:calc(200% / 3)}.layout-align-gt-lg{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-gt-lg-start,.layout-align-gt-lg-start-center,.layout-align-gt-lg-start-end,.layout-align-gt-lg-start-start,.layout-align-gt-lg-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-gt-lg-center,.layout-align-gt-lg-center-center,.layout-align-gt-lg-center-end,.layout-align-gt-lg-center-start,.layout-align-gt-lg-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-gt-lg-end,.layout-align-gt-lg-end-center,.layout-align-gt-lg-end-end,.layout-align-gt-lg-end-start,.layout-align-gt-lg-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-gt-lg-space-around,.layout-align-gt-lg-space-around-center,.layout-align-gt-lg-space-around-end,.layout-align-gt-lg-space-around-start,.layout-align-gt-lg-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-gt-lg-space-between,.layout-align-gt-lg-space-between-center,.layout-align-gt-lg-space-between-end,.layout-align-gt-lg-space-between-start,.layout-align-gt-lg-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-gt-lg-center-start,.layout-align-gt-lg-end-start,.layout-align-gt-lg-space-around-start,.layout-align-gt-lg-space-between-start,.layout-align-gt-lg-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-gt-lg-center-center,.layout-align-gt-lg-end-center,.layout-align-gt-lg-space-around-center,.layout-align-gt-lg-space-between-center,.layout-align-gt-lg-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-gt-lg-center-center>*,.layout-align-gt-lg-end-center>*,.layout-align-gt-lg-space-around-center>*,.layout-align-gt-lg-space-between-center>*,.layout-align-gt-lg-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-gt-lg-center-end,.layout-align-gt-lg-end-end,.layout-align-gt-lg-space-around-end,.layout-align-gt-lg-space-between-end,.layout-align-gt-lg-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-gt-lg-center-stretch,.layout-align-gt-lg-end-stretch,.layout-align-gt-lg-space-around-stretch,.layout-align-gt-lg-space-between-stretch,.layout-align-gt-lg-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-gt-lg{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1920px){.flex-gt-lg{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1920px){.flex-gt-lg-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-gt-lg-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-lg-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-gt-lg-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-gt-lg-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-gt-lg-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-gt-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-0,.layout-row>.flex-gt-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-0,.layout-gt-lg-column>.flex-gt-lg-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-gt-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-5,.layout-row>.flex-gt-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-5,.layout-gt-lg-column>.flex-gt-lg-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-gt-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-10,.layout-row>.flex-gt-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-10,.layout-gt-lg-column>.flex-gt-lg-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-gt-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-15,.layout-row>.flex-gt-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-15,.layout-gt-lg-column>.flex-gt-lg-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-gt-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-20,.layout-row>.flex-gt-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-20,.layout-gt-lg-column>.flex-gt-lg-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-gt-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-25,.layout-row>.flex-gt-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-25,.layout-gt-lg-column>.flex-gt-lg-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-gt-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-30,.layout-row>.flex-gt-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-30,.layout-gt-lg-column>.flex-gt-lg-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-gt-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-35,.layout-row>.flex-gt-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-35,.layout-gt-lg-column>.flex-gt-lg-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-gt-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-40,.layout-row>.flex-gt-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-40,.layout-gt-lg-column>.flex-gt-lg-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-gt-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-45,.layout-row>.flex-gt-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-45,.layout-gt-lg-column>.flex-gt-lg-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-gt-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-50,.layout-row>.flex-gt-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-50,.layout-gt-lg-column>.flex-gt-lg-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-gt-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-55,.layout-row>.flex-gt-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-55,.layout-gt-lg-column>.flex-gt-lg-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-gt-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-60,.layout-row>.flex-gt-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-60,.layout-gt-lg-column>.flex-gt-lg-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-gt-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-65,.layout-row>.flex-gt-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-65,.layout-gt-lg-column>.flex-gt-lg-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-gt-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-70,.layout-row>.flex-gt-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-70,.layout-gt-lg-column>.flex-gt-lg-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-gt-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-75,.layout-row>.flex-gt-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-75,.layout-gt-lg-column>.flex-gt-lg-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-gt-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-80,.layout-row>.flex-gt-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-80,.layout-gt-lg-column>.flex-gt-lg-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-gt-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-85,.layout-row>.flex-gt-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-85,.layout-gt-lg-column>.flex-gt-lg-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-gt-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-90,.layout-row>.flex-gt-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-90,.layout-gt-lg-column>.flex-gt-lg-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-gt-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-95,.layout-row>.flex-gt-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-95,.layout-gt-lg-column>.flex-gt-lg-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-gt-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-100,.layout-row>.flex-gt-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-gt-lg-100,.layout-gt-lg-column>.flex-gt-lg-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-33,.layout-row>.flex-gt-lg-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex-gt-lg-66,.layout-row>.flex-gt-lg-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-gt-lg-row>.flex,.layout-row>.flex{min-width:0}.layout-column>.flex-gt-lg-33,.layout-gt-lg-column>.flex-gt-lg-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-gt-lg-66,.layout-gt-lg-column>.flex-gt-lg-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-gt-lg,.layout-gt-lg-column,.layout-gt-lg-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-gt-lg-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-gt-lg-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.flex-order-xl--20{-webkit-order:-20;-ms-flex-order:-20;order:-20}.flex-order-xl--19{-webkit-order:-19;-ms-flex-order:-19;order:-19}.flex-order-xl--18{-webkit-order:-18;-ms-flex-order:-18;order:-18}.flex-order-xl--17{-webkit-order:-17;-ms-flex-order:-17;order:-17}.flex-order-xl--16{-webkit-order:-16;-ms-flex-order:-16;order:-16}.flex-order-xl--15{-webkit-order:-15;-ms-flex-order:-15;order:-15}.flex-order-xl--14{-webkit-order:-14;-ms-flex-order:-14;order:-14}.flex-order-xl--13{-webkit-order:-13;-ms-flex-order:-13;order:-13}.flex-order-xl--12{-webkit-order:-12;-ms-flex-order:-12;order:-12}.flex-order-xl--11{-webkit-order:-11;-ms-flex-order:-11;order:-11}.flex-order-xl--10{-webkit-order:-10;-ms-flex-order:-10;order:-10}.flex-order-xl--9{-webkit-order:-9;-ms-flex-order:-9;order:-9}.flex-order-xl--8{-webkit-order:-8;-ms-flex-order:-8;order:-8}.flex-order-xl--7{-webkit-order:-7;-ms-flex-order:-7;order:-7}.flex-order-xl--6{-webkit-order:-6;-ms-flex-order:-6;order:-6}.flex-order-xl--5{-webkit-order:-5;-ms-flex-order:-5;order:-5}.flex-order-xl--4{-webkit-order:-4;-ms-flex-order:-4;order:-4}.flex-order-xl--3{-webkit-order:-3;-ms-flex-order:-3;order:-3}.flex-order-xl--2{-webkit-order:-2;-ms-flex-order:-2;order:-2}.flex-order-xl--1{-webkit-order:-1;-ms-flex-order:-1;order:-1}.flex-order-xl-0{-webkit-order:0;-ms-flex-order:0;order:0}.flex-order-xl-1{-webkit-order:1;-ms-flex-order:1;order:1}.flex-order-xl-2{-webkit-order:2;-ms-flex-order:2;order:2}.flex-order-xl-3{-webkit-order:3;-ms-flex-order:3;order:3}.flex-order-xl-4{-webkit-order:4;-ms-flex-order:4;order:4}.flex-order-xl-5{-webkit-order:5;-ms-flex-order:5;order:5}.flex-order-xl-6{-webkit-order:6;-ms-flex-order:6;order:6}.flex-order-xl-7{-webkit-order:7;-ms-flex-order:7;order:7}.flex-order-xl-8{-webkit-order:8;-ms-flex-order:8;order:8}.flex-order-xl-9{-webkit-order:9;-ms-flex-order:9;order:9}.flex-order-xl-10{-webkit-order:10;-ms-flex-order:10;order:10}.flex-order-xl-11{-webkit-order:11;-ms-flex-order:11;order:11}.flex-order-xl-12{-webkit-order:12;-ms-flex-order:12;order:12}.flex-order-xl-13{-webkit-order:13;-ms-flex-order:13;order:13}.flex-order-xl-14{-webkit-order:14;-ms-flex-order:14;order:14}.flex-order-xl-15{-webkit-order:15;-ms-flex-order:15;order:15}.flex-order-xl-16{-webkit-order:16;-ms-flex-order:16;order:16}.flex-order-xl-17{-webkit-order:17;-ms-flex-order:17;order:17}.flex-order-xl-18{-webkit-order:18;-ms-flex-order:18;order:18}.flex-order-xl-19{-webkit-order:19;-ms-flex-order:19;order:19}.flex-order-xl-20{-webkit-order:20;-ms-flex-order:20;order:20}.flex-offset-xl-0,.offset-xl-0{margin-left:0}.flex-offset-xl-5,.offset-xl-5{margin-left:5%}.flex-offset-xl-10,.offset-xl-10{margin-left:10%}.flex-offset-xl-15,.offset-xl-15{margin-left:15%}.flex-offset-xl-20,.offset-xl-20{margin-left:20%}.flex-offset-xl-25,.offset-xl-25{margin-left:25%}.flex-offset-xl-30,.offset-xl-30{margin-left:30%}.flex-offset-xl-35,.offset-xl-35{margin-left:35%}.flex-offset-xl-40,.offset-xl-40{margin-left:40%}.flex-offset-xl-45,.offset-xl-45{margin-left:45%}.flex-offset-xl-50,.offset-xl-50{margin-left:50%}.flex-offset-xl-55,.offset-xl-55{margin-left:55%}.flex-offset-xl-60,.offset-xl-60{margin-left:60%}.flex-offset-xl-65,.offset-xl-65{margin-left:65%}.flex-offset-xl-70,.offset-xl-70{margin-left:70%}.flex-offset-xl-75,.offset-xl-75{margin-left:75%}.flex-offset-xl-80,.offset-xl-80{margin-left:80%}.flex-offset-xl-85,.offset-xl-85{margin-left:85%}.flex-offset-xl-90,.offset-xl-90{margin-left:90%}.flex-offset-xl-95,.offset-xl-95{margin-left:95%}.flex-offset-xl-33,.offset-xl-33{margin-left:calc(100% / 3)}.flex-offset-xl-66,.offset-xl-66{margin-left:calc(200% / 3)}.layout-align-xl{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch}.layout-align-xl-start,.layout-align-xl-start-center,.layout-align-xl-start-end,.layout-align-xl-start-start,.layout-align-xl-start-stretch{-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start}.layout-align-xl-center,.layout-align-xl-center-center,.layout-align-xl-center-end,.layout-align-xl-center-start,.layout-align-xl-center-stretch{-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.layout-align-xl-end,.layout-align-xl-end-center,.layout-align-xl-end-end,.layout-align-xl-end-start,.layout-align-xl-end-stretch{-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.layout-align-xl-space-around,.layout-align-xl-space-around-center,.layout-align-xl-space-around-end,.layout-align-xl-space-around-start,.layout-align-xl-space-around-stretch{-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around}.layout-align-xl-space-between,.layout-align-xl-space-between-center,.layout-align-xl-space-between-end,.layout-align-xl-space-between-start,.layout-align-xl-space-between-stretch{-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.layout-align-xl-center-start,.layout-align-xl-end-start,.layout-align-xl-space-around-start,.layout-align-xl-space-between-start,.layout-align-xl-start-start{-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-align-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layout-align-xl-center-center,.layout-align-xl-end-center,.layout-align-xl-space-around-center,.layout-align-xl-space-between-center,.layout-align-xl-start-center{-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-align-content:center;-ms-flex-line-pack:center;align-content:center;max-width:100%}.layout-align-xl-center-center>*,.layout-align-xl-end-center>*,.layout-align-xl-space-around-center>*,.layout-align-xl-space-between-center>*,.layout-align-xl-start-center>*{max-width:100%;box-sizing:border-box}.layout-align-xl-center-end,.layout-align-xl-end-end,.layout-align-xl-space-around-end,.layout-align-xl-space-between-end,.layout-align-xl-start-end{-webkit-align-items:flex-end;-ms-flex-align:end;align-items:flex-end;-webkit-align-content:flex-end;-ms-flex-line-pack:end;align-content:flex-end}.layout-align-xl-center-stretch,.layout-align-xl-end-stretch,.layout-align-xl-space-around-stretch,.layout-align-xl-space-between-stretch,.layout-align-xl-start-stretch{-webkit-align-items:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch}.flex-xl{-webkit-flex:1;-ms-flex:1;flex:1;box-sizing:border-box}}@media screen\\0 and (min-width:1920px){.flex-xl{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%}}@media (min-width:1920px){.flex-xl-grow{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;box-sizing:border-box}.flex-xl-initial{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-xl-auto{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;box-sizing:border-box}.flex-xl-none{-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;box-sizing:border-box}.flex-xl-noshrink{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;box-sizing:border-box}.flex-xl-nogrow{-webkit-flex:0 1 auto;-ms-flex:0 1 auto;flex:0 1 auto;box-sizing:border-box}.flex-xl-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-0,.layout-xl-row>.flex-xl-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:0;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-0,.layout-xl-column>.flex-xl-0{-webkit-flex:1 1 0%;-ms-flex:1 1 0%;flex:1 1 0%;max-width:100%;max-height:0%;box-sizing:border-box}.flex-xl-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-5,.layout-xl-row>.flex-xl-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:5%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-5,.layout-xl-column>.flex-xl-5{-webkit-flex:1 1 5%;-ms-flex:1 1 5%;flex:1 1 5%;max-width:100%;max-height:5%;box-sizing:border-box}.flex-xl-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-10,.layout-xl-row>.flex-xl-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:10%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-10,.layout-xl-column>.flex-xl-10{-webkit-flex:1 1 10%;-ms-flex:1 1 10%;flex:1 1 10%;max-width:100%;max-height:10%;box-sizing:border-box}.flex-xl-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-15,.layout-xl-row>.flex-xl-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:15%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-15,.layout-xl-column>.flex-xl-15{-webkit-flex:1 1 15%;-ms-flex:1 1 15%;flex:1 1 15%;max-width:100%;max-height:15%;box-sizing:border-box}.flex-xl-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-20,.layout-xl-row>.flex-xl-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:20%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-20,.layout-xl-column>.flex-xl-20{-webkit-flex:1 1 20%;-ms-flex:1 1 20%;flex:1 1 20%;max-width:100%;max-height:20%;box-sizing:border-box}.flex-xl-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-25,.layout-xl-row>.flex-xl-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:25%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-25,.layout-xl-column>.flex-xl-25{-webkit-flex:1 1 25%;-ms-flex:1 1 25%;flex:1 1 25%;max-width:100%;max-height:25%;box-sizing:border-box}.flex-xl-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-30,.layout-xl-row>.flex-xl-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:30%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-30,.layout-xl-column>.flex-xl-30{-webkit-flex:1 1 30%;-ms-flex:1 1 30%;flex:1 1 30%;max-width:100%;max-height:30%;box-sizing:border-box}.flex-xl-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-35,.layout-xl-row>.flex-xl-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:35%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-35,.layout-xl-column>.flex-xl-35{-webkit-flex:1 1 35%;-ms-flex:1 1 35%;flex:1 1 35%;max-width:100%;max-height:35%;box-sizing:border-box}.flex-xl-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-40,.layout-xl-row>.flex-xl-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:40%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-40,.layout-xl-column>.flex-xl-40{-webkit-flex:1 1 40%;-ms-flex:1 1 40%;flex:1 1 40%;max-width:100%;max-height:40%;box-sizing:border-box}.flex-xl-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-45,.layout-xl-row>.flex-xl-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:45%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-45,.layout-xl-column>.flex-xl-45{-webkit-flex:1 1 45%;-ms-flex:1 1 45%;flex:1 1 45%;max-width:100%;max-height:45%;box-sizing:border-box}.flex-xl-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-50,.layout-xl-row>.flex-xl-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:50%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-50,.layout-xl-column>.flex-xl-50{-webkit-flex:1 1 50%;-ms-flex:1 1 50%;flex:1 1 50%;max-width:100%;max-height:50%;box-sizing:border-box}.flex-xl-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-55,.layout-xl-row>.flex-xl-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:55%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-55,.layout-xl-column>.flex-xl-55{-webkit-flex:1 1 55%;-ms-flex:1 1 55%;flex:1 1 55%;max-width:100%;max-height:55%;box-sizing:border-box}.flex-xl-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-60,.layout-xl-row>.flex-xl-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:60%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-60,.layout-xl-column>.flex-xl-60{-webkit-flex:1 1 60%;-ms-flex:1 1 60%;flex:1 1 60%;max-width:100%;max-height:60%;box-sizing:border-box}.flex-xl-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-65,.layout-xl-row>.flex-xl-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:65%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-65,.layout-xl-column>.flex-xl-65{-webkit-flex:1 1 65%;-ms-flex:1 1 65%;flex:1 1 65%;max-width:100%;max-height:65%;box-sizing:border-box}.flex-xl-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-70,.layout-xl-row>.flex-xl-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:70%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-70,.layout-xl-column>.flex-xl-70{-webkit-flex:1 1 70%;-ms-flex:1 1 70%;flex:1 1 70%;max-width:100%;max-height:70%;box-sizing:border-box}.flex-xl-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-75,.layout-xl-row>.flex-xl-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:75%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-75,.layout-xl-column>.flex-xl-75{-webkit-flex:1 1 75%;-ms-flex:1 1 75%;flex:1 1 75%;max-width:100%;max-height:75%;box-sizing:border-box}.flex-xl-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-80,.layout-xl-row>.flex-xl-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:80%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-80,.layout-xl-column>.flex-xl-80{-webkit-flex:1 1 80%;-ms-flex:1 1 80%;flex:1 1 80%;max-width:100%;max-height:80%;box-sizing:border-box}.flex-xl-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-85,.layout-xl-row>.flex-xl-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:85%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-85,.layout-xl-column>.flex-xl-85{-webkit-flex:1 1 85%;-ms-flex:1 1 85%;flex:1 1 85%;max-width:100%;max-height:85%;box-sizing:border-box}.flex-xl-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-90,.layout-xl-row>.flex-xl-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:90%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-90,.layout-xl-column>.flex-xl-90{-webkit-flex:1 1 90%;-ms-flex:1 1 90%;flex:1 1 90%;max-width:100%;max-height:90%;box-sizing:border-box}.flex-xl-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-95,.layout-xl-row>.flex-xl-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:95%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-95,.layout-xl-column>.flex-xl-95{-webkit-flex:1 1 95%;-ms-flex:1 1 95%;flex:1 1 95%;max-width:100%;max-height:95%;box-sizing:border-box}.flex-xl-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-100,.layout-xl-row>.flex-xl-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-column>.flex-xl-100,.layout-xl-column>.flex-xl-100{-webkit-flex:1 1 100%;-ms-flex:1 1 100%;flex:1 1 100%;max-width:100%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-33,.layout-xl-row>.flex-xl-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:33.33%;max-height:100%;box-sizing:border-box}.layout-row>.flex-xl-66,.layout-xl-row>.flex-xl-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:66.66%;max-height:100%;box-sizing:border-box}.layout-row>.flex,.layout-xl-row>.flex{min-width:0}.layout-column>.flex-xl-33,.layout-xl-column>.flex-xl-33{-webkit-flex:1 1 33.33%;-ms-flex:1 1 33.33%;flex:1 1 33.33%;max-width:100%;max-height:33.33%;box-sizing:border-box}.layout-column>.flex-xl-66,.layout-xl-column>.flex-xl-66{-webkit-flex:1 1 66.66%;-ms-flex:1 1 66.66%;flex:1 1 66.66%;max-width:100%;max-height:66.66%;box-sizing:border-box}.layout-xl,.layout-xl-column,.layout-xl-row{box-sizing:border-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.layout-xl-column{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.layout-xl-row{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.hide-gt-lg:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show),.hide-gt-md:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show),.hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show),.hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show),.hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show){display:none}.hide-xl:not(.show-xl):not(.show-gt-lg):not(.show-gt-md):not(.show-gt-sm):not(.show-gt-xs):not(.show){display:none}}@media print{.hide-print:not(.show-print):not(.show){display:none!important}}");
})
(function(factory) {
  factory();
});
//# sourceMappingURL=build.js.map